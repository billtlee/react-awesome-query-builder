(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("React"), require("Immutable"), require("moment"), require("lodash/omit"), require("lodash/pick"), require("lodash/keys"), require("ReactRedux"), require("lodash/last"), require("lodash/mapValues"), require("lodash/merge"), require("lodash/range"), require("classnames"), require("lodash/mergeWith"), require("Redux"), require("lodash/pickBy"), require("lodash/startsWith"), require("sqlstring"));
	else if(typeof define === 'function' && define.amd)
		define(["React", "Immutable", "moment", "lodash/omit", "lodash/pick", "lodash/keys", "ReactRedux", "lodash/last", "lodash/mapValues", "lodash/merge", "lodash/range", "classnames", "lodash/mergeWith", "Redux", "lodash/pickBy", "lodash/startsWith", "sqlstring"], factory);
	else if(typeof exports === 'object')
		exports["ReactAwesomeQueryBuilder"] = factory(require("React"), require("Immutable"), require("moment"), require("lodash/omit"), require("lodash/pick"), require("lodash/keys"), require("ReactRedux"), require("lodash/last"), require("lodash/mapValues"), require("lodash/merge"), require("lodash/range"), require("classnames"), require("lodash/mergeWith"), require("Redux"), require("lodash/pickBy"), require("lodash/startsWith"), require("sqlstring"));
	else
		root["ReactAwesomeQueryBuilder"] = factory(root["React"], root["Immutable"], root["moment"], root["lodash/omit"], root["lodash/pick"], root["lodash/keys"], root["ReactRedux"], root["lodash/last"], root["lodash/mapValues"], root["lodash/merge"], root["lodash/range"], root["classnames"], root["lodash/mergeWith"], root["Redux"], root["lodash/pickBy"], root["lodash/startsWith"], root["sqlstring"]);
})(window, function(__WEBPACK_EXTERNAL_MODULE__0__, __WEBPACK_EXTERNAL_MODULE__5__, __WEBPACK_EXTERNAL_MODULE__9__, __WEBPACK_EXTERNAL_MODULE__11__, __WEBPACK_EXTERNAL_MODULE__12__, __WEBPACK_EXTERNAL_MODULE__17__, __WEBPACK_EXTERNAL_MODULE__18__, __WEBPACK_EXTERNAL_MODULE__20__, __WEBPACK_EXTERNAL_MODULE__22__, __WEBPACK_EXTERNAL_MODULE__23__, __WEBPACK_EXTERNAL_MODULE__24__, __WEBPACK_EXTERNAL_MODULE__26__, __WEBPACK_EXTERNAL_MODULE__27__, __WEBPACK_EXTERNAL_MODULE__28__, __WEBPACK_EXTERNAL_MODULE__29__, __WEBPACK_EXTERNAL_MODULE__30__, __WEBPACK_EXTERNAL_MODULE__35__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 36);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__0__;

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (false) { var throwOnDirectAccess, ReactIs; } else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = __webpack_require__(32)();
}


/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return extendConfig; });
/* unused harmony export getFieldRawConfig */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return getFuncConfig; });
/* unused harmony export getFuncArgConfig */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return getFieldConfig; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return getFirstField; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return getOperatorsForField; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return getFirstOperator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return getFieldPath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return getFuncPathLabels; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return getFieldPathLabels; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return getOperatorConfig; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return getFieldWidgetConfig; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return getValueLabel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() { return getWidgetsForFieldOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return getValueSourcesForFieldOp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return getWidgetForFieldOp; });
/* harmony import */ var lodash_last__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(20);
/* harmony import */ var lodash_last__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_last__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash_merge__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(23);
/* harmony import */ var lodash_merge__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_merge__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var lodash_mergeWith__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(27);
/* harmony import */ var lodash_mergeWith__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_mergeWith__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _config_default__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(15);
/* harmony import */ var moment__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(9);
/* harmony import */ var moment__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(moment__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _stuff__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(3);


function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }







var extendConfig = function extendConfig(config) {
  //operators, defaultOperator - merge
  //widgetProps (including valueLabel, valuePlaceholder, hideOperator, operatorInlineLabel) - concrete by widget
  if (config.__extended) return config;
  config.settings = lodash_merge__WEBPACK_IMPORTED_MODULE_1___default()({}, _config_default__WEBPACK_IMPORTED_MODULE_3__[/* settings */ "a"], config.settings);
  config._fieldsCntByType = {};
  config._funcsCntByType = {};

  _extendTypesConfig(config.types, config);

  _extendFieldsConfig(config.fields, config);

  _extendFuncArgsConfig(config.funcs, config);

  moment__WEBPACK_IMPORTED_MODULE_4___default.a.locale(config.settings.locale.moment);
  Object.defineProperty(config, "__extended", {
    enumerable: false,
    writable: false,
    value: true
  });
  return config;
};

function _extendTypesConfig(typesConfig, config) {
  for (var type in typesConfig) {
    var typeConfig = typesConfig[type];

    _extendTypeConfig(type, typeConfig, config);
  }
}

function _extendTypeConfig(type, typeConfig, config) {
  var operators = null,
      defaultOperator = null;
  typeConfig.mainWidget = typeConfig.mainWidget || Object.keys(typeConfig.widgets).filter(function (w) {
    return w != "field" && w != "func";
  })[0];

  for (var widget in typeConfig.widgets) {
    var typeWidgetConfig = typeConfig.widgets[widget];

    if (typeWidgetConfig.operators) {
      if (!operators) operators = [];
      operators = operators.concat(typeWidgetConfig.operators.slice());
    }

    if (typeWidgetConfig.defaultOperator) defaultOperator = typeWidgetConfig.defaultOperator;

    if (widget == typeConfig.mainWidget) {
      typeWidgetConfig = lodash_merge__WEBPACK_IMPORTED_MODULE_1___default()({}, {
        widgetProps: typeConfig.mainWidgetProps || {}
      }, typeWidgetConfig);
    }

    typeConfig.widgets[widget] = typeWidgetConfig;
  }

  if (!typeConfig.valueSources) typeConfig.valueSources = Object.keys(config.settings.valueSourcesInfo);

  var _iterator = _createForOfIteratorHelper(typeConfig.valueSources),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var valueSrc = _step.value;

      if (valueSrc != "value" && !typeConfig.widgets[valueSrc]) {
        typeConfig.widgets[valueSrc] = {};
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  if (!typeConfig.operators && operators) typeConfig.operators = Array.from(new Set(operators)); //unique

  if (!typeConfig.defaultOperator && defaultOperator) typeConfig.defaultOperator = defaultOperator;
}

function _extendFieldsConfig(subconfig, config) {
  for (var field in subconfig) {
    _extendFieldConfig(subconfig[field], config);

    if (subconfig[field].subfields) {
      _extendFieldsConfig(subconfig[field].subfields, config);
    }
  }
}

function _extendFuncArgsConfig(subconfig, config) {
  if (!subconfig) return;

  for (var funcKey in subconfig) {
    var funcDef = subconfig[funcKey];

    if (funcDef.returnType) {
      if (!config._funcsCntByType[funcDef.returnType]) config._funcsCntByType[funcDef.returnType] = 0;
      config._funcsCntByType[funcDef.returnType]++;
    }

    for (var argKey in funcDef.args) {
      _extendFieldConfig(funcDef.args[argKey], config, true);
    } // isOptional can be only in the end


    if (funcDef.args) {
      var argKeys = Object.keys(funcDef.args);
      var tmpIsOptional = true;

      var _iterator2 = _createForOfIteratorHelper(argKeys.reverse()),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var _argKey = _step2.value;
          var argDef = funcDef.args[_argKey];

          if (!tmpIsOptional && argDef.isOptional) {
            delete argDef.isOptional;
          }

          if (!argDef.isOptional) tmpIsOptional = false;
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }

    if (funcDef.subfields) {
      _extendFuncArgsConfig(funcDef.subfields, config);
    }
  }
}

function _extendFieldConfig(fieldConfig, config) {
  var isFuncArg = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var operators = null,
      defaultOperator = null;
  var typeConfig = config.types[fieldConfig.type];
  var excludeOperators = fieldConfig.excludeOperators || [];

  if (fieldConfig.type != "!struct" && fieldConfig.type != "!group") {
    if (!typeConfig) {
      //console.warn(`No type config for ${fieldConfig.type}`);
      fieldConfig.disabled = true;
      return;
    }

    if (!isFuncArg) {
      if (!config._fieldsCntByType[fieldConfig.type]) config._fieldsCntByType[fieldConfig.type] = 0;
      config._fieldsCntByType[fieldConfig.type]++;
    }

    if (!fieldConfig.widgets) fieldConfig.widgets = {};
    fieldConfig.mainWidget = fieldConfig.mainWidget || typeConfig.mainWidget;
    fieldConfig.valueSources = fieldConfig.valueSources || typeConfig.valueSources;

    for (var widget in typeConfig.widgets) {
      var fieldWidgetConfig = fieldConfig.widgets[widget] || {};
      var typeWidgetConfig = typeConfig.widgets[widget] || {};

      if (!isFuncArg) {
        var shouldIncludeOperators = fieldConfig.preferWidgets && (widget == "field" || fieldConfig.preferWidgets.includes(widget)) || excludeOperators.length > 0;

        if (fieldWidgetConfig.operators) {
          if (!operators) operators = [];
          operators = operators.concat(fieldWidgetConfig.operators.filter(function (o) {
            return !excludeOperators.includes(o);
          }));
        } else if (shouldIncludeOperators && typeWidgetConfig.operators) {
          if (!operators) operators = [];
          operators = operators.concat(typeWidgetConfig.operators.filter(function (o) {
            return !excludeOperators.includes(o);
          }));
        }

        if (fieldWidgetConfig.defaultOperator) defaultOperator = fieldWidgetConfig.defaultOperator;
      }

      if (widget == fieldConfig.mainWidget) {
        fieldWidgetConfig = lodash_merge__WEBPACK_IMPORTED_MODULE_1___default()({}, {
          widgetProps: fieldConfig.mainWidgetProps || {}
        }, fieldWidgetConfig);
      }

      fieldConfig.widgets[widget] = fieldWidgetConfig;
    }

    if (!isFuncArg) {
      if (!fieldConfig.operators && operators) fieldConfig.operators = Array.from(new Set(operators));
      if (!fieldConfig.defaultOperator && defaultOperator) fieldConfig.defaultOperator = defaultOperator;
    }

    var keysToPutInFieldSettings = ["listValues", "allowCustomValues", "validateValue"];
    if (!fieldConfig.fieldSettings) fieldConfig.fieldSettings = {};

    for (var _i = 0, _keysToPutInFieldSett = keysToPutInFieldSettings; _i < _keysToPutInFieldSett.length; _i++) {
      var k = _keysToPutInFieldSett[_i];

      if (fieldConfig[k]) {
        fieldConfig.fieldSettings[k] = fieldConfig[k];
        delete fieldConfig[k];
      }
    }

    if (fieldConfig.fieldSettings.listValues) {
      fieldConfig.fieldSettings.listValues = Object(_stuff__WEBPACK_IMPORTED_MODULE_5__[/* normalizeListValues */ "j"])(fieldConfig.fieldSettings.listValues, fieldConfig.type, fieldConfig.fieldSettings);
    }
  }
}

var getFieldRawConfig = function getFieldRawConfig(field, config) {
  var fieldsKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "fields";
  var subfieldsKey = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "subfields";
  if (!field) return null;
  var fieldSeparator = config.settings.fieldSeparator;
  var parts = Array.isArray(field) ? field : field.split(fieldSeparator);
  var targetFields = config[fieldsKey];
  if (!targetFields) return null;
  var fields = targetFields;
  var fieldConfig = null;
  var path = [];

  for (var i = 0; i < parts.length; i++) {
    var part = parts[i];
    path.push(part);
    var pathKey = path.join(fieldSeparator);
    fieldConfig = fields[pathKey];

    if (i < parts.length - 1) {
      if (fieldConfig && fieldConfig[subfieldsKey]) {
        fields = fieldConfig[subfieldsKey];
        path = [];
      } else {
        fieldConfig = null;
      }
    }
  }

  return fieldConfig;
};
var getFuncConfig = function getFuncConfig(func, config) {
  if (!func) return null;
  var funcConfig = getFieldRawConfig(func, config, "funcs", "subfields");
  if (!funcConfig) return null; //throw new Error("Can't find func " + func + ", please check your config");

  return funcConfig;
};
var getFuncArgConfig = function getFuncArgConfig(funcKey, argKey, config) {
  var funcConfig = getFuncConfig(funcKey, config);
  if (!funcConfig) return null; //throw new Error(`Can't find func ${funcKey}, please check your config`);

  var argConfig = funcConfig.args && funcConfig.args[argKey] || null;
  if (!argConfig) return null; //throw new Error(`Can't find arg ${argKey} for func ${funcKey}, please check your config`);
  //merge, but don't merge operators (rewrite instead)

  var typeConfig = config.types[argConfig.type] || {};
  var ret = lodash_mergeWith__WEBPACK_IMPORTED_MODULE_2___default()({}, typeConfig, argConfig || {}, function (objValue, srcValue, _key, _object, _source, _stack) {
    if (Array.isArray(objValue)) {
      return srcValue;
    }
  });
  return ret;
};
var getFieldConfig = function getFieldConfig(field, config) {
  if (!field) return null;
  if (_typeof(field) == "object" && !field.func && !!field.type) return field;
  if (_typeof(field) == "object" && field.func && field.arg) return getFuncArgConfig(field.func, field.arg, config);
  var fieldConfig = getFieldRawConfig(field, config);
  if (!fieldConfig) return null; //throw new Error("Can't find field " + field + ", please check your config");
  //merge, but don't merge operators (rewrite instead)

  var typeConfig = config.types[fieldConfig.type] || {};
  var ret = lodash_mergeWith__WEBPACK_IMPORTED_MODULE_2___default()({}, typeConfig, fieldConfig || {}, function (objValue, srcValue, _key, _object, _source, _stack) {
    if (Array.isArray(objValue)) {
      return srcValue;
    }
  });
  return ret;
};
var getFirstField = function getFirstField(config) {
  var parentRuleGroupPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var fieldSeparator = config.settings.fieldSeparator;
  var parentPathArr = typeof parentRuleGroupPath == "string" ? parentRuleGroupPath.split(fieldSeparator) : parentRuleGroupPath;
  var parentField = parentRuleGroupPath ? getFieldRawConfig(parentRuleGroupPath, config) : config;
  var firstField = parentField,
      key = null,
      keysPath = [];

  do {
    var subfields = firstField === config ? config.fields : firstField.subfields;

    if (!subfields || !Object.keys(subfields).length) {
      firstField = key = null;
      break;
    }

    key = Object.keys(subfields)[0];
    keysPath.push(key);
    firstField = subfields[key];
  } while (firstField.type == "!struct" || firstField.type == "!group");

  return (parentPathArr || []).concat(keysPath).join(fieldSeparator);
};
var getOperatorsForField = function getOperatorsForField(config, field) {
  var fieldConfig = getFieldConfig(field, config);
  var fieldOps = fieldConfig ? fieldConfig.operators : [];
  return fieldOps;
};
var getFirstOperator = function getFirstOperator(config, field) {
  var fieldOps = getOperatorsForField(config, field);
  return fieldOps ? fieldOps[0] : null;
};
var getFieldPath = function getFieldPath(field, config) {
  var onlyKeys = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  if (!field) return null;
  var fieldSeparator = config.settings.fieldSeparator;
  var parts = Array.isArray(field) ? field : field.split(fieldSeparator);
  if (onlyKeys) return parts;else return parts.map(function (_curr, ind, arr) {
    return arr.slice(0, ind + 1);
  }).map(function (parts) {
    return parts.join(fieldSeparator);
  });
};
var getFuncPathLabels = function getFuncPathLabels(field, config) {
  return getFieldPathLabels(field, config, "funcs", "subfields");
};
var getFieldPathLabels = function getFieldPathLabels(field, config) {
  var fieldsKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "fields";
  var subfieldsKey = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "subfields";
  if (!field) return null;
  var fieldSeparator = config.settings.fieldSeparator;
  var parts = Array.isArray(field) ? field : field.split(fieldSeparator);
  return parts.map(function (_curr, ind, arr) {
    return arr.slice(0, ind + 1);
  }).map(function (parts) {
    return parts.join(fieldSeparator);
  }).map(function (part) {
    var cnf = getFieldRawConfig(part, config, fieldsKey, subfieldsKey);
    return cnf && cnf.label || cnf && lodash_last__WEBPACK_IMPORTED_MODULE_0___default()(part.split(fieldSeparator));
  }).filter(function (label) {
    return label != null;
  });
};
var getOperatorConfig = function getOperatorConfig(config, operator) {
  var field = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  if (!operator) return null;
  var opConfig = config.operators[operator];

  if (field) {
    var fieldConfig = getFieldConfig(field, config);
    var widget = getWidgetForFieldOp(config, field, operator);
    var widgetConfig = config.widgets[widget] || {};
    var fieldWidgetConfig = (fieldConfig && fieldConfig.widgets ? fieldConfig.widgets[widget] : {}) || {};
    var widgetOpProps = (widgetConfig.opProps || {})[operator];
    var fieldWidgetOpProps = (fieldWidgetConfig.opProps || {})[operator];
    var mergedOpConfig = lodash_merge__WEBPACK_IMPORTED_MODULE_1___default()({}, opConfig, widgetOpProps, fieldWidgetOpProps);
    return mergedOpConfig;
  } else {
    return opConfig;
  }
};
var getFieldWidgetConfig = function getFieldWidgetConfig(config, field, operator) {
  var widget = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var valueSrc = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
  if (!field || !(operator || widget)) return null;
  var fieldConfig = getFieldConfig(field, config);
  if (!widget) widget = getWidgetForFieldOp(config, field, operator, valueSrc);
  var widgetConfig = config.widgets[widget] || {};
  var fieldWidgetConfig = (fieldConfig && fieldConfig.widgets ? fieldConfig.widgets[widget] : {}) || {};
  var fieldWidgetProps = fieldWidgetConfig.widgetProps || {};
  var valueFieldSettings = (valueSrc == "value" || !valueSrc) && fieldConfig && fieldConfig.fieldSettings || {}; // useful to take 'validateValue'

  var mergedConfig = lodash_merge__WEBPACK_IMPORTED_MODULE_1___default()({}, widgetConfig, fieldWidgetProps, valueFieldSettings);
  return mergedConfig;
};
var getValueLabel = function getValueLabel(config, field, operator, delta) {
  var valueSrc = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
  var isSpecialRange = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
  var isFuncArg = _typeof(field) == "object" && field.arg;
  var showLabels = config.settings.showLabels;
  var fieldConfig = getFieldConfig(field, config);
  var fieldWidgetConfig = getFieldWidgetConfig(config, field, operator, null, valueSrc) || {};
  var mergedOpConfig = getOperatorConfig(config, operator, field) || {};
  var cardinality = isSpecialRange ? 1 : mergedOpConfig.cardinality;
  var ret = null;

  if (cardinality > 1) {
    var valueLabels = fieldWidgetConfig.valueLabels || mergedOpConfig.valueLabels;
    if (valueLabels) ret = valueLabels[delta];

    if (ret && _typeof(ret) != "object") {
      ret = {
        label: ret,
        placeholder: ret
      };
    }

    if (!ret) {
      ret = {
        label: config.settings.valueLabel + " " + (delta + 1),
        placeholder: config.settings.valuePlaceholder + " " + (delta + 1)
      };
    }
  } else {
    var label = fieldWidgetConfig.valueLabel;
    var placeholder = fieldWidgetConfig.valuePlaceholder;

    if (isFuncArg) {
      if (!label) label = fieldConfig.label || field.arg;
      if (!placeholder && !showLabels) placeholder = fieldConfig.label || field.arg;
    }

    ret = {
      label: label || config.settings.valueLabel,
      placeholder: placeholder || config.settings.valuePlaceholder
    };
  }

  return ret;
};

function _getWidgetsAndSrcsForFieldOp(config, field) {
  var operator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var valueSrc = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var widgets = [];
  var valueSrcs = [];
  if (!field) return {
    widgets: widgets,
    valueSrcs: valueSrcs
  };
  var isFuncArg = _typeof(field) == "object" && !!field.type;
  var fieldConfig = getFieldConfig(field, config);
  var opConfig = operator ? config.operators[operator] : null;

  if (fieldConfig && fieldConfig.widgets) {
    var _loop = function _loop(widget) {
      var widgetConfig = fieldConfig.widgets[widget];
      var widgetValueSrc = config.widgets[widget].valueSrc || "value";
      var canAdd = true;
      if (!widgetConfig.operators) canAdd = canAdd && (valueSrc != "value" || isFuncArg); //if can't check operators, don't add

      if (widgetConfig.operators && operator) canAdd = canAdd && widgetConfig.operators.indexOf(operator) != -1;
      if (valueSrc && valueSrc != widgetValueSrc) canAdd = false;
      if (opConfig && opConfig.cardinality == 0 && widgetValueSrc != "value") canAdd = false;

      if (canAdd) {
        widgets.push(widget);
        var canAddValueSrc = fieldConfig.valueSources && fieldConfig.valueSources.indexOf(widgetValueSrc) != -1;
        if (opConfig && opConfig.valueSources && opConfig.valueSources.indexOf(widgetValueSrc) == -1) canAddValueSrc = false;
        if (canAddValueSrc && !valueSrcs.find(function (v) {
          return v == widgetValueSrc;
        })) valueSrcs.push(widgetValueSrc);
      }
    };

    for (var widget in fieldConfig.widgets) {
      _loop(widget);
    }
  }

  widgets.sort(function (w1, w2) {
    var w1Main = fieldConfig.preferWidgets ? fieldConfig.preferWidgets.indexOf(w1) != -1 : w1 == fieldConfig.mainWidget;

    var _w2Main = fieldConfig.preferWidgets ? fieldConfig.preferWidgets.indexOf(w2) != -1 : w2 == fieldConfig.mainWidget;

    if (w1 != w2) {
      return w1Main ? -1 : +1;
    }

    return 0;
  });
  return {
    widgets: widgets,
    valueSrcs: valueSrcs
  };
}

var getWidgetsForFieldOp = function getWidgetsForFieldOp(config, field, operator) {
  var valueSrc = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

  var _getWidgetsAndSrcsFor = _getWidgetsAndSrcsForFieldOp(config, field, operator, valueSrc),
      widgets = _getWidgetsAndSrcsFor.widgets;

  return widgets;
};
var getValueSourcesForFieldOp = function getValueSourcesForFieldOp(config, field, operator) {
  var fieldDefinition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var leftFieldForFunc = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;

  var _getWidgetsAndSrcsFor2 = _getWidgetsAndSrcsForFieldOp(config, field, operator, null),
      valueSrcs = _getWidgetsAndSrcsFor2.valueSrcs;

  var filteredValueSrcs = valueSrcs.filter(function (vs) {
    if (vs == "field" && fieldDefinition) {
      return config._fieldsCntByType[fieldDefinition.type] > 1;
    }

    if (vs == "func" && fieldDefinition) {
      if (!config._funcsCntByType[fieldDefinition.type]) return false;
      if (fieldDefinition.funcs) return fieldDefinition.funcs.length > 0;
      return true;
    }

    return true;
  });
  return filteredValueSrcs;
};
var getWidgetForFieldOp = function getWidgetForFieldOp(config, field, operator) {
  var valueSrc = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

  var _getWidgetsAndSrcsFor3 = _getWidgetsAndSrcsForFieldOp(config, field, operator, valueSrc),
      widgets = _getWidgetsAndSrcsFor3.widgets;

  var widget = null;
  if (widgets.length) widget = widgets[0];
  return widget;
};

/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export SELECT_WIDTH_OFFSET_RIGHT */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return defaultValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return bindActionCreators; });
/* unused harmony export calcTextWidth */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return truncateString; });
/* unused harmony export BUILT_IN_PLACEMENTS */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return immutableEqual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return deepEqual; });
/* unused harmony export eqSet */
/* unused harmony export eqArrSet */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return shallowEqual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return escapeRegExp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return useOnPropsChanged; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return getItemInListValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return getTitleInListValues; });
/* unused harmony export getValueInListValues */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return mapListValues; });
/* unused harmony export defaultTreeDataMap */
/* unused harmony export flatizeTreeData */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return normalizeListValues; });
/* unused harmony export removePrefixPath */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return isJsonLogic; });
/* harmony import */ var lodash_mapValues__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(22);
/* harmony import */ var lodash_mapValues__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash_mapValues__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var immutable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
/* harmony import */ var immutable__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(immutable__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(0);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }




var SELECT_WIDTH_OFFSET_RIGHT = 48;
var DEFAULT_FONT_SIZE = "14px";
var DEFAULT_FONT_FAMILY = "'Helvetica Neue', Helvetica, Arial, sans-serif"; // RegExp.quote = function (str) {
//     return str.replace(/([.?*+^$[\]\\(){}|-])/g, "\\$1");
// };

var defaultValue = function defaultValue(value, _default) {
  return typeof value === "undefined" ? _default : value;
};
var bindActionCreators = function bindActionCreators(actionCreators, config, dispatch) {
  return lodash_mapValues__WEBPACK_IMPORTED_MODULE_0___default()(actionCreators, function (actionCreator) {
    return function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return dispatch(actionCreator.apply(void 0, [config].concat(args)));
    };
  });
};
var calcTextWidth = function calcTextWidth(str) {
  var fontFamily = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DEFAULT_FONT_FAMILY;
  var fontSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_FONT_SIZE;
  var div = document.createElement("div");
  div.innerHTML = str;
  var css = {
    "position": "absolute",
    "float": "left",
    "white-space": "nowrap",
    "visibility": "hidden",
    "font-size": fontSize,
    "font-family": fontFamily
  };

  for (var k in css) {
    div.style[k] = css[k];
  }

  div = document.body.appendChild(div);
  var w = div.offsetWidth;
  document.body.removeChild(div);
  return w;
};
var truncateString = function truncateString(str, n, useWordBoundary) {
  if (!n || str.length <= n) {
    return str;
  }

  var subString = str.substr(0, n - 1);
  return (useWordBoundary ? subString.substr(0, subString.lastIndexOf(" ")) : subString) + "...";
};
var BUILT_IN_PLACEMENTS = {
  bottomLeft: {
    points: ["tl", "bl"],
    offset: [0, 4],
    overflow: {
      adjustX: 0,
      adjustY: 1
    }
  },
  bottomRight: {
    points: ["tr", "br"],
    offset: [0, 4],
    overflow: {
      adjustX: 1,
      adjustY: 1
    }
  },
  topLeft: {
    points: ["bl", "tl"],
    offset: [0, -4],
    overflow: {
      adjustX: 0,
      adjustY: 1
    }
  },
  topRight: {
    points: ["br", "tr"],
    offset: [0, -4],
    overflow: {
      adjustX: 1,
      adjustY: 1
    }
  }
};
var immutableEqual = function immutableEqual(v1, v2) {
  if (v1 === v2) {
    return true;
  } else {
    return v1.equals(v2);
  }
};
var deepEqual = function deepEqual(v1, v2) {
  if (v1 === v2) {
    return true;
  } else if (immutable__WEBPACK_IMPORTED_MODULE_1__["Map"].isMap(v1)) {
    return v1.equals(v2);
  } else {
    return JSON.stringify(v1) == JSON.stringify(v2);
  }
}; //Do sets have same values?

var eqSet = function eqSet(as, bs) {
  if (as.size !== bs.size) return false;

  var _iterator = _createForOfIteratorHelper(as),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var a = _step.value;
      if (!bs.has(a)) return false;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return true;
}; //Do arrays have same values?

var eqArrSet = function eqArrSet(arr1, arr2) {
  return eqSet(new Set(arr1), new Set(arr2));
};
var shallowEqual = function shallowEqual(a, b) {
  var deep = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  if (a === b) {
    return true;
  } else if (Array.isArray(a)) return shallowEqualArrays(a, b, deep);else if (immutable__WEBPACK_IMPORTED_MODULE_1__["Map"].isMap(a)) return a.equals(b);else if (_typeof(a) == "object") return shallowEqualObjects(a, b, deep);else return a === b;
};

function shallowEqualArrays(arrA, arrB) {
  var deep = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  if (arrA === arrB) {
    return true;
  }

  if (!arrA || !arrB) {
    return false;
  }

  var len = arrA.length;

  if (arrB.length !== len) {
    return false;
  }

  for (var i = 0; i < len; i++) {
    var isEqual = deep ? shallowEqual(arrA[i], arrB[i]) : arrA[i] === arrB[i];

    if (!isEqual) {
      return false;
    }
  }

  return true;
}

function shallowEqualObjects(objA, objB) {
  var deep = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  if (objA === objB) {
    return true;
  }

  if (!objA || !objB) {
    return false;
  }

  var aKeys = Object.keys(objA);
  var bKeys = Object.keys(objB);
  var len = aKeys.length;

  if (bKeys.length !== len) {
    return false;
  }

  for (var i = 0; i < len; i++) {
    var key = aKeys[i];
    var isEqual = deep ? shallowEqual(objA[key], objB[key], deep) : objA[key] === objB[key];

    if (!isEqual) {
      return false;
    }
  }

  return true;
}

var escapeRegExp = function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\/]/g, "\\$&"); // $& means the whole matched string
};

var canUseUnsafe = function canUseUnsafe() {
  var v = react__WEBPACK_IMPORTED_MODULE_2___default.a.version.split(".").map(parseInt.bind(null, 10));
  return v[0] >= 16 && v[1] >= 3;
};

var useOnPropsChanged = function useOnPropsChanged(obj) {
  if (canUseUnsafe) {
    obj.UNSAFE_componentWillReceiveProps = function (nextProps) {
      obj.onPropsChanged(nextProps);
    };
  } else {
    obj.componentWillReceiveProps = function (nextProps) {
      obj.onPropsChanged(nextProps);
    };
  }
};

var isObject = function isObject(v) {
  return _typeof(v) == "object" && v !== null;
};

var listValue = function listValue(v, title) {
  return isObject(v) ? v : {
    value: v,
    title: title !== undefined ? title : v
  };
}; // convert {<value>: <title>, ..} or [value, ..] to normal [{value, title}, ..]


var listValuesToArray = function listValuesToArray(listValuesObj) {
  if (!isObject(listValuesObj)) return listValuesObj;
  if (Array.isArray(listValuesObj)) return listValuesObj.map(function (v) {
    return listValue(v);
  });
  var listValuesArr = [];

  for (var v in listValuesObj) {
    var title = listValuesObj[v];
    listValuesArr.push(listValue(v, title));
  }

  return listValuesArr;
}; // listValues can be {<value>: <title>, ..} or [{value, title}, ..] or [value, ..]


var getItemInListValues = function getItemInListValues(listValues, value) {
  if (Array.isArray(listValues)) {
    var values = listValues.map(function (v) {
      return listValue(v);
    });
    return values.find(function (v) {
      return v.value === value;
    }) || values.find(function (v) {
      return "".concat(v.value) === value;
    });
  } else {
    return listValues[value] !== undefined ? listValue(value, listValues[value]) : undefined;
  }
};
var getTitleInListValues = function getTitleInListValues(listValues, value) {
  var it = getItemInListValues(listValues, value);
  return it !== undefined ? it.title : undefined;
};
var getValueInListValues = function getValueInListValues(listValues, value) {
  var it = getItemInListValues(listValues, value);
  return it !== undefined ? it.value : undefined;
};
var mapListValues = function mapListValues(listValues, fun) {
  var ret = [];

  if (Array.isArray(listValues)) {
    var _iterator2 = _createForOfIteratorHelper(listValues),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var v = _step2.value;
        ret.push(fun(listValue(v)));
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  } else {
    for (var value in listValues) {
      ret.push(fun(listValue(value, listValues[value])));
    }
  }

  return ret;
};
var defaultTreeDataMap = {
  id: "value",
  pId: "parent",
  rootPId: undefined
}; // converts from treeData to treeDataSimpleMode format (https://ant.design/components/tree-select/)
// ! modifies value of `treeData`

var flatizeTreeData = function flatizeTreeData(treeData) {
  var tdm = defaultTreeDataMap;
  var rind;
  var len;

  var _flatize = function _flatize(node, root, lev) {
    if (node.children) {
      if (lev == 1) node[tdm.pId] = tdm.rootPId; //optional?

      var childrenCount = node.children.length;

      var _iterator3 = _createForOfIteratorHelper(node.children),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var c = _step3.value;
          c[tdm.pId] = node[tdm.id];
          rind++;
          root.splice(rind, 0, c); //instead of just push

          len++;

          _flatize(c, root, lev + 1);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      delete node.children;

      if (childrenCount == 0) {
        root.splice(rind, 1);
        rind--;
        len--;
      }
    }
  };

  if (Array.isArray(treeData)) {
    len = treeData.length;

    for (rind = 0; rind < len; rind++) {
      var c = treeData[rind];
      if (!isObject(c)) continue;
      if (c[tdm.pId] !== undefined && c[tdm.pId] != tdm.rootPId) continue; //not lev 1

      _flatize(c, treeData, 1);
    }
  }

  return treeData;
};

var getPathInListValues = function getPathInListValues(listValues, value) {
  var tdm = defaultTreeDataMap;
  var it = getItemInListValues(listValues, value);
  var parentId = it ? it[tdm.pId] : undefined;
  var parent = parentId ? listValues.find(function (v) {
    return v[tdm.id] === parentId;
  }) : undefined;
  return parent ? [parent.value].concat(_toConsumableArray(getPathInListValues(listValues, parent.value))) : [];
};

var getChildrenInListValues = function getChildrenInListValues(listValues, value) {
  var tdm = defaultTreeDataMap;
  var it = getItemInListValues(listValues, value);
  return it ? listValues.filter(function (v) {
    return v[tdm.pId] === it[tdm.id];
  }).map(function (v) {
    return v.value;
  }) : [];
}; // ! modifies value of `treeData`


var extendTreeData = function extendTreeData(treeData, fieldSettings, isMulti) {
  var _iterator4 = _createForOfIteratorHelper(treeData),
      _step4;

  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var node = _step4.value;
      node.path = getPathInListValues(treeData, node.value);

      if (fieldSettings.treeSelectOnlyLeafs != false) {
        var childrenValues = getChildrenInListValues(treeData, node.value);

        if (!isMulti) {
          node.selectable = childrenValues.length == 0;
        }
      }
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }

  return treeData;
};

var normalizeListValues = function normalizeListValues(listValues, type, fieldSettings) {
  var isTree = ["treeselect", "treemultiselect"].includes(type);
  var isMulti = ["multiselect", "treemultiselect"].includes(type);

  if (isTree) {
    listValues = listValuesToArray(listValues);
    listValues = flatizeTreeData(listValues);
    listValues = extendTreeData(listValues, fieldSettings, isMulti);
  }

  return listValues;
};
var removePrefixPath = function removePrefixPath(selectedPath, parentPath) {
  if (!selectedPath) return selectedPath;
  var isPrefix = true;

  for (var i = 0; i < parentPath.length; i++) {
    var part = parentPath[i];

    if (selectedPath[i] !== undefined && part == selectedPath[i]) {//ok
    } else {
      isPrefix = false;
      break;
    }
  }

  return isPrefix ? selectedPath.slice(parentPath.length) : selectedPath;
};
var isJsonLogic = function isJsonLogic(logic) {
  return _typeof(logic) === "object" // An object
  && logic !== null // but not null
  && !Array.isArray(logic) // and not an array
  && Object.keys(logic).length === 1 // with exactly one key
  ;
};

/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return expandTreePath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return expandTreeSubpath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return getItemByPath; });
/* unused harmony export removePathsInTree */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return fixPathsInTree; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return fixEmptyGroupsInTree; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return getFlatTree; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return getTotalReordableNodesCountInTree; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return getTotalRulesCountInTree; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return getTreeBadFields; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return getLightTree; });
/* harmony import */ var immutable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var immutable__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(immutable__WEBPACK_IMPORTED_MODULE_0__);
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


/**
 * @param {Immutable.List} path
 * @param {...string} suffix
 * @return {Immutable.List}
 */

var expandTreePath = function expandTreePath(path) {
  for (var _len = arguments.length, suffix = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    suffix[_key - 1] = arguments[_key];
  }

  return path.interpose("children1").withMutations(function (list) {
    list.skip(1);
    list.push.apply(list, suffix);
    return list;
  });
};
/**
 * @param {Immutable.List} path
 * @param {...string} suffix
 * @return {Immutable.List}
 */

var expandTreeSubpath = function expandTreeSubpath(path) {
  for (var _len2 = arguments.length, suffix = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    suffix[_key2 - 1] = arguments[_key2];
  }

  return path.interpose("children1").withMutations(function (list) {
    list.push.apply(list, suffix);
    return list;
  });
};
/**
 * @param {Immutable.Map} path
 * @param {Immutable.List} path
 * @return {Immutable.Map}
 */

var getItemByPath = function getItemByPath(tree, path) {
  var children = new immutable__WEBPACK_IMPORTED_MODULE_0___default.a.OrderedMap(_defineProperty({}, tree.get("id"), tree));
  var res = tree;
  path.forEach(function (id) {
    res = children.get(id);
    children = res.get("children1");
  });
  return res;
};
/**
 * Remove `path` in every item
 * @param {Immutable.Map} tree
 * @return {Immutable.Map} tree
 */

var removePathsInTree = function removePathsInTree(tree) {
  var newTree = tree;

  function _processNode(item, path) {
    var itemPath = path.push(item.get("id"));

    if (item.get("path")) {
      newTree = newTree.removeIn(expandTreePath(itemPath, "path"));
    }

    var children = item.get("children1");

    if (children) {
      children.map(function (child, _childId) {
        _processNode(child, itemPath);
      });
    }
  }

  _processNode(tree, new immutable__WEBPACK_IMPORTED_MODULE_0___default.a.List());

  return newTree;
};
/**
 * Set correct `path` in every item
 * @param {Immutable.Map} tree
 * @return {Immutable.Map} tree
 */

var fixPathsInTree = function fixPathsInTree(tree) {
  var newTree = tree;

  function _processNode(item, path, lev) {
    if (!item) return;

    var _id = item.get("id");

    var itemPath = path.push(item.get("id"));
    var currItemPath = item.get("path");

    if (!currItemPath || !currItemPath.equals(itemPath)) {
      newTree = newTree.setIn(expandTreePath(itemPath, "path"), itemPath);
    }

    var children = item.get("children1");

    if (children) {
      children.map(function (child, _childId) {
        _processNode(child, itemPath, lev + 1);
      });
    }
  }

  _processNode(tree, new immutable__WEBPACK_IMPORTED_MODULE_0___default.a.List(), 0);

  return newTree;
};
var fixEmptyGroupsInTree = function fixEmptyGroupsInTree(tree) {
  var newTree = tree;

  function _processNode(item, path, lev) {
    if (!item) return false;
    var id = item.get("id");
    var itemPath = path.push(item.get("id"));
    var children = item.get("children1");

    if (children) {
      var allChildrenGone = children.map(function (child, _childId) {
        return _processNode(child, itemPath, lev + 1);
      }).reduce(function (curr, v) {
        return curr && v;
      }, true);

      if ((children.size == 0 || allChildrenGone) && lev > 0) {
        newTree = newTree.deleteIn(expandTreePath(itemPath));
        return true;
      }
    }

    return false;
  }

  _processNode(tree, new immutable__WEBPACK_IMPORTED_MODULE_0___default.a.List(), 0);

  return newTree;
};
/**
 * @param {Immutable.Map} tree
 * @return {Object} {flat, items}
 */

var getFlatTree = function getFlatTree(tree) {
  var flat = [];
  var items = {};
  var realHeight = 0;

  function _flatizeTree(item, path, insideCollapsed, lev, info, parentType) {
    var type = item.get("type");
    var collapsed = item.get("collapsed");
    var id = item.get("id");
    var children = item.get("children1");
    var childrenIds = children ? children.map(function (_child, childId) {
      return childId;
    }) : null;
    var itemsBefore = flat.length;
    var top = realHeight;
    flat.push(id);
    if (!insideCollapsed) realHeight += 1;
    info.height = (info.height || 0) + 1;

    if (children) {
      var subinfo = {};
      children.map(function (child, _childId) {
        _flatizeTree(child, path.concat(id), insideCollapsed || collapsed, lev + 1, subinfo, type);
      });

      if (!collapsed) {
        info.height = (info.height || 0) + (subinfo.height || 0);
      }
    }

    var itemsAfter = flat.length;
    var _bottom = realHeight;
    var height = info.height;
    items[id] = {
      type: type,
      parent: path.length ? path[path.length - 1] : null,
      parentType: parentType,
      path: path.concat(id),
      lev: lev,
      leaf: !children,
      index: itemsBefore,
      id: id,
      children: childrenIds,
      _top: itemsBefore,
      _height: itemsAfter - itemsBefore,
      top: insideCollapsed ? null : top,
      height: height,
      bottom: (insideCollapsed ? null : top) + height,
      collapsed: collapsed,
      node: item
    };
  }

  _flatizeTree(tree, [], false, 0, {}, null);

  for (var i = 0; i < flat.length; i++) {
    var prevId = i > 0 ? flat[i - 1] : null;
    var nextId = i < flat.length - 1 ? flat[i + 1] : null;
    var item = items[flat[i]];
    item.prev = prevId;
    item.next = nextId;
  }

  return {
    flat: flat,
    items: items
  };
};
/**
 * Returns count of reorderable(!) nodes
 * @param {Immutable.Map} tree
 * @return {Integer}
 */

var getTotalReordableNodesCountInTree = function getTotalReordableNodesCountInTree(tree) {
  if (!tree) return -1;
  var cnt = 0;

  function _processNode(item, path, lev) {
    var id = item.get("id");
    var children = item.get("children1");
    var isRuleGroup = item.get("type") == "rule_group";
    cnt++; //tip: rules in rule-group can be reordered only inside

    if (children && !isRuleGroup) {
      children.map(function (child, _childId) {
        _processNode(child, path.concat(id), lev + 1);
      });
    }
  }

  _processNode(tree, [], 0);

  return cnt - 1; // -1 for root
};
/**
 * Returns count of rules (leafs, i.e. don't count groups)
 * @param {Immutable.Map} tree
 * @return {Integer}
 */

var getTotalRulesCountInTree = function getTotalRulesCountInTree(tree) {
  if (!tree) return -1;
  var cnt = 0;

  function _processNode(item, path, lev) {
    var id = item.get("id");
    var children = item.get("children1");
    var isGroup = item.get("type") == "group"; //const isRuleGroup = item.get("type") == "rule_group";

    if (children && isGroup) {
      children.map(function (child, _childId) {
        _processNode(child, path.concat(id), lev + 1);
      });
    } else {
      // tip: count rule_group as 1 rule
      cnt++;
    }
  }

  _processNode(tree, [], 0);

  return cnt;
};
var getTreeBadFields = function getTreeBadFields(tree) {
  var badFields = [];

  function _processNode(item, path, lev) {
    var id = item.get("id");
    var children = item.get("children1");
    var valueError = item.getIn(["properties", "valueError"]);
    var field = item.getIn(["properties", "field"]);

    if (valueError && valueError.size > 0 && valueError.filter(function (v) {
      return v != null;
    }).size > 0) {
      badFields.push(field);
    }

    if (children) {
      children.map(function (child, _childId) {
        _processNode(child, path.concat(id), lev + 1);
      });
    }
  }

  if (tree) _processNode(tree, [], 0);
  return Array.from(new Set(badFields));
}; // Remove fields that can be calced: "id", "path"
// Remove empty fields: "operatorOptions"

var getLightTree = function getLightTree(tree) {
  var newTree = tree;

  function _processNode(item, itemId) {
    if (item.path) delete item.path;
    if (itemId) delete item.id;
    var properties = item.properties;

    if (properties) {
      if (properties.operatorOptions == null) delete properties.operatorOptions;
    }

    var children = item.children1;

    if (children) {
      for (var id in children) {
        _processNode(children[id], id);
      }
    }
  }

  _processNode(tree, null);

  return newTree;
};

/***/ }),
/* 5 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__5__;

/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ADD_GROUP; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return REMOVE_GROUP; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return SET_CONJUNCTION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "p", function() { return SET_NOT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return ADD_NEW_GROUP; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return ADD_RULE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return REMOVE_RULE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "o", function() { return SET_FIELD; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "q", function() { return SET_OPERATOR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "t", function() { return SET_VALUE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "u", function() { return SET_VALUE_SRC; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "r", function() { return SET_OPERATOR_OPTION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "s", function() { return SET_TREE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return MOVE_ITEM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return PLACEMENT_AFTER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return PLACEMENT_BEFORE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return PLACEMENT_APPEND; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return PLACEMENT_PREPEND; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return SET_DRAG_PROGRESS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "n", function() { return SET_DRAG_START; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return SET_DRAG_END; });
var ADD_GROUP = "ADD_GROUP";
var REMOVE_GROUP = "REMOVE_GROUP";
var SET_CONJUNCTION = "SET_CONJUNCTION";
var SET_NOT = "SET_NOT";
var ADD_NEW_GROUP = "ADD_NEW_GROUP";
var ADD_RULE = "ADD_RULE";
var REMOVE_RULE = "REMOVE_RULE";
var SET_FIELD = "SET_FIELD";
var SET_OPERATOR = "SET_OPERATOR";
var SET_VALUE = "SET_VALUE";
var SET_VALUE_SRC = "SET_VALUE_SRC";
var SET_OPERATOR_OPTION = "SET_OPERATOR_OPTION";
var SET_TREE = "SET_TREE";
var MOVE_ITEM = "MOVE_ITEM";
var PLACEMENT_AFTER = "after";
var PLACEMENT_BEFORE = "before";
var PLACEMENT_APPEND = "append";
var PLACEMENT_PREPEND = "prepend";
var SET_DRAG_PROGRESS = "SET_DRAG_PROGRESS";
var SET_DRAG_START = "SET_DRAG_START";
var SET_DRAG_END = "SET_DRAG_END";

/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export defaultField */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return defaultOperator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return defaultOperatorOptions; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return defaultRuleProperties; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return defaultGroupConjunction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return defaultConjunction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return defaultGroupProperties; });
/* unused harmony export getChild */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return defaultRoot; });
/* harmony import */ var immutable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
/* harmony import */ var immutable__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(immutable__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _uuid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8);
/* harmony import */ var _configUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2);
/* harmony import */ var _utils_validation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(14);
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }





var defaultField = function defaultField(config) {
  var canGetFirst = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var parentRuleGroupPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  return typeof config.settings.defaultField === "function" ? config.settings.defaultField(parentRuleGroupPath) : config.settings.defaultField || (canGetFirst ? Object(_configUtils__WEBPACK_IMPORTED_MODULE_2__[/* getFirstField */ "f"])(config, parentRuleGroupPath) : null);
};
var defaultOperator = function defaultOperator(config, field) {
  var canGetFirst = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  var fieldConfig = Object(_configUtils__WEBPACK_IMPORTED_MODULE_2__[/* getFieldConfig */ "b"])(field, config);
  var fieldOperators = fieldConfig && fieldConfig.operators || [];
  var fieldDefaultOperator = fieldConfig && fieldConfig.defaultOperator;
  if (!fieldOperators.includes(fieldDefaultOperator)) fieldDefaultOperator = null;
  if (!fieldDefaultOperator && canGetFirst) fieldDefaultOperator = Object(_configUtils__WEBPACK_IMPORTED_MODULE_2__[/* getFirstOperator */ "g"])(config, field);
  var op = typeof config.settings.defaultOperator === "function" ? config.settings.defaultOperator(field, fieldConfig) : fieldDefaultOperator;
  return op;
}; //used for complex operators like proximity

var defaultOperatorOptions = function defaultOperatorOptions(config, operator, field) {
  var operatorConfig = operator ? Object(_configUtils__WEBPACK_IMPORTED_MODULE_2__[/* getOperatorConfig */ "j"])(config, operator, field) : null;
  if (!operatorConfig) return null; //new Immutable.Map();

  return operatorConfig.options ? new immutable__WEBPACK_IMPORTED_MODULE_0___default.a.Map(operatorConfig.options && operatorConfig.options.defaults || {}) : null;
};
var defaultRuleProperties = function defaultRuleProperties(config) {
  var parentRuleGroupPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var field = null,
      operator = null;
  var _config$settings = config.settings,
      setDefaultFieldAndOp = _config$settings.setDefaultFieldAndOp,
      showErrorMessage = _config$settings.showErrorMessage;

  if (setDefaultFieldAndOp) {
    field = defaultField(config, true, parentRuleGroupPath);
    operator = defaultOperator(config, field);
  }

  var current = new immutable__WEBPACK_IMPORTED_MODULE_0___default.a.Map({
    field: field,
    operator: operator,
    value: new immutable__WEBPACK_IMPORTED_MODULE_0___default.a.List(),
    valueSrc: new immutable__WEBPACK_IMPORTED_MODULE_0___default.a.List(),
    //used for complex operators like proximity
    operatorOptions: defaultOperatorOptions(config, operator, field)
  });

  if (showErrorMessage) {
    current = current.set("valueError", new immutable__WEBPACK_IMPORTED_MODULE_0___default.a.List());
  }

  if (field && operator) {
    var _getNewValueForFieldO = Object(_utils_validation__WEBPACK_IMPORTED_MODULE_3__[/* getNewValueForFieldOp */ "a"])(config, config, current, field, operator, "operator", false),
        newValue = _getNewValueForFieldO.newValue,
        newValueSrc = _getNewValueForFieldO.newValueSrc,
        newValueType = _getNewValueForFieldO.newValueType,
        newValueError = _getNewValueForFieldO.newValueError;

    current = current.set("value", newValue).set("valueSrc", newValueSrc).set("valueType", newValueType);

    if (showErrorMessage) {
      current = current.set("valueError", newValueError);
    }
  }

  return current;
}; //------------

var defaultGroupConjunction = function defaultGroupConjunction(config) {
  return config.settings.defaultGroupConjunction || config.settings.defaultConjunction || Object.keys(config.conjunctions)[0];
};
var defaultConjunction = function defaultConjunction(config) {
  return config.settings.defaultConjunction || Object.keys(config.conjunctions)[0];
};
var defaultGroupProperties = function defaultGroupProperties(config) {
  return new immutable__WEBPACK_IMPORTED_MODULE_0___default.a.Map({
    conjunction: defaultGroupConjunction(config)
  });
}; //------------

var getChild = function getChild(id, config) {
  return _defineProperty({}, id, new immutable__WEBPACK_IMPORTED_MODULE_0___default.a.Map({
    type: "rule",
    id: id,
    properties: defaultRuleProperties(config)
  }));
};
var defaultRoot = function defaultRoot(config) {
  if (config.tree) {
    return new immutable__WEBPACK_IMPORTED_MODULE_0___default.a.Map(config.tree);
  }

  return new immutable__WEBPACK_IMPORTED_MODULE_0___default.a.Map({
    type: "group",
    id: Object(_uuid__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(),
    children1: new immutable__WEBPACK_IMPORTED_MODULE_0___default.a.OrderedMap(_objectSpread({}, getChild(Object(_uuid__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(), config))),
    properties: defaultGroupProperties(config)
  });
};

/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// Had to make uuid use a constant seed so it would generate same sequence across runs. This was needed
// so server side rendering and client side rendering yield same results (e.g. the uuid is used when rendering
// the concunctions with their name and id)
var query_builder_seed = 0;
/* harmony default export */ __webpack_exports__["a"] = (function () {
  // Generate a random GUID http://stackoverflow.com/a/2117523.
  var timePart = (new Date().getTime().toString(16) + "FF").substr(0, 11);
  var s = "ssssssss-xxxx-4xxx-yxxx-x".replace(/[xys]/g, function (c) {
    var r = c === "s" ? Math.floor(Math.random() * 16) : query_builder_seed++ & 0xf;
    var v = c === "x" ? r : r & 0x3 | 0x8;
    return v.toString(16);
  });
  return s + timePart;
});

/***/ }),
/* 9 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__9__;

/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "ValueFieldWidget", function() { return /* reexport */ ValueField_ValueField; });
__webpack_require__.d(__webpack_exports__, "FuncWidget", function() { return /* reexport */ FuncWidget_FuncWidget; });
__webpack_require__.d(__webpack_exports__, "VanillaBooleanWidget", function() { return /* reexport */ VanillaBoolean; });
__webpack_require__.d(__webpack_exports__, "VanillaTextWidget", function() { return /* reexport */ VanillaText; });
__webpack_require__.d(__webpack_exports__, "VanillaDateWidget", function() { return /* reexport */ VanillaDate; });
__webpack_require__.d(__webpack_exports__, "VanillaTimeWidget", function() { return /* reexport */ VanillaTime; });
__webpack_require__.d(__webpack_exports__, "VanillaDateTimeWidget", function() { return /* reexport */ VanillaDateTime; });
__webpack_require__.d(__webpack_exports__, "VanillaMultiSelectWidget", function() { return /* reexport */ VanillaMultiSelect; });
__webpack_require__.d(__webpack_exports__, "VanillaSelectWidget", function() { return /* reexport */ VanillaSelect; });
__webpack_require__.d(__webpack_exports__, "VanillaNumberWidget", function() { return /* reexport */ VanillaNumber; });
__webpack_require__.d(__webpack_exports__, "VanillaSliderWidget", function() { return /* reexport */ VanillaSlider; });
__webpack_require__.d(__webpack_exports__, "VanillaFieldSelect", function() { return /* reexport */ VanillaFieldSelect; });
__webpack_require__.d(__webpack_exports__, "VanillaConjs", function() { return /* reexport */ VanillaConjs; });
__webpack_require__.d(__webpack_exports__, "VanillaButton", function() { return /* reexport */ VanillaButton; });
__webpack_require__.d(__webpack_exports__, "VanillaButtonGroup", function() { return /* reexport */ VanillaButtonGroup; });
__webpack_require__.d(__webpack_exports__, "VanillaValueSources", function() { return /* reexport */ VanillaValueSources; });
__webpack_require__.d(__webpack_exports__, "vanillaConfirm", function() { return /* reexport */ vanillaConfirm; });
__webpack_require__.d(__webpack_exports__, "VanillaProvider", function() { return /* reexport */ VanillaProvider; });

// EXTERNAL MODULE: external "React"
var external_React_ = __webpack_require__(0);
var external_React_default = /*#__PURE__*/__webpack_require__.n(external_React_);

// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(1);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);

// EXTERNAL MODULE: ./modules/utils/configUtils.js
var configUtils = __webpack_require__(2);

// EXTERNAL MODULE: ./modules/utils/stuff.js
var stuff = __webpack_require__(3);

// EXTERNAL MODULE: external "lodash/last"
var last_ = __webpack_require__(20);
var last_default = /*#__PURE__*/__webpack_require__.n(last_);

// EXTERNAL MODULE: external "lodash/keys"
var keys_ = __webpack_require__(17);
var keys_default = /*#__PURE__*/__webpack_require__.n(keys_);

// EXTERNAL MODULE: ./node_modules/clone/clone.js
var clone = __webpack_require__(21);
var clone_default = /*#__PURE__*/__webpack_require__.n(clone);

// CONCATENATED MODULE: ./modules/components/ValueField.jsx
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }







 //tip: this.props.value - right value, this.props.field - left value

var ValueField_ValueField = /*#__PURE__*/function (_PureComponent) {
  _inherits(ValueField, _PureComponent);

  var _super = _createSuper(ValueField);

  function ValueField(props) {
    var _this;

    _classCallCheck(this, ValueField);

    _this = _super.call(this, props);
    Object(stuff["m" /* useOnPropsChanged */])(_assertThisInitialized(_this));

    _this.onPropsChanged(props);

    return _this;
  }

  _createClass(ValueField, [{
    key: "onPropsChanged",
    value: function onPropsChanged(nextProps) {
      var prevProps = this.props;
      var keysForItems = ["config", "field", "operator", "isFuncArg", "placeholder"];
      var keysForMeta = ["config", "field", "operator", "value"];
      var needUpdateItems = !this.items || keysForItems.map(function (k) {
        return nextProps[k] !== prevProps[k];
      }).filter(function (ch) {
        return ch;
      }).length > 0;
      var needUpdateMeta = !this.meta || keysForMeta.map(function (k) {
        return nextProps[k] !== prevProps[k];
      }).filter(function (ch) {
        return ch;
      }).length > 0;

      if (needUpdateItems) {
        this.items = this.getItems(nextProps);
      }

      if (needUpdateMeta) {
        this.meta = this.getMeta(nextProps);
      }
    }
  }, {
    key: "getItems",
    value: function getItems(_ref) {
      var config = _ref.config,
          field = _ref.field,
          operator = _ref.operator;
      var canCompareFieldWithField = config.settings.canCompareFieldWithField;
      var filteredFields = this.filterFields(config, config.fields, field, operator, canCompareFieldWithField);
      var items = this.buildOptions(config, filteredFields);
      return items;
    }
  }, {
    key: "getMeta",
    value: function getMeta(_ref2) {
      var config = _ref2.config,
          field = _ref2.field,
          operator = _ref2.operator,
          value = _ref2.value,
          customPlaceholder = _ref2.placeholder,
          isFuncArg = _ref2.isFuncArg;
      var _config$settings = config.settings,
          fieldPlaceholder = _config$settings.fieldPlaceholder,
          fieldSeparatorDisplay = _config$settings.fieldSeparatorDisplay;
      var selectedKey = value;
      var isFieldSelected = !!value;
      var leftFieldConfig = Object(configUtils["b" /* getFieldConfig */])(field, config);
      var leftFieldWidgetField = leftFieldConfig.widgets.field;
      var leftFieldWidgetFieldProps = leftFieldWidgetField && leftFieldWidgetField.widgetProps || {};
      var placeholder = isFieldSelected ? null : isFuncArg && customPlaceholder || leftFieldWidgetFieldProps.valuePlaceholder || fieldPlaceholder;
      var currField = isFieldSelected ? Object(configUtils["b" /* getFieldConfig */])(selectedKey, config) : null;
      var selectedOpts = currField || {};
      var selectedKeys = Object(configUtils["c" /* getFieldPath */])(selectedKey, config);
      var selectedPath = Object(configUtils["c" /* getFieldPath */])(selectedKey, config, true);
      var selectedLabel = this.getFieldLabel(currField, selectedKey, config);
      var partsLabels = Object(configUtils["d" /* getFieldPathLabels */])(selectedKey, config);
      var selectedFullLabel = partsLabels ? partsLabels.join(fieldSeparatorDisplay) : null;
      if (selectedFullLabel == selectedLabel) selectedFullLabel = null;
      var selectedAltLabel = selectedOpts.label2;
      return {
        placeholder: placeholder,
        selectedKey: selectedKey,
        selectedKeys: selectedKeys,
        selectedPath: selectedPath,
        selectedLabel: selectedLabel,
        selectedOpts: selectedOpts,
        selectedAltLabel: selectedAltLabel,
        selectedFullLabel: selectedFullLabel
      };
    }
  }, {
    key: "filterFields",
    value: function filterFields(config, fields, leftFieldFullkey, operator, canCompareFieldWithField) {
      fields = clone_default()(fields);
      var fieldSeparator = config.settings.fieldSeparator;
      var leftFieldConfig = Object(configUtils["b" /* getFieldConfig */])(leftFieldFullkey, config);
      var expectedType;
      var widget = Object(configUtils["n" /* getWidgetForFieldOp */])(config, leftFieldFullkey, operator, "value");

      if (widget) {
        var widgetConfig = config.widgets[widget];
        var widgetType = widgetConfig.type; //expectedType = leftFieldConfig.type;

        expectedType = widgetType;
      } else {
        expectedType = leftFieldConfig.type;
      }

      function _filter(list, path) {
        for (var rightFieldKey in list) {
          var subfields = list[rightFieldKey].subfields;
          var subpath = (path ? path : []).concat(rightFieldKey);
          var rightFieldFullkey = subpath.join(fieldSeparator);
          var rightFieldConfig = Object(configUtils["b" /* getFieldConfig */])(rightFieldFullkey, config);

          if (!rightFieldConfig) {
            delete list[rightFieldKey];
          } else if (rightFieldConfig.type == "!struct" || rightFieldConfig.type == "!group") {
            if (_filter(subfields, subpath) == 0) delete list[rightFieldKey];
          } else {
            var canUse = rightFieldConfig.type == expectedType && rightFieldFullkey != leftFieldFullkey;
            var fn = canCompareFieldWithField || config.settings.canCompareFieldWithField;
            if (fn) canUse = canUse && fn(leftFieldFullkey, leftFieldConfig, rightFieldFullkey, rightFieldConfig, operator);
            if (!canUse) delete list[rightFieldKey];
          }
        }

        return keys_default()(list).length;
      }

      _filter(fields, []);

      return fields;
    }
  }, {
    key: "buildOptions",
    value: function buildOptions(config, fields) {
      var _this2 = this;

      var path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var optGroupLabel = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      if (!fields) return null;
      var _config$settings2 = config.settings,
          fieldSeparator = _config$settings2.fieldSeparator,
          fieldSeparatorDisplay = _config$settings2.fieldSeparatorDisplay;
      var prefix = path ? path.join(fieldSeparator) + fieldSeparator : "";
      return keys_default()(fields).map(function (fieldKey) {
        var field = fields[fieldKey];

        var label = _this2.getFieldLabel(field, fieldKey, config);

        var partsLabels = Object(configUtils["d" /* getFieldPathLabels */])(fieldKey, config);
        var fullLabel = partsLabels.join(fieldSeparatorDisplay);
        if (fullLabel == label) fullLabel = null;
        var altLabel = field.label2;
        var tooltip = field.tooltip;
        var subpath = (path ? path : []).concat(fieldKey);
        if (field.hideForCompare) return undefined;

        if (field.type == "!struct" || field.type == "!group") {
          return {
            key: fieldKey,
            path: prefix + fieldKey,
            label: label,
            fullLabel: fullLabel,
            altLabel: altLabel,
            tooltip: tooltip,
            items: _this2.buildOptions(config, field.subfields, subpath, label)
          };
        } else {
          return {
            key: fieldKey,
            path: prefix + fieldKey,
            label: label,
            fullLabel: fullLabel,
            altLabel: altLabel,
            tooltip: tooltip,
            grouplabel: optGroupLabel
          };
        }
      }).filter(function (o) {
        return !!o;
      });
    }
  }, {
    key: "getFieldLabel",
    value: function getFieldLabel(fieldOpts, fieldKey, config) {
      if (!fieldKey) return null;
      var fieldSeparator = config.settings.fieldSeparator;
      var maxLabelsLength = config.settings.maxLabelsLength;
      var fieldParts = Array.isArray(fieldKey) ? fieldKey : fieldKey.split(fieldSeparator);
      var label = fieldOpts.label || last_default()(fieldParts);
      label = Object(stuff["l" /* truncateString */])(label, maxLabelsLength);
      return label;
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props = this.props,
          config = _this$props.config,
          customProps = _this$props.customProps,
          setValue = _this$props.setValue,
          readonly = _this$props.readonly;
      var renderField = config.settings.renderField;

      var renderProps = _objectSpread({
        config: config,
        customProps: customProps,
        setField: setValue,
        readonly: readonly,
        items: this.items
      }, this.meta);

      return renderField(renderProps);
    }
  }]);

  return ValueField;
}(external_React_["PureComponent"]);

ValueField_ValueField.propTypes = {
  setValue: prop_types_default.a.func.isRequired,
  config: prop_types_default.a.object.isRequired,
  field: prop_types_default.a.string.isRequired,
  value: prop_types_default.a.string,
  operator: prop_types_default.a.string,
  customProps: prop_types_default.a.object,
  readonly: prop_types_default.a.bool
};

// CONCATENATED MODULE: ./modules/components/FuncSelect.jsx
function FuncSelect_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { FuncSelect_typeof = function _typeof(obj) { return typeof obj; }; } else { FuncSelect_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return FuncSelect_typeof(obj); }

function FuncSelect_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function FuncSelect_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { FuncSelect_ownKeys(Object(source), true).forEach(function (key) { FuncSelect_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { FuncSelect_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function FuncSelect_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function FuncSelect_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function FuncSelect_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function FuncSelect_createClass(Constructor, protoProps, staticProps) { if (protoProps) FuncSelect_defineProperties(Constructor.prototype, protoProps); if (staticProps) FuncSelect_defineProperties(Constructor, staticProps); return Constructor; }

function FuncSelect_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) FuncSelect_setPrototypeOf(subClass, superClass); }

function FuncSelect_setPrototypeOf(o, p) { FuncSelect_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return FuncSelect_setPrototypeOf(o, p); }

function FuncSelect_createSuper(Derived) { var hasNativeReflectConstruct = FuncSelect_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = FuncSelect_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = FuncSelect_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return FuncSelect_possibleConstructorReturn(this, result); }; }

function FuncSelect_possibleConstructorReturn(self, call) { if (call && (FuncSelect_typeof(call) === "object" || typeof call === "function")) { return call; } return FuncSelect_assertThisInitialized(self); }

function FuncSelect_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function FuncSelect_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function FuncSelect_getPrototypeOf(o) { FuncSelect_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return FuncSelect_getPrototypeOf(o); }







 //tip: this.props.value - right value, this.props.field - left value

var FuncSelect_FuncSelect = /*#__PURE__*/function (_PureComponent) {
  FuncSelect_inherits(FuncSelect, _PureComponent);

  var _super = FuncSelect_createSuper(FuncSelect);

  function FuncSelect(props) {
    var _this;

    FuncSelect_classCallCheck(this, FuncSelect);

    _this = _super.call(this, props);
    Object(stuff["m" /* useOnPropsChanged */])(FuncSelect_assertThisInitialized(_this));

    _this.onPropsChanged(props);

    return _this;
  }

  FuncSelect_createClass(FuncSelect, [{
    key: "onPropsChanged",
    value: function onPropsChanged(nextProps) {
      var prevProps = this.props;
      var keysForItems = ["config", "field", "operator"];
      var keysForMeta = ["config", "field", "value"];
      var needUpdateItems = !this.items || keysForItems.map(function (k) {
        return nextProps[k] !== prevProps[k];
      }).filter(function (ch) {
        return ch;
      }).length > 0;
      var needUpdateMeta = !this.meta || keysForMeta.map(function (k) {
        return nextProps[k] !== prevProps[k];
      }).filter(function (ch) {
        return ch;
      }).length > 0;

      if (needUpdateItems) {
        this.items = this.getItems(nextProps);
      }

      if (needUpdateMeta) {
        this.meta = this.getMeta(nextProps);
      }
    }
  }, {
    key: "getItems",
    value: function getItems(_ref) {
      var config = _ref.config,
          field = _ref.field,
          operator = _ref.operator;
      var canUseFuncForField = config.settings.canUseFuncForField;
      var filteredFuncs = this.filterFuncs(config, config.funcs, field, operator, canUseFuncForField);
      var items = this.buildOptions(config, filteredFuncs);
      return items;
    }
  }, {
    key: "getMeta",
    value: function getMeta(_ref2) {
      var config = _ref2.config,
          field = _ref2.field,
          value = _ref2.value;
      var _config$settings = config.settings,
          funcPlaceholder = _config$settings.funcPlaceholder,
          fieldSeparatorDisplay = _config$settings.fieldSeparatorDisplay;
      var selectedFuncKey = value;
      var isFuncSelected = !!value;
      var leftFieldConfig = Object(configUtils["b" /* getFieldConfig */])(field, config);
      var leftFieldWidgetField = leftFieldConfig.widgets.field;
      var leftFieldWidgetFieldProps = leftFieldWidgetField && leftFieldWidgetField.widgetProps || {};
      var placeholder = !isFuncSelected ? funcPlaceholder : null;
      var currFunc = isFuncSelected ? Object(configUtils["h" /* getFuncConfig */])(selectedFuncKey, config) : null;
      var selectedOpts = currFunc || {};
      var selectedKeys = Object(configUtils["c" /* getFieldPath */])(selectedFuncKey, config);
      var selectedPath = Object(configUtils["c" /* getFieldPath */])(selectedFuncKey, config, true);
      var selectedLabel = this.getFuncLabel(currFunc, selectedFuncKey, config);
      var partsLabels = Object(configUtils["i" /* getFuncPathLabels */])(selectedFuncKey, config);
      var selectedFullLabel = partsLabels ? partsLabels.join(fieldSeparatorDisplay) : null;
      if (selectedFullLabel == selectedLabel) selectedFullLabel = null;
      return {
        placeholder: placeholder,
        selectedKey: selectedFuncKey,
        selectedKeys: selectedKeys,
        selectedPath: selectedPath,
        selectedLabel: selectedLabel,
        selectedOpts: selectedOpts,
        selectedFullLabel: selectedFullLabel
      };
    }
  }, {
    key: "filterFuncs",
    value: function filterFuncs(config, funcs, leftFieldFullkey, operator, canUseFuncForField) {
      funcs = clone_default()(funcs);
      var fieldSeparator = config.settings.fieldSeparator;
      var leftFieldConfig = Object(configUtils["b" /* getFieldConfig */])(leftFieldFullkey, config);
      var expectedType;
      var widget = Object(configUtils["n" /* getWidgetForFieldOp */])(config, leftFieldFullkey, operator, "value");

      if (widget) {
        var widgetConfig = config.widgets[widget];
        var widgetType = widgetConfig.type; //expectedType = leftFieldConfig.type;

        expectedType = widgetType;
      } else {
        expectedType = leftFieldConfig.type;
      }

      function _filter(list, path) {
        for (var funcKey in list) {
          var subfields = list[funcKey].subfields;
          var subpath = (path ? path : []).concat(funcKey);
          var funcFullkey = subpath.join(fieldSeparator);
          var funcConfig = Object(configUtils["h" /* getFuncConfig */])(funcFullkey, config);

          if (funcConfig.type == "!struct") {
            if (_filter(subfields, subpath) == 0) delete list[funcKey];
          } else {
            var canUse = funcConfig.returnType == expectedType;
            if (leftFieldConfig.funcs) canUse = canUse && leftFieldConfig.funcs.includes(funcFullkey);
            if (canUseFuncForField) canUse = canUse && canUseFuncForField(leftFieldFullkey, leftFieldConfig, funcFullkey, funcConfig, operator);
            if (!canUse) delete list[funcKey];
          }
        }

        return keys_default()(list).length;
      }

      _filter(funcs, []);

      return funcs;
    }
  }, {
    key: "buildOptions",
    value: function buildOptions(config, funcs) {
      var _this2 = this;

      var path = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var optGroupLabel = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      if (!funcs) return null;
      var _config$settings2 = config.settings,
          fieldSeparator = _config$settings2.fieldSeparator,
          fieldSeparatorDisplay = _config$settings2.fieldSeparatorDisplay;
      var prefix = path ? path.join(fieldSeparator) + fieldSeparator : "";
      return keys_default()(funcs).map(function (funcKey) {
        var func = funcs[funcKey];

        var label = _this2.getFuncLabel(func, funcKey, config);

        var partsLabels = Object(configUtils["i" /* getFuncPathLabels */])(funcKey, config);
        var fullLabel = partsLabels.join(fieldSeparatorDisplay);
        if (fullLabel == label) fullLabel = null;
        var tooltip = func.tooltip;
        var subpath = (path ? path : []).concat(funcKey);

        if (func.type == "!struct") {
          return {
            key: funcKey,
            path: prefix + funcKey,
            label: label,
            fullLabel: fullLabel,
            tooltip: tooltip,
            items: _this2.buildOptions(config, func.subfields, subpath, label)
          };
        } else {
          return {
            key: funcKey,
            path: prefix + funcKey,
            label: label,
            fullLabel: fullLabel,
            tooltip: tooltip,
            grouplabel: optGroupLabel
          };
        }
      });
    }
  }, {
    key: "getFuncLabel",
    value: function getFuncLabel(funcOpts, funcKey, config) {
      if (!funcKey) return null;
      var fieldSeparator = config.settings.fieldSeparator;
      var maxLabelsLength = config.settings.maxLabelsLength;
      var funcParts = Array.isArray(funcKey) ? funcKey : funcKey.split(fieldSeparator);
      var label = funcOpts.label || last_default()(funcParts);
      label = Object(stuff["l" /* truncateString */])(label, maxLabelsLength);
      return label;
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props = this.props,
          config = _this$props.config,
          customProps = _this$props.customProps,
          setValue = _this$props.setValue,
          readonly = _this$props.readonly;
      var renderFunc = config.settings.renderFunc;

      var renderProps = FuncSelect_objectSpread({
        config: config,
        customProps: customProps,
        readonly: readonly,
        setField: setValue,
        items: this.items
      }, this.meta);

      return renderFunc(renderProps);
    }
  }]);

  return FuncSelect;
}(external_React_["PureComponent"]);

FuncSelect_FuncSelect.propTypes = {
  config: prop_types_default.a.object.isRequired,
  field: prop_types_default.a.string.isRequired,
  operator: prop_types_default.a.string.isRequired,
  customProps: prop_types_default.a.object,
  value: prop_types_default.a.string,
  setValue: prop_types_default.a.func.isRequired,
  readonly: prop_types_default.a.bool
};

// EXTERNAL MODULE: ./modules/components/Widget.jsx + 1 modules
var Widget = __webpack_require__(25);

// EXTERNAL MODULE: ./modules/utils/funcUtils.js
var funcUtils = __webpack_require__(13);

// CONCATENATED MODULE: ./modules/components/FuncWidget.jsx
function FuncWidget_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { FuncWidget_typeof = function _typeof(obj) { return typeof obj; }; } else { FuncWidget_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return FuncWidget_typeof(obj); }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function FuncWidget_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function FuncWidget_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function FuncWidget_createClass(Constructor, protoProps, staticProps) { if (protoProps) FuncWidget_defineProperties(Constructor.prototype, protoProps); if (staticProps) FuncWidget_defineProperties(Constructor, staticProps); return Constructor; }

function FuncWidget_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) FuncWidget_setPrototypeOf(subClass, superClass); }

function FuncWidget_setPrototypeOf(o, p) { FuncWidget_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return FuncWidget_setPrototypeOf(o, p); }

function FuncWidget_createSuper(Derived) { var hasNativeReflectConstruct = FuncWidget_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = FuncWidget_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = FuncWidget_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return FuncWidget_possibleConstructorReturn(this, result); }; }

function FuncWidget_possibleConstructorReturn(self, call) { if (call && (FuncWidget_typeof(call) === "object" || typeof call === "function")) { return call; } return FuncWidget_assertThisInitialized(self); }

function FuncWidget_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function FuncWidget_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function FuncWidget_getPrototypeOf(o) { FuncWidget_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return FuncWidget_getPrototypeOf(o); }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }









var FuncWidget_Col = function Col(_ref) {
  var children = _ref.children,
      props = _objectWithoutProperties(_ref, ["children"]);

  return /*#__PURE__*/external_React_default.a.createElement("div", props, children);
};

var FuncWidget_FuncWidget = /*#__PURE__*/function (_PureComponent) {
  FuncWidget_inherits(FuncWidget, _PureComponent);

  var _super = FuncWidget_createSuper(FuncWidget);

  function FuncWidget(props) {
    var _this;

    FuncWidget_classCallCheck(this, FuncWidget);

    _this = _super.call(this, props);

    _this.setFunc = function (funcKey) {
      _this.props.setValue(Object(funcUtils["d" /* setFunc */])(_this.props.value, funcKey, _this.props.config));
    };

    _this.setArgValue = function (argKey, argVal) {
      _this.props.setValue(Object(funcUtils["b" /* setArgValue */])(_this.props.value, argKey, argVal));
    };

    _this.setArgValueSrc = function (argKey, argValSrc) {
      _this.props.setValue(Object(funcUtils["c" /* setArgValueSrc */])(_this.props.value, argKey, argValSrc));
    };

    _this.renderFuncSelect = function () {
      var _this$props = _this.props,
          config = _this$props.config,
          field = _this$props.field,
          operator = _this$props.operator,
          customProps = _this$props.customProps,
          value = _this$props.value,
          readonly = _this$props.readonly;
      var funcKey = value ? value.get("func") : null;
      var selectProps = {
        value: funcKey,
        setValue: _this.setFunc,
        config: config,
        field: field,
        operator: operator,
        customProps: customProps,
        readonly: readonly
      };
      var _config$settings = config.settings,
          showLabels = _config$settings.showLabels,
          funcLabel = _config$settings.funcLabel;
      var widgetLabel = showLabels ? /*#__PURE__*/external_React_default.a.createElement("label", {
        className: "rule--label"
      }, funcLabel) : null;
      return /*#__PURE__*/external_React_default.a.createElement(FuncWidget_Col, {
        key: "func",
        className: "rule--func"
      }, widgetLabel, /*#__PURE__*/external_React_default.a.createElement(FuncSelect_FuncSelect, selectProps));
    };

    _this.renderArgLabel = function (argKey, argDefinition) {
      var config = _this.props.config;
      var isConst = argDefinition.valueSources && argDefinition.valueSources.length == 1 && argDefinition.valueSources[0] == "const";
      var forceShow = !config.settings.showLabels && (argDefinition.type == "boolean" || isConst);
      if (!forceShow) return null;
      return /*#__PURE__*/external_React_default.a.createElement(FuncWidget_Col, {
        className: "rule--func--arg-label"
      }, argDefinition.label || argKey);
    };

    _this.renderArgLabelSep = function (argKey, argDefinition) {
      var config = _this.props.config;
      var isConst = argDefinition.valueSources && argDefinition.valueSources.length == 1 && argDefinition.valueSources[0] == "const";
      var forceShow = !config.settings.showLabels && (argDefinition.type == "boolean" || isConst);
      if (!forceShow) return null;
      return /*#__PURE__*/external_React_default.a.createElement(FuncWidget_Col, {
        className: "rule--func--arg-label-sep"
      }, ":");
    };

    _this.renderArgVal = function (funcKey, argKey, argDefinition) {
      var _this$props2 = _this.props,
          config = _this$props2.config,
          field = _this$props2.field,
          operator = _this$props2.operator,
          value = _this$props2.value,
          readonly = _this$props2.readonly;
      var arg = value ? value.getIn(["args", argKey]) : null;
      var argVal = arg ? arg.get("value") : undefined;
      var argValSrc = arg ? arg.get("valueSrc") || "value" : undefined;
      var widgetProps = {
        config: config,
        fieldFunc: funcKey,
        fieldArg: argKey,
        leftField: field,
        operator: null,
        value: argVal,
        valueSrc: argValSrc,
        setValue: _this.setArgValue,
        setValueSrc: _this.setArgValueSrc,
        funcKey: funcKey,
        argKey: argKey,
        argDefinition: argDefinition,
        readonly: readonly
      }; //tip: value & valueSrc will be converted to Immutable.List at WidgetContainer

      return /*#__PURE__*/external_React_default.a.createElement(FuncWidget_Col, {
        className: "rule--func--arg-value"
      }, /*#__PURE__*/external_React_default.a.createElement(FuncWidget_ArgWidget, widgetProps));
    };

    _this.renderArgSep = function (argKey, argDefinition, argIndex, _ref2) {
      var renderSeps = _ref2.renderSeps;
      if (!argIndex) return null;
      return /*#__PURE__*/external_React_default.a.createElement(FuncWidget_Col, {
        className: "rule--func--arg-sep"
      }, renderSeps ? renderSeps[argIndex - 1] : ", ");
    };

    _this.renderBracketBefore = function (_ref3) {
      var renderBrackets = _ref3.renderBrackets;
      return /*#__PURE__*/external_React_default.a.createElement(FuncWidget_Col, {
        key: "before_args",
        className: "rule--func--bracket-before"
      }, renderBrackets ? renderBrackets[0] : "(");
    };

    _this.renderBracketAfter = function (_ref4) {
      var renderBrackets = _ref4.renderBrackets;
      return /*#__PURE__*/external_React_default.a.createElement(FuncWidget_Col, {
        key: "after_args",
        className: "rule--func--bracket-after"
      }, renderBrackets ? renderBrackets[1] : ")");
    };

    _this.renderFuncArgs = function () {
      var _this$meta = _this.meta,
          funcDefinition = _this$meta.funcDefinition,
          funcKey = _this$meta.funcKey;
      if (!funcKey) return null;
      var args = funcDefinition.args;
      if (!args) return null;
      return /*#__PURE__*/external_React_default.a.createElement(external_React_default.a.Fragment, null, _this.renderBracketBefore(funcDefinition), /*#__PURE__*/external_React_default.a.createElement(FuncWidget_Col, {
        key: "args",
        className: "rule--func--args"
      }, Object.keys(args).map(function (argKey, argIndex) {
        return /*#__PURE__*/external_React_default.a.createElement(FuncWidget_Col, {
          key: "arg-".concat(argKey, "-").concat(argIndex),
          className: "rule--func--arg"
        }, _this.renderArgSep(argKey, args[argKey], argIndex, funcDefinition), _this.renderArgLabel(argKey, args[argKey]), _this.renderArgLabelSep(argKey, args[argKey]), _this.renderArgVal(funcKey, argKey, args[argKey]));
      })), _this.renderBracketAfter(funcDefinition));
    };

    Object(stuff["m" /* useOnPropsChanged */])(FuncWidget_assertThisInitialized(_this));

    _this.onPropsChanged(props);

    return _this;
  }

  FuncWidget_createClass(FuncWidget, [{
    key: "onPropsChanged",
    value: function onPropsChanged(nextProps) {
      var prevProps = this.props;
      var keysForMeta = ["config", "field", "operator", "value"];
      var needUpdateMeta = !this.meta || keysForMeta.map(function (k) {
        return nextProps[k] !== prevProps[k];
      }).filter(function (ch) {
        return ch;
      }).length > 0;

      if (needUpdateMeta) {
        this.meta = this.getMeta(nextProps);
      }
    }
  }, {
    key: "getMeta",
    value: function getMeta(_ref5) {
      var config = _ref5.config,
          field = _ref5.field,
          operator = _ref5.operator,
          value = _ref5.value;
      var funcKey = value ? value.get("func") : null;
      var funcDefinition = funcKey ? Object(configUtils["h" /* getFuncConfig */])(funcKey, config) : null;
      return {
        funcDefinition: funcDefinition,
        funcKey: funcKey
      };
    }
  }, {
    key: "render",
    value: function render() {
      return /*#__PURE__*/external_React_default.a.createElement(FuncWidget_Col, {
        className: "rule--func--wrapper"
      }, this.renderFuncSelect(), this.renderFuncArgs());
    }
  }]);

  return FuncWidget;
}(external_React_["PureComponent"]);

FuncWidget_FuncWidget.propTypes = {
  config: prop_types_default.a.object.isRequired,
  field: prop_types_default.a.string.isRequired,
  operator: prop_types_default.a.string.isRequired,
  customProps: prop_types_default.a.object,
  value: prop_types_default.a.object,
  //instanceOf(Immutable.Map) //with keys 'func' and `args`
  setValue: prop_types_default.a.func.isRequired,
  readonly: prop_types_default.a.bool
};


var FuncWidget_ArgWidget = /*#__PURE__*/function (_PureComponent2) {
  FuncWidget_inherits(ArgWidget, _PureComponent2);

  var _super2 = FuncWidget_createSuper(ArgWidget);

  function ArgWidget() {
    var _this2;

    FuncWidget_classCallCheck(this, ArgWidget);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this2 = _super2.call.apply(_super2, [this].concat(args));

    _this2.setValue = function (_delta, value, _widgetType) {
      var _this2$props = _this2.props,
          setValue = _this2$props.setValue,
          argKey = _this2$props.argKey;
      setValue(argKey, value);
    };

    _this2.setValueSrc = function (_delta, valueSrc, _widgetType) {
      var _this2$props2 = _this2.props,
          setValueSrc = _this2$props2.setValueSrc,
          argKey = _this2$props2.argKey;
      setValueSrc(argKey, valueSrc);
    };

    return _this2;
  }

  FuncWidget_createClass(ArgWidget, [{
    key: "render",
    value: function render() {
      return /*#__PURE__*/external_React_default.a.createElement(Widget["a" /* default */], _extends({}, this.props, {
        setValue: this.setValue,
        setValueSrc: this.setValueSrc,
        isFuncArg: true
      }));
    }
  }]);

  return ArgWidget;
}(external_React_["PureComponent"]);

FuncWidget_ArgWidget.propTypes = {
  funcKey: prop_types_default.a.string.isRequired,
  argKey: prop_types_default.a.string.isRequired,
  setValue: prop_types_default.a.func.isRequired,
  setValueSrc: prop_types_default.a.func.isRequired,
  readonly: prop_types_default.a.bool
};
// EXTERNAL MODULE: ./modules/utils/uuid.js
var uuid = __webpack_require__(8);

// CONCATENATED MODULE: ./modules/components/widgets/vanilla/value/VanillaBoolean.jsx


/* harmony default export */ var VanillaBoolean = (function (props) {
  var value = props.value,
      setValue = props.setValue,
      config = props.config,
      labelYes = props.labelYes,
      labelNo = props.labelNo,
      readonly = props.readonly;

  var onCheckboxChange = function onCheckboxChange(e) {
    return setValue(e.target.checked);
  };

  var onRadioChange = function onRadioChange(e) {
    return setValue(e.target.value == "true");
  };

  var id = Object(uuid["a" /* default */])(),
      id2 = Object(uuid["a" /* default */])(); // return <>
  //     <input key={id}  type="checkbox" id={id} checked={!!value} disabled={readonly} onChange={onCheckboxChange} />
  //     <label style={{display: "inline"}} key={id+"label"}  htmlFor={id}>{value ? labelYes : labelNo}</label>
  // </>;

  return /*#__PURE__*/external_React_default.a.createElement(external_React_default.a.Fragment, null, /*#__PURE__*/external_React_default.a.createElement("input", {
    key: id,
    type: "radio",
    id: id,
    value: true,
    checked: !!value,
    disabled: readonly,
    onChange: onRadioChange
  }), /*#__PURE__*/external_React_default.a.createElement("label", {
    style: {
      display: "inline"
    },
    key: id + "label",
    htmlFor: id
  }, labelYes), /*#__PURE__*/external_React_default.a.createElement("input", {
    key: id2,
    type: "radio",
    id: id2,
    value: false,
    checked: !value,
    disabled: readonly,
    onChange: onRadioChange
  }), /*#__PURE__*/external_React_default.a.createElement("label", {
    style: {
      display: "inline"
    },
    key: id2 + "label",
    htmlFor: id2
  }, labelNo));
});
// CONCATENATED MODULE: ./modules/components/widgets/vanilla/value/VanillaText.jsx

/* harmony default export */ var VanillaText = (function (props) {
  var value = props.value,
      setValue = props.setValue,
      config = props.config,
      readonly = props.readonly,
      placeholder = props.placeholder;

  var onChange = function onChange(e) {
    var val = e.target.value;
    if (val === "") val = undefined; // don't allow empty value

    setValue(val);
  };

  var textValue = value || "";
  return /*#__PURE__*/external_React_default.a.createElement("input", {
    type: "text",
    value: textValue,
    placeholder: placeholder,
    disabled: readonly,
    onChange: onChange
  });
});
// EXTERNAL MODULE: external "moment"
var external_moment_ = __webpack_require__(9);
var external_moment_default = /*#__PURE__*/__webpack_require__.n(external_moment_);

// CONCATENATED MODULE: ./modules/components/widgets/vanilla/value/VanillaDate.jsx


/* harmony default export */ var VanillaDate = (function (props) {
  var value = props.value,
      setValue = props.setValue,
      config = props.config,
      valueFormat = props.valueFormat,
      readonly = props.readonly;

  var onChange = function onChange(e) {
    var value = e.target.value;
    if (value == "") value = undefined;
    setValue(value);
  };

  return /*#__PURE__*/external_React_default.a.createElement("input", {
    type: "date",
    value: value || "",
    disabled: readonly,
    onChange: onChange
  });
});
// CONCATENATED MODULE: ./modules/components/widgets/vanilla/value/VanillaTime.jsx

/* harmony default export */ var VanillaTime = (function (props) {
  var value = props.value,
      setValue = props.setValue,
      config = props.config,
      valueFormat = props.valueFormat,
      use12Hours = props.use12Hours,
      readonly = props.readonly;

  var onChange = function onChange(e) {
    var value = e.target.value;
    if (value == "") value = undefined;
    setValue(value);
  };

  return /*#__PURE__*/external_React_default.a.createElement("input", {
    type: "time",
    value: value || "",
    disabled: readonly,
    onChange: onChange
  });
});
// CONCATENATED MODULE: ./modules/components/widgets/vanilla/value/VanillaDateTime.jsx


/* harmony default export */ var VanillaDateTime = (function (props) {
  var value = props.value,
      setValue = props.setValue,
      config = props.config,
      valueFormat = props.valueFormat,
      use12Hours = props.use12Hours,
      readonly = props.readonly;

  var onChange = function onChange(e) {
    var value = e.target.value;
    if (value == "") value = undefined;else value = external_moment_default()(new Date(value)).format(valueFormat);
    setValue(value);
  };

  var dtValue = value;
  if (!value) dtValue = "";else dtValue = external_moment_default()(value).format("YYYY-MM-DDTHH:mm");
  return /*#__PURE__*/external_React_default.a.createElement("input", {
    type: "datetime-local",
    value: dtValue,
    disabled: readonly,
    onChange: onChange
  });
});
// CONCATENATED MODULE: ./modules/components/widgets/vanilla/value/VanillaMultiSelect.jsx


/* harmony default export */ var VanillaMultiSelect = (function (_ref) {
  var listValues = _ref.listValues,
      value = _ref.value,
      setValue = _ref.setValue,
      allowCustomValues = _ref.allowCustomValues,
      readonly = _ref.readonly;

  var renderOptions = function renderOptions() {
    return Object(stuff["i" /* mapListValues */])(listValues, function (_ref2) {
      var title = _ref2.title,
          value = _ref2.value;
      return /*#__PURE__*/external_React_default.a.createElement("option", {
        key: value,
        value: value
      }, title);
    });
  };

  var getMultiSelectValues = function getMultiSelectValues(multiselect) {
    var values = [];
    var options = multiselect.options;

    for (var i = 0; i < options.length; i++) {
      var opt = options[i];

      if (opt.selected) {
        values.push(opt.value);
      }
    }

    if (!values.length) values = undefined; //not allow []

    return values;
  };

  var onChange = function onChange(e) {
    return setValue(getMultiSelectValues(e.target));
  };

  return /*#__PURE__*/external_React_default.a.createElement("select", {
    multiple: true,
    onChange: onChange,
    value: value,
    disabled: readonly
  }, renderOptions());
});
// CONCATENATED MODULE: ./modules/components/widgets/vanilla/value/VanillaSelect.jsx


/* harmony default export */ var VanillaSelect = (function (_ref) {
  var listValues = _ref.listValues,
      value = _ref.value,
      setValue = _ref.setValue,
      allowCustomValues = _ref.allowCustomValues,
      readonly = _ref.readonly;

  var renderOptions = function renderOptions() {
    return Object(stuff["i" /* mapListValues */])(listValues, function (_ref2) {
      var title = _ref2.title,
          value = _ref2.value;
      return /*#__PURE__*/external_React_default.a.createElement("option", {
        key: value,
        value: value
      }, title);
    });
  };

  var onChange = function onChange(e) {
    return setValue(e.target.value);
  };

  var hasValue = value != null;
  return /*#__PURE__*/external_React_default.a.createElement("select", {
    onChange: onChange,
    value: hasValue ? value : "",
    disabled: readonly
  }, !hasValue && /*#__PURE__*/external_React_default.a.createElement("option", {
    disabled: true,
    value: ""
  }), renderOptions());
});
// CONCATENATED MODULE: ./modules/components/widgets/vanilla/value/VanillaNumber.jsx

/* harmony default export */ var VanillaNumber = (function (props) {
  var value = props.value,
      setValue = props.setValue,
      config = props.config,
      readonly = props.readonly,
      min = props.min,
      max = props.max,
      step = props.step,
      placeholder = props.placeholder;

  var onChange = function onChange(e) {
    var val = e.target.value;
    if (val === "" || val === null) val = undefined;else val = Number(val);
    setValue(val);
  };

  var numberValue = value == undefined ? "" : value;
  return /*#__PURE__*/external_React_default.a.createElement("input", {
    type: "number",
    value: numberValue,
    placeholder: placeholder,
    disabled: readonly,
    min: min,
    max: max,
    step: step,
    onChange: onChange
  });
});
// CONCATENATED MODULE: ./modules/components/widgets/vanilla/value/VanillaSlider.jsx

/* harmony default export */ var VanillaSlider = (function (props) {
  var value = props.value,
      setValue = props.setValue,
      config = props.config,
      readonly = props.readonly,
      min = props.min,
      max = props.max,
      step = props.step,
      placeholder = props.placeholder;

  var onChange = function onChange(e) {
    var val = e.target.value;
    if (val === "" || val === null) val = undefined;else val = Number(val);
    setValue(val);
  };

  var numberValue = value == undefined ? "" : value;
  return [/*#__PURE__*/external_React_default.a.createElement("input", {
    key: "number",
    type: "number",
    value: numberValue,
    placeholder: placeholder,
    disabled: readonly,
    min: min,
    max: max,
    step: step,
    onChange: onChange
  }), /*#__PURE__*/external_React_default.a.createElement("input", {
    key: "range",
    type: "range",
    value: numberValue,
    disabled: readonly,
    min: min,
    max: max,
    step: step,
    onChange: onChange
  })];
});
// CONCATENATED MODULE: ./modules/components/widgets/vanilla/core/VanillaFieldSelect.jsx

/* harmony default export */ var VanillaFieldSelect = (function (_ref) {
  var items = _ref.items,
      setField = _ref.setField,
      selectedKey = _ref.selectedKey,
      readonly = _ref.readonly;

  var renderOptions = function renderOptions(fields) {
    return Object.keys(fields).map(function (fieldKey) {
      var field = fields[fieldKey];
      var items = field.items,
          path = field.path,
          label = field.label,
          disabled = field.disabled;

      if (items) {
        return /*#__PURE__*/external_React_default.a.createElement("optgroup", {
          disabled: disabled,
          key: path,
          label: label
        }, renderOptions(items));
      } else {
        return /*#__PURE__*/external_React_default.a.createElement("option", {
          disabled: disabled,
          key: path,
          value: path
        }, label);
      }
    });
  };

  var onChange = function onChange(e) {
    return setField(e.target.value);
  };

  var hasValue = selectedKey != null;
  return /*#__PURE__*/external_React_default.a.createElement("select", {
    onChange: onChange,
    value: hasValue ? selectedKey : "",
    disabled: readonly
  }, !hasValue && /*#__PURE__*/external_React_default.a.createElement("option", {
    disabled: true,
    value: ""
  }), renderOptions(items));
});
// CONCATENATED MODULE: ./modules/components/widgets/vanilla/core/VanillaConjs.jsx

/* harmony default export */ var VanillaConjs = (function (_ref) {
  var id = _ref.id,
      not = _ref.not,
      setNot = _ref.setNot,
      conjunctionOptions = _ref.conjunctionOptions,
      setConjunction = _ref.setConjunction,
      disabled = _ref.disabled,
      readonly = _ref.readonly,
      config = _ref.config;
  var conjsCount = Object.keys(conjunctionOptions).length;
  var lessThenTwo = disabled;

  var renderOptions = function renderOptions() {
    return Object.keys(conjunctionOptions).map(function (key) {
      var _conjunctionOptions$k = conjunctionOptions[key],
          id = _conjunctionOptions$k.id,
          name = _conjunctionOptions$k.name,
          label = _conjunctionOptions$k.label,
          checked = _conjunctionOptions$k.checked;
      var postfix = setConjunction.isDummyFn ? "__dummy" : "";
      return [/*#__PURE__*/external_React_default.a.createElement("input", {
        key: id + postfix,
        type: "radio",
        id: id + postfix,
        name: name + postfix,
        checked: checked,
        disabled: readonly,
        value: key,
        onChange: onChange
      }), /*#__PURE__*/external_React_default.a.createElement("label", {
        key: id + postfix + "label",
        htmlFor: id + postfix
      }, label)];
    });
  };

  var renderNot = function renderNot() {
    return [/*#__PURE__*/external_React_default.a.createElement("input", {
      key: id,
      type: "checkbox",
      id: id + "__not",
      checked: not,
      disabled: readonly,
      onChange: onNotChange
    }), /*#__PURE__*/external_React_default.a.createElement("label", {
      key: id + "label",
      htmlFor: id + "__not"
    }, config.settings.notLabel || "NOT")];
  };

  var onChange = function onChange(e) {
    return setConjunction(e.target.value);
  };

  var onNotChange = function onNotChange(e) {
    return setNot(e.target.checked);
  };

  return [config.settings.showNot && renderNot(), conjsCount > 1 && !lessThenTwo && renderOptions()];
});
// CONCATENATED MODULE: ./modules/components/widgets/vanilla/core/VanillaButton.jsx

/* harmony default export */ var VanillaButton = (function (_ref) {
  var type = _ref.type,
      label = _ref.label,
      onClick = _ref.onClick,
      config = _ref.config;
  var typeToLabel = {
    "addRuleGroup": "+",
    "delGroup": "x",
    "delRule": "x"
  };
  var btnLabel = typeToLabel[type] || label;
  return /*#__PURE__*/external_React_default.a.createElement("button", {
    onClick: onClick,
    type: "button"
  }, btnLabel);
});
// CONCATENATED MODULE: ./modules/components/widgets/vanilla/core/VanillaButtonGroup.jsx

/* harmony default export */ var VanillaButtonGroup = (function (_ref) {
  var children = _ref.children,
      config = _ref.config;
  return /*#__PURE__*/external_React_default.a.createElement(external_React_default.a.Fragment, null, children);
});
// CONCATENATED MODULE: ./modules/components/widgets/vanilla/core/VanillaValueSources.jsx
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }


/* harmony default export */ var VanillaValueSources = (function (_ref) {
  var config = _ref.config,
      valueSources = _ref.valueSources,
      valueSrc = _ref.valueSrc,
      title = _ref.title,
      setValueSrc = _ref.setValueSrc,
      readonly = _ref.readonly;

  var renderOptions = function renderOptions(valueSources) {
    return valueSources.map(function (_ref2) {
      var _ref3 = _slicedToArray(_ref2, 2),
          srcKey = _ref3[0],
          info = _ref3[1];

      return /*#__PURE__*/external_React_default.a.createElement("option", {
        key: srcKey,
        value: srcKey
      }, info.label);
    });
  };

  var onChange = function onChange(e) {
    return setValueSrc(e.target.value);
  };

  return /*#__PURE__*/external_React_default.a.createElement("select", {
    onChange: onChange,
    value: valueSrc,
    disabled: readonly
  }, renderOptions(valueSources));
});
// CONCATENATED MODULE: ./modules/components/widgets/vanilla/core/vanillaConfirm.jsx
/* harmony default export */ var vanillaConfirm = (function (_ref) {
  var onOk = _ref.onOk,
      okText = _ref.okText,
      cancelText = _ref.cancelText,
      title = _ref.title;

  if (confirm(title)) {
    onOk();
  }
});
// CONCATENATED MODULE: ./modules/components/widgets/vanilla/index.js
 // value widgets









 // field select widget

 // core components






var VanillaProvider = function VanillaProvider(_ref) {
  var config = _ref.config,
      children = _ref.children;
  return children;
};
// CONCATENATED MODULE: ./modules/components/widgets/index.js

 //export * from './antd/index.js';



/***/ }),
/* 11 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__11__;

/***/ }),
/* 12 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__12__;

/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return completeValue; });
/* unused harmony export completeFuncValue */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return setFunc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return setArgValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return setArgValueSrc; });
/* harmony import */ var _utils_configUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var immutable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);
/* harmony import */ var immutable__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(immutable__WEBPACK_IMPORTED_MODULE_1__);
function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }



/**
 * @param {*} value
 * @param {string} valueSrc - 'value' | 'field' | 'func'
 * @param {object} config
 * @return {* | undefined} - undefined if func value is not complete (missing required arg vals); can return completed value != value
 */

var completeValue = function completeValue(value, valueSrc, config) {
  if (valueSrc == "func") return completeFuncValue(value, config);else return value;
};
/**
 * @param {Immutable.Map} value
 * @param {object} config
 * @return {Immutable.Map | undefined} - undefined if func value is not complete (missing required arg vals); can return completed value != value
 */

var completeFuncValue = function completeFuncValue(value, config) {
  var _checkFuncValue = function _checkFuncValue(value) {
    if (!value) return undefined;
    var funcKey = value.get("func");
    var funcConfig = funcKey && Object(_utils_configUtils__WEBPACK_IMPORTED_MODULE_0__[/* getFuncConfig */ "h"])(funcKey, config);
    if (!funcConfig) return undefined;
    var complValue = value;
    var tmpHasOptional = false;

    for (var argKey in funcConfig.args) {
      var argConfig = funcConfig.args[argKey];
      var args = complValue.get("args");
      var argVal = args ? args.get(argKey) : undefined;
      var argValue = argVal ? argVal.get("value") : undefined;
      var argValueSrc = argVal ? argVal.get("valueSrc") : undefined;

      if (argValue !== undefined) {
        var completeArgValue = completeValue(argValue, argValueSrc, config);

        if (completeArgValue === undefined) {
          return undefined;
        } else if (completeArgValue !== argValue) {
          complValue = complValue.setIn(["args", argKey, "value"], completeArgValue);
        }

        if (tmpHasOptional) {
          // has gap
          return undefined;
        }
      } else if (argConfig.defaultValue !== undefined) {
        complValue = complValue.setIn(["args", argKey, "value"], argConfig.defaultValue);
        complValue = complValue.setIn(["args", argKey, "valueSrc"], "value");
      } else if (argConfig.isOptional) {
        // optional
        tmpHasOptional = true;
      } else {
        // missing value
        return undefined;
      }
    }

    return complValue;
  };

  return _checkFuncValue(value);
};
/**
 * @param {Immutable.Map} value 
 * @return {array} - [usedFields, badFields]
 */

var getUsedFieldsInFuncValue = function getUsedFieldsInFuncValue(value, config) {
  var usedFields = [];
  var badFields = [];

  var _traverse = function _traverse(value) {
    var args = value && value.get("args");
    if (!args) return;

    var _iterator = _createForOfIteratorHelper(args.values()),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var arg = _step.value;

        if (arg.get("valueSrc") == "field") {
          var rightField = arg.get("value");

          if (rightField) {
            var rightFieldDefinition = config ? Object(_utils_configUtils__WEBPACK_IMPORTED_MODULE_0__[/* getFieldConfig */ "b"])(rightField, config) : undefined;
            if (config && !rightFieldDefinition) badFields.push(rightField);else usedFields.push(rightField);
          }
        } else if (arg.get("valueSrc") == "func") {
          _traverse(arg.get("value"));
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  };

  _traverse(value);

  return [usedFields, badFields];
};
/**
 * Used @ FuncWidget
 * @param {Immutable.Map} value 
 * @param {string} funcKey 
 * @param {object} config 
 */


var setFunc = function setFunc(value, funcKey, config) {
  var fieldSeparator = config.settings.fieldSeparator;
  value = value || new immutable__WEBPACK_IMPORTED_MODULE_1___default.a.Map();

  if (Array.isArray(funcKey)) {
    // fix for cascader
    funcKey = funcKey.join(fieldSeparator);
  }

  value = value.set("func", funcKey);
  value = value.set("args", new immutable__WEBPACK_IMPORTED_MODULE_1___default.a.Map()); // defaults

  var funcConfig = funcKey && Object(_utils_configUtils__WEBPACK_IMPORTED_MODULE_0__[/* getFuncConfig */ "h"])(funcKey, config);

  if (funcConfig) {
    for (var argKey in funcConfig.args) {
      var argConfig = funcConfig.args[argKey];

      if (argConfig.defaultValue !== undefined) {
        value = value.setIn(["args", argKey, "value"], argConfig.defaultValue);
      }
    }
  }

  return value;
};
/**
* Used @ FuncWidget
* @param {Immutable.Map} value 
* @param {string} argKey 
* @param {*} argVal 
*/

var setArgValue = function setArgValue(value, argKey, argVal) {
  if (value && value.get("func")) {
    value = value.setIn(["args", argKey, "value"], argVal);
  }

  return value;
};
/**
* Used @ FuncWidget
* @param {Immutable.Map} value 
* @param {string} argKey 
* @param {string} argValSrc 
*/

var setArgValueSrc = function setArgValueSrc(value, argKey, argValSrc) {
  if (value && value.get("func")) {
    value = value.setIn(["args", argKey], new immutable__WEBPACK_IMPORTED_MODULE_1___default.a.Map({
      valueSrc: argValSrc
    }));
  }

  return value;
};

/***/ }),
/* 14 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return validateTree; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return validateValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return getNewValueForFieldOp; });
/* harmony import */ var _configUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _utils_stuff__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
/* harmony import */ var _utils_defaultUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7);
/* harmony import */ var lodash_omit__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(11);
/* harmony import */ var lodash_omit__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(lodash_omit__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var immutable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(5);
/* harmony import */ var immutable__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(immutable__WEBPACK_IMPORTED_MODULE_4__);
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }







var typeOf = function typeOf(v) {
  if (_typeof(v) == "object" && v !== null && Array.isArray(v)) return "array";else return _typeof(v);
};

var isTypeOf = function isTypeOf(v, type) {
  if (typeOf(v) == type) return true;
  if (type == "number" && !isNaN(v)) return true; //can be casted

  return false;
};

var validateTree = function validateTree(tree, _oldTree, config, oldConfig) {
  var removeEmptyGroups = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
  var removeInvalidRules = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
  var c = {
    config: config,
    oldConfig: oldConfig,
    removeEmptyGroups: removeEmptyGroups,
    removeInvalidRules: removeInvalidRules
  };
  return validateItem(tree, [], null, {}, c);
};

function validateItem(item, path, itemId, meta, c) {
  var type = item.get("type");
  var children = item.get("children1");

  if ((type === "group" || type === "rule_group") && children && children.size) {
    return validateGroup(item, path, itemId, meta, c);
  } else if (type === "rule") {
    return validateRule(item, path, itemId, meta, c);
  } else {
    return item;
  }
}

function validateGroup(item, path, itemId, meta, c) {
  var removeEmptyGroups = c.removeEmptyGroups;
  var id = item.get("id");
  var children = item.get("children1");
  var oldChildren = children;

  if (!id && itemId) {
    id = itemId;
    item = item.set("id", id);
    meta.sanitized = true;
  } //validate children


  var submeta = {};
  children = children.map(function (currentChild, childId) {
    return validateItem(currentChild, path.concat(id), childId, submeta, c);
  });
  if (removeEmptyGroups) children = children.filter(function (currentChild) {
    return currentChild != undefined;
  });
  var sanitized = submeta.sanitized || oldChildren.size != children.size;

  if (!children.size && removeEmptyGroups && path.length) {
    sanitized = true;
    item = undefined;
  }

  if (sanitized) meta.sanitized = true;
  if (sanitized && item) item = item.set("children1", children);
  return item;
}

function validateRule(item, path, itemId, meta, c) {
  var removeInvalidRules = c.removeInvalidRules,
      config = c.config,
      oldConfig = c.oldConfig;
  var showErrorMessage = config.settings.showErrorMessage;
  var id = item.get("id");
  var properties = item.get("properties");
  var field = properties.get("field");
  var operator = properties.get("operator");
  var operatorOptions = properties.get("operatorOptions");
  var valueSrc = properties.get("valueSrc");
  var value = properties.get("value");
  var valueError = properties.get("valueError");
  var oldSerialized = {
    field: field,
    operator: operator,
    operatorOptions: operatorOptions ? operatorOptions.toJS() : {},
    valueSrc: valueSrc ? valueSrc.toJS() : null,
    value: value ? value.toJS() : null,
    valueError: valueError ? valueError.toJS() : null
  };

  var _wasValid = field && operator && value && !value.find(function (v, ind) {
    return v === undefined;
  });

  if (!id && itemId) {
    id = itemId;
    item = item.set("id", id);
    meta.sanitized = true;
  } //validate field


  var fieldDefinition = field ? Object(_configUtils__WEBPACK_IMPORTED_MODULE_0__[/* getFieldConfig */ "b"])(field, config) : null;
  if (!fieldDefinition) field = null;

  if (field == null) {
    properties = ["operator", "operatorOptions", "valueSrc", "value"].reduce(function (map, key) {
      return map["delete"](key);
    }, properties);
    operator = null;
  } //validate operator


  operator = properties.get("operator");

  if (operator == "range_between" || operator == "range_not_between") {
    // fix obsolete operators
    operator = operator == "range_between" ? "between" : "not_between";
    properties = properties.set("operator", operator);
  }

  var operatorDefinition = operator ? Object(_configUtils__WEBPACK_IMPORTED_MODULE_0__[/* getOperatorConfig */ "j"])(config, operator, field) : null;
  if (!operatorDefinition) operator = null;
  var availOps = field ? Object(_configUtils__WEBPACK_IMPORTED_MODULE_0__[/* getOperatorsForField */ "k"])(config, field) : [];

  if (!availOps) {
    console.warn("Type of field ".concat(field, " is not supported"));
    operator = null;
  } else if (availOps.indexOf(operator) == -1) {
    operator = null;
  }

  if (operator == null) {
    properties = properties["delete"]("operatorOptions");
    properties = properties["delete"]("valueSrc");
    properties = properties["delete"]("value");
  } //validate operator options


  operatorOptions = properties.get("operatorOptions");

  var _operatorCardinality = operator ? Object(_utils_stuff__WEBPACK_IMPORTED_MODULE_1__[/* defaultValue */ "c"])(operatorDefinition.cardinality, 1) : null;

  if (!operator || operatorOptions && !operatorDefinition.options) {
    operatorOptions = null;
    properties = properties["delete"]("operatorOptions");
  } else if (operator && !operatorOptions && operatorDefinition.options) {
    operatorOptions = Object(_utils_defaultUtils__WEBPACK_IMPORTED_MODULE_2__[/* defaultOperatorOptions */ "e"])(config, operator, field);
    properties = properties.set("operatorOptions", operatorOptions);
  } //validate values


  valueSrc = properties.get("valueSrc");
  value = properties.get("value");

  var _getNewValueForFieldO = getNewValueForFieldOp(config, oldConfig, properties, field, operator, null, true),
      newValue = _getNewValueForFieldO.newValue,
      newValueSrc = _getNewValueForFieldO.newValueSrc,
      newValueError = _getNewValueForFieldO.newValueError;

  value = newValue;
  valueSrc = newValueSrc;
  valueError = newValueError;
  properties = properties.set("value", value);
  properties = properties.set("valueSrc", valueSrc);

  if (showErrorMessage) {
    properties = properties.set("valueError", valueError);
  }

  var newSerialized = {
    field: field,
    operator: operator,
    operatorOptions: operatorOptions ? operatorOptions.toJS() : {},
    valueSrc: valueSrc ? valueSrc.toJS() : null,
    value: value ? value.toJS() : null,
    valueError: valueError ? valueError.toJS() : null
  };
  var sanitized = !Object(_utils_stuff__WEBPACK_IMPORTED_MODULE_1__[/* deepEqual */ "b"])(oldSerialized, newSerialized);
  var isValid = field && operator && value && !value.find(function (v, _ind) {
    return v === undefined;
  });
  if (sanitized) meta.sanitized = true;
  if (sanitized && !isValid && removeInvalidRules) item = undefined;
  if (sanitized && item) item = item.set("properties", properties);
  return item;
}
/**
 * 
 * @param {bool} canFix true is useful for func values to remove bad args
 * @param {bool} isEndValue false if value is in process of editing by user
 * @param {bool} isRawValue false is used only internally from validateFuncValue
 * @return {array} [validError, fixedValue] - if validError === null and canFix == true, fixedValue can differ from value if was fixed
 */


var validateValue = function validateValue(config, leftField, field, operator, value, valueType, valueSrc) {
  var canFix = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;
  var isEndValue = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : false;
  var isRawValue = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : true;
  var validError = null;
  var fixedValue = value;

  if (value != null) {
    if (valueSrc == "field") {
      var _validateFieldValue = validateFieldValue(leftField, field, value, valueSrc, valueType, config, operator, isEndValue, canFix);

      var _validateFieldValue2 = _slicedToArray(_validateFieldValue, 2);

      validError = _validateFieldValue2[0];
      fixedValue = _validateFieldValue2[1];
    } else if (valueSrc == "func") {
      var _validateFuncValue = validateFuncValue(leftField, field, value, valueSrc, valueType, config, operator, isEndValue, canFix);

      var _validateFuncValue2 = _slicedToArray(_validateFuncValue, 2);

      validError = _validateFuncValue2[0];
      fixedValue = _validateFuncValue2[1];
    } else if (valueSrc == "value" || !valueSrc) {
      var _validateNormalValue = validateNormalValue(leftField, field, value, valueSrc, valueType, config, operator, isEndValue, canFix);

      var _validateNormalValue2 = _slicedToArray(_validateNormalValue, 2);

      validError = _validateNormalValue2[0];
      fixedValue = _validateNormalValue2[1];
    }

    if (!validError) {
      var fieldConfig = Object(_configUtils__WEBPACK_IMPORTED_MODULE_0__[/* getFieldConfig */ "b"])(field, config);
      var w = Object(_configUtils__WEBPACK_IMPORTED_MODULE_0__[/* getWidgetForFieldOp */ "n"])(config, field, operator, valueSrc);
      var fieldWidgetDefinition = lodash_omit__WEBPACK_IMPORTED_MODULE_3___default()(Object(_configUtils__WEBPACK_IMPORTED_MODULE_0__[/* getFieldWidgetConfig */ "e"])(config, field, operator, w, valueSrc), ["factory"]);
      var rightFieldDefinition = valueSrc == "field" ? Object(_configUtils__WEBPACK_IMPORTED_MODULE_0__[/* getFieldConfig */ "b"])(value, config) : null;
      var fieldSettings = fieldWidgetDefinition; // widget definition merged with fieldSettings

      var fn = fieldWidgetDefinition.validateValue;

      if (typeof fn == "function") {
        var args = [fixedValue, fieldSettings];
        if (valueSrc == "field") args.push(rightFieldDefinition);
        var validResult = fn.apply(void 0, args);

        if (typeof validResult == "boolean") {
          if (validResult == false) validError = "Invalid value";
        } else {
          validError = validResult;
        }
      }
    }
  }

  if (isRawValue && validError) {
    console.warn("[RAQB validate]", "Field ".concat(field, ": ").concat(validError));
  }

  return [validError, validError ? value : fixedValue];
};
/**
* 
*/

var validateNormalValue = function validateNormalValue(leftField, field, value, valueSrc, valueType, config) {
  var operator = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;
  var isEndValue = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;
  var canFix = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : false;
  var fixedValue = value;
  var fieldConfig = Object(_configUtils__WEBPACK_IMPORTED_MODULE_0__[/* getFieldConfig */ "b"])(field, config);
  var w = Object(_configUtils__WEBPACK_IMPORTED_MODULE_0__[/* getWidgetForFieldOp */ "n"])(config, field, operator, valueSrc);
  var wConfig = config.widgets[w];
  var wType = wConfig.type;
  var jsType = wConfig.jsType;
  var fieldSettings = fieldConfig.fieldSettings;
  if (valueType != wType) return ["Value should have type ".concat(wType, ", but got value of type ").concat(valueType), value];

  if (jsType && !isTypeOf(value, jsType) && !fieldSettings.listValues) {
    //tip: can skip tye check for listValues
    return ["Value should have JS type ".concat(jsType, ", but got value of type ").concat(_typeof(value)), value];
  }

  if (fieldSettings) {
    if (fieldSettings.listValues && !fieldSettings.allowCustomValues) {
      if (value instanceof Array) {
        for (var i = 0; i < value.length; i++) {
          var vv = Object(_utils_stuff__WEBPACK_IMPORTED_MODULE_1__[/* getItemInListValues */ "e"])(fieldSettings.listValues, value[i]);

          if (vv == undefined) {
            return ["Value ".concat(value[i], " is not in list of values"), value];
          } else {
            value[i] = vv.value;
          }
        }
      } else {
        var _vv = Object(_utils_stuff__WEBPACK_IMPORTED_MODULE_1__[/* getItemInListValues */ "e"])(fieldSettings.listValues, value);

        if (_vv == undefined) {
          return ["Value ".concat(value, " is not in list of values"), value];
        } else {
          value = _vv.value;
        }
      }
    }

    if (fieldSettings.min != null && value < fieldSettings.min) {
      return ["Value ".concat(value, " < min ").concat(fieldSettings.min), value];
    }

    if (fieldSettings.max != null && value > fieldSettings.max) {
      return ["Value ".concat(value, " > max ").concat(fieldSettings.max), value];
    }
  }

  return [null, value];
};
/**
* 
*/


var validateFieldValue = function validateFieldValue(leftField, field, value, _valueSrc, valueType, config) {
  var operator = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;
  var isEndValue = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;
  var canFix = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : false;
  var fieldSeparator = config.settings.fieldSeparator;
  var leftFieldStr = Array.isArray(leftField) ? leftField.join(fieldSeparator) : leftField;
  var rightFieldStr = Array.isArray(value) ? value.join(fieldSeparator) : value;
  var rightFieldDefinition = Object(_configUtils__WEBPACK_IMPORTED_MODULE_0__[/* getFieldConfig */ "b"])(value, config);
  if (!rightFieldDefinition) return ["Unknown field ".concat(value), value];
  if (rightFieldStr == leftFieldStr) return ["Can't compare field ".concat(leftField, " with itself"), value];
  if (valueType && valueType != rightFieldDefinition.type) return ["Field ".concat(value, " is of type ").concat(rightFieldDefinition.type, ", but expected ").concat(valueType), value];
  return [null, value];
};
/**
* 
*/


var validateFuncValue = function validateFuncValue(leftField, field, value, _valueSrc, valueType, config) {
  var operator = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;
  var isEndValue = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : false;
  var canFix = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : false;
  var fixedValue = value;

  if (value) {
    var funcKey = value.get("func");

    if (funcKey) {
      var funcConfig = Object(_configUtils__WEBPACK_IMPORTED_MODULE_0__[/* getFuncConfig */ "h"])(funcKey, config);

      if (funcConfig) {
        if (valueType && funcConfig.returnType != valueType) return ["Function ".concat(funcKey, " should return value of type ").concat(funcConfig.returnType, ", but got ").concat(valueType), value];

        for (var argKey in funcConfig.args) {
          var argConfig = funcConfig.args[argKey];
          var args = fixedValue.get("args");
          var argVal = args ? args.get(argKey) : undefined;
          var fieldDef = Object(_configUtils__WEBPACK_IMPORTED_MODULE_0__[/* getFieldConfig */ "b"])(argConfig, config);
          var argValue = argVal ? argVal.get("value") : undefined;
          var argValueSrc = argVal ? argVal.get("valueSrc") : undefined;

          if (argValue !== undefined) {
            var _validateValue = validateValue(config, leftField, fieldDef, operator, argValue, argConfig.type, argValueSrc, canFix, isEndValue, false),
                _validateValue2 = _slicedToArray(_validateValue, 2),
                argValidError = _validateValue2[0],
                fixedArgVal = _validateValue2[1];

            if (argValidError !== null) {
              if (canFix) {
                fixedValue = fixedValue.deleteIn(["args", argKey]);

                if (argConfig.defaultValue !== undefined) {
                  fixedValue = fixedValue.setIn(["args", argKey, "value"], argConfig.defaultValue);
                  fixedValue = fixedValue.setIn(["args", argKey, "valueSrc"], "value");
                }
              } else {
                return ["Invalid value of arg ".concat(argKey, " for func ").concat(funcKey, ": ").concat(argValidError), value];
              }
            } else if (fixedArgVal !== argValue) {
              fixedValue = fixedValue.setIn(["args", argKey, "value"], fixedArgVal);
            }
          } else if (isEndValue && argConfig.defaultValue === undefined && !canFix) {
            return ["Value of arg ".concat(argKey, " for func ").concat(funcKey, " is required"), value];
          }
        }
      } else return ["Unknown function ".concat(funcKey), value];
    } // else it's not function value

  } // empty value


  return [null, fixedValue];
};
/**
 * @param {object} config
 * @param {object} oldConfig
 * @param {Immutable.Map} current
 * @param {string} newField
 * @param {string} newOperator
 * @param {string} changedField
 * @return {object} - {canReuseValue, newValue, newValueSrc, newValueType, newValueError}
 */


var getNewValueForFieldOp = function getNewValueForFieldOp(config) {
  var oldConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var current = arguments.length > 2 ? arguments[2] : undefined;
  var newField = arguments.length > 3 ? arguments[3] : undefined;
  var newOperator = arguments.length > 4 ? arguments[4] : undefined;
  var changedField = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : null;
  var canFix = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : true;
  if (!oldConfig) oldConfig = config;
  var currentField = current.get("field");
  var currentOperator = current.get("operator");
  var currentValue = current.get("value");
  var currentValueSrc = current.get("valueSrc", new immutable__WEBPACK_IMPORTED_MODULE_4___default.a.List());
  var currentValueType = current.get("valueType", new immutable__WEBPACK_IMPORTED_MODULE_4___default.a.List()); //const isValidatingTree = (changedField === null);

  var _config$settings = config.settings,
      convertableWidgets = _config$settings.convertableWidgets,
      clearValueOnChangeField = _config$settings.clearValueOnChangeField,
      clearValueOnChangeOp = _config$settings.clearValueOnChangeOp,
      showErrorMessage = _config$settings.showErrorMessage; //const currentOperatorConfig = getOperatorConfig(oldConfig, currentOperator, currentField);

  var newOperatorConfig = Object(_configUtils__WEBPACK_IMPORTED_MODULE_0__[/* getOperatorConfig */ "j"])(config, newOperator, newField); //const currentOperatorCardinality = currentOperator ? defaultValue(currentOperatorConfig.cardinality, 1) : null;

  var operatorCardinality = newOperator ? Object(_utils_stuff__WEBPACK_IMPORTED_MODULE_1__[/* defaultValue */ "c"])(newOperatorConfig.cardinality, 1) : null;
  var currentFieldConfig = Object(_configUtils__WEBPACK_IMPORTED_MODULE_0__[/* getFieldConfig */ "b"])(currentField, oldConfig);
  var newFieldConfig = Object(_configUtils__WEBPACK_IMPORTED_MODULE_0__[/* getFieldConfig */ "b"])(newField, config);
  var canReuseValue = currentField && currentOperator && newOperator && (!changedField || changedField == "field" && !clearValueOnChangeField || changedField == "operator" && !clearValueOnChangeOp) && currentFieldConfig && newFieldConfig && currentFieldConfig.type == newFieldConfig.type; // compare old & new widgets

  for (var i = 0; i < operatorCardinality; i++) {
    var vs = currentValueSrc.get(i) || null;
    var currentWidget = Object(_configUtils__WEBPACK_IMPORTED_MODULE_0__[/* getWidgetForFieldOp */ "n"])(oldConfig, currentField, currentOperator, vs);
    var newWidget = Object(_configUtils__WEBPACK_IMPORTED_MODULE_0__[/* getWidgetForFieldOp */ "n"])(config, newField, newOperator, vs); // need to also check value widgets if we changed operator and current value source was 'field'
    // cause for select type op '=' requires single value and op 'in' requires array value

    var currentValueWidget = vs == "value" ? currentWidget : Object(_configUtils__WEBPACK_IMPORTED_MODULE_0__[/* getWidgetForFieldOp */ "n"])(oldConfig, currentField, currentOperator, "value");
    var newValueWidget = vs == "value" ? newWidget : Object(_configUtils__WEBPACK_IMPORTED_MODULE_0__[/* getWidgetForFieldOp */ "n"])(config, newField, newOperator, "value");
    var canReuseWidget = newValueWidget == currentValueWidget || (convertableWidgets[currentValueWidget] || []).includes(newValueWidget);
    if (!canReuseWidget) canReuseValue = false;
  }

  if (currentOperator != newOperator && [currentOperator, newOperator].includes("proximity")) canReuseValue = false;
  var firstWidgetConfig = Object(_configUtils__WEBPACK_IMPORTED_MODULE_0__[/* getFieldWidgetConfig */ "e"])(config, newField, newOperator, null, currentValueSrc.first());
  var valueSources = Object(_configUtils__WEBPACK_IMPORTED_MODULE_0__[/* getValueSourcesForFieldOp */ "m"])(config, newField, newOperator);
  var valueFixes = {};
  var valueErrors = Array.from({
    length: operatorCardinality
  }, function () {
    return null;
  });

  if (canReuseValue) {
    var _loop = function _loop(_i2) {
      var v = currentValue.get(_i2);
      var vType = currentValueType.get(_i2) || null;
      var vSrc = currentValueSrc.get(_i2) || null;
      var isValidSrc = valueSources.find(function (v) {
        return v == vSrc;
      }) != null;
      if (!isValidSrc && _i2 > 0 && vSrc == null) isValidSrc = true; // make exception for range widgets (when changing op from '==' to 'between')

      var isEndValue = !canFix;

      var _validateValue3 = validateValue(config, newField, newField, newOperator, v, vType, vSrc, canFix, isEndValue),
          _validateValue4 = _slicedToArray(_validateValue3, 2),
          validateError = _validateValue4[0],
          fixedValue = _validateValue4[1];

      var isValid = !validateError;

      if (!isValid && showErrorMessage && changedField != "field") {
        // allow bad value
        // but not on field change - in that case just drop bad value that can't be reused
        // ? maybe we should also drop bad value on op change?
        valueErrors[_i2] = validateError;
      } else if (!isValidSrc || !isValid) {
        canReuseValue = false;
        return "break";
      } else if (canFix && fixedValue !== v) {
        valueFixes[_i2] = fixedValue;
      }
    };

    for (var _i2 = 0; _i2 < operatorCardinality; _i2++) {
      var _ret = _loop(_i2);

      if (_ret === "break") break;
    }
  }

  var newValue = null,
      newValueSrc = null,
      newValueType = null,
      newValueError = null;
  newValue = new immutable__WEBPACK_IMPORTED_MODULE_4___default.a.List(Array.from({
    length: operatorCardinality
  }, function (_ignore, i) {
    var v = undefined;

    if (canReuseValue) {
      if (i < currentValue.size) {
        v = currentValue.get(i);

        if (valueFixes[i] !== undefined) {
          v = valueFixes[i];
        }
      }
    } else if (operatorCardinality == 1 && (firstWidgetConfig || newFieldConfig)) {
      if (newFieldConfig.defaultValue !== undefined) v = newFieldConfig.defaultValue;else if (newFieldConfig.fieldSettings && newFieldConfig.fieldSettings.defaultValue !== undefined) v = newFieldConfig.fieldSettings.defaultValue;else if (firstWidgetConfig.defaultValue !== undefined) v = firstWidgetConfig.defaultValue;
    }

    return v;
  }));
  newValueSrc = new immutable__WEBPACK_IMPORTED_MODULE_4___default.a.List(Array.from({
    length: operatorCardinality
  }, function (_ignore, i) {
    var vs = null;

    if (canReuseValue) {
      if (i < currentValueSrc.size) vs = currentValueSrc.get(i);
    } else if (valueSources.length == 1) {
      vs = valueSources[0];
    } else if (valueSources.length > 1) {
      vs = valueSources[0];
    }

    return vs;
  }));

  if (showErrorMessage) {
    if (newOperatorConfig && newOperatorConfig.validateValues && newValueSrc.toJS().filter(function (vs) {
      return vs == "value" || vs == null;
    }).length == operatorCardinality) {
      // last element in `valueError` list is for range validation error
      var jsValues = firstWidgetConfig && firstWidgetConfig.toJS ? newValue.toJS().map(function (v) {
        return firstWidgetConfig.toJS(v, firstWidgetConfig);
      }) : newValue.toJS();
      var rangeValidateError = newOperatorConfig.validateValues(jsValues);

      if (showErrorMessage) {
        valueErrors.push(rangeValidateError);
      }
    }

    newValueError = new immutable__WEBPACK_IMPORTED_MODULE_4___default.a.List(valueErrors);
  }

  newValueType = new immutable__WEBPACK_IMPORTED_MODULE_4___default.a.List(Array.from({
    length: operatorCardinality
  }, function (_ignore, i) {
    var vt = null;

    if (canReuseValue) {
      if (i < currentValueType.size) vt = currentValueType.get(i);
    } else if (operatorCardinality == 1 && firstWidgetConfig && firstWidgetConfig.type !== undefined) {
      vt = firstWidgetConfig.type;
    }

    return vt;
  }));
  return {
    canReuseValue: canReuseValue,
    newValue: newValue,
    newValueSrc: newValueSrc,
    newValueType: newValueType,
    newValueError: newValueError
  };
};

/***/ }),
/* 15 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return settings; });
/* harmony import */ var _components_widgets__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(0);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);


var VanillaFieldSelect = _components_widgets__WEBPACK_IMPORTED_MODULE_0__["VanillaFieldSelect"],
    VanillaConjs = _components_widgets__WEBPACK_IMPORTED_MODULE_0__["VanillaConjs"],
    VanillaButton = _components_widgets__WEBPACK_IMPORTED_MODULE_0__["VanillaButton"],
    VanillaButtonGroup = _components_widgets__WEBPACK_IMPORTED_MODULE_0__["VanillaButtonGroup"],
    VanillaProvider = _components_widgets__WEBPACK_IMPORTED_MODULE_0__["VanillaProvider"],
    VanillaValueSources = _components_widgets__WEBPACK_IMPORTED_MODULE_0__["VanillaValueSources"],
    vanillaConfirm = _components_widgets__WEBPACK_IMPORTED_MODULE_0__["vanillaConfirm"];
var settings = {
  formatField: function formatField(field, parts, label2, fieldDefinition, config, isForDisplay) {
    if (isForDisplay) return label2;else return field;
  },
  renderField: function renderField(props) {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(VanillaFieldSelect, props);
  },
  renderOperator: function renderOperator(props) {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(VanillaFieldSelect, props);
  },
  renderFunc: function renderFunc(props) {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(VanillaFieldSelect, props);
  },
  renderConjs: function renderConjs(props) {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(VanillaConjs, props);
  },
  renderButton: function renderButton(props) {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(VanillaButton, props);
  },
  renderButtonGroup: function renderButtonGroup(props) {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(VanillaButtonGroup, props);
  },
  renderProvider: function renderProvider(props) {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(VanillaProvider, props);
  },
  renderValueSources: function renderValueSources(props) {
    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default.a.createElement(VanillaValueSources, props);
  },
  renderConfirm: vanillaConfirm,
  valueSourcesInfo: {
    value: {}
  },
  fieldSeparator: ".",
  fieldSeparatorDisplay: ".",
  renderSize: "small",
  maxLabelsLength: 100,
  hideConjForOne: true,
  canReorder: true,
  canRegroup: true,
  showNot: true,
  canShortMongoQuery: true,
  groupActionsPosition: "topRight",
  // oneOf [topLeft, topCenter, topRight, bottomLeft, bottomCenter, bottomRight]
  setOpOnChangeField: ["keep", "default"],
  // 'default' (default if present), 'keep' (keep prev from last field), 'first', 'none'
  convertableWidgets: {
    "number": ["slider", "rangeslider"],
    "slider": ["number", "rangeslider"],
    "rangeslider": ["number", "slider"]
  },
  // localization
  locale: {
    moment: "en"
  },
  valueLabel: "Value",
  valuePlaceholder: "Value",
  fieldLabel: "Field",
  operatorLabel: "Operator",
  funcLabel: "Function",
  fieldPlaceholder: "Select field",
  funcPlaceholder: "Select function",
  operatorPlaceholder: "Select operator",
  deleteLabel: null,
  addGroupLabel: "Add group",
  addRuleLabel: "Add rule",
  delGroupLabel: "",
  notLabel: "Not",
  valueSourcesPopupTitle: "Select value source",
  removeRuleConfirmOptions: null,
  removeGroupConfirmOptions: null,
  useGroupsAsArrays: true,
  defaultGroupConjunction: "AND"
};

/***/ }),
/* 16 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return liteShouldComponentUpdate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return pureShouldComponentUpdate; });
/* harmony import */ var _stuff__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);

var liteShouldComponentUpdate = function liteShouldComponentUpdate(self, config) {
  return function (nextProps, nextState) {
    var prevProps = self.props;
    var prevState = self.state;
    var should = nextProps != prevProps || nextState != prevState;

    if (should) {
      if (prevState == nextState && prevProps != nextProps) {
        var chs = [];

        for (var k in nextProps) {
          var changed = nextProps[k] != prevProps[k];

          if (changed) {
            if (config[k] == "ignore") changed = false;else if (config[k] == "shallow_deep") changed = !Object(_stuff__WEBPACK_IMPORTED_MODULE_0__[/* shallowEqual */ "k"])(nextProps[k], prevProps[k], true);else if (config[k] == "shallow") changed = !Object(_stuff__WEBPACK_IMPORTED_MODULE_0__[/* shallowEqual */ "k"])(nextProps[k], prevProps[k]);else if (typeof config[k] == "function") changed = config[k](nextProps[k], prevProps[k], nextState);
          }

          if (changed) chs.push(k);
        }

        if (!chs.length) should = false;
      }
    }

    return should;
  };
};
var pureShouldComponentUpdate = function pureShouldComponentUpdate(self) {
  return function (nextProps, nextState) {
    return !Object(_stuff__WEBPACK_IMPORTED_MODULE_0__[/* shallowEqual */ "k"])(self.props, nextProps) || !Object(_stuff__WEBPACK_IMPORTED_MODULE_0__[/* shallowEqual */ "k"])(self.state, nextState);
  };
};

/***/ }),
/* 17 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__17__;

/***/ }),
/* 18 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__18__;

/***/ }),
/* 19 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "d", function() { return /* reexport */ tree_namespaceObject; });
__webpack_require__.d(__webpack_exports__, "b", function() { return /* reexport */ group_namespaceObject; });
__webpack_require__.d(__webpack_exports__, "c", function() { return /* reexport */ rule_namespaceObject; });
__webpack_require__.d(__webpack_exports__, "a", function() { return /* reexport */ drag_namespaceObject; });

// NAMESPACE OBJECT: ./modules/actions/tree.js
var tree_namespaceObject = {};
__webpack_require__.r(tree_namespaceObject);
__webpack_require__.d(tree_namespaceObject, "setTree", function() { return tree_setTree; });
__webpack_require__.d(tree_namespaceObject, "addRule", function() { return tree_addRule; });
__webpack_require__.d(tree_namespaceObject, "removeRule", function() { return tree_removeRule; });
__webpack_require__.d(tree_namespaceObject, "addGroup", function() { return tree_addGroup; });
__webpack_require__.d(tree_namespaceObject, "removeGroup", function() { return tree_removeGroup; });
__webpack_require__.d(tree_namespaceObject, "moveItem", function() { return tree_moveItem; });

// NAMESPACE OBJECT: ./modules/actions/group.js
var group_namespaceObject = {};
__webpack_require__.r(group_namespaceObject);
__webpack_require__.d(group_namespaceObject, "setConjunction", function() { return group_setConjunction; });
__webpack_require__.d(group_namespaceObject, "setNot", function() { return group_setNot; });

// NAMESPACE OBJECT: ./modules/actions/rule.js
var rule_namespaceObject = {};
__webpack_require__.r(rule_namespaceObject);
__webpack_require__.d(rule_namespaceObject, "setField", function() { return rule_setField; });
__webpack_require__.d(rule_namespaceObject, "setOperator", function() { return rule_setOperator; });
__webpack_require__.d(rule_namespaceObject, "setValue", function() { return rule_setValue; });
__webpack_require__.d(rule_namespaceObject, "setValueSrc", function() { return rule_setValueSrc; });
__webpack_require__.d(rule_namespaceObject, "setOperatorOption", function() { return rule_setOperatorOption; });

// NAMESPACE OBJECT: ./modules/actions/drag.js
var drag_namespaceObject = {};
__webpack_require__.r(drag_namespaceObject);
__webpack_require__.d(drag_namespaceObject, "setDragProgress", function() { return drag_setDragProgress; });
__webpack_require__.d(drag_namespaceObject, "setDragStart", function() { return drag_setDragStart; });
__webpack_require__.d(drag_namespaceObject, "setDragEnd", function() { return drag_setDragEnd; });

// EXTERNAL MODULE: ./modules/utils/uuid.js
var uuid = __webpack_require__(8);

// EXTERNAL MODULE: ./modules/utils/defaultUtils.js
var defaultUtils = __webpack_require__(7);

// EXTERNAL MODULE: ./modules/constants.js
var constants = __webpack_require__(6);

// EXTERNAL MODULE: external "Immutable"
var external_Immutable_ = __webpack_require__(5);
var external_Immutable_default = /*#__PURE__*/__webpack_require__.n(external_Immutable_);

// CONCATENATED MODULE: ./modules/actions/tree.js




/**
 * @param {object} config
 * @param {Immutable.Map} tree
 */

var tree_setTree = function setTree(config, tree) {
  return {
    type: constants["s" /* SET_TREE */],
    tree: tree
  };
};
/**
 * @param {object} config
 * @param {Immutable.List} path
 * @param {Immutable.Map} properties
 */

var tree_addRule = function addRule(config, path, properties) {
  return {
    type: constants["c" /* ADD_RULE */],
    path: path,
    id: Object(uuid["a" /* default */])(),
    properties: Object(defaultUtils["g" /* defaultRuleProperties */])(config).merge(properties || {}),
    config: config
  };
};
/**
 * @param {object} config
 * @param {Immutable.List} path
 */

var tree_removeRule = function removeRule(config, path) {
  return {
    type: constants["j" /* REMOVE_RULE */],
    path: path,
    config: config
  };
};
/**
 * @param {object} config
 * @param {Immutable.List} path
 * @param {Immutable.Map} properties
 */

var tree_addGroup = function addGroup(config, path, properties) {
  return {
    type: constants["b" /* ADD_NEW_GROUP */],
    path: path,
    properties: Object(defaultUtils["c" /* defaultGroupProperties */])(config).merge(properties || {}),
    config: config
  };
};
/**
 * @param {object} config
 * @param {Immutable.List} path
 */

var tree_removeGroup = function removeGroup(config, path) {
  return {
    type: constants["i" /* REMOVE_GROUP */],
    path: path,
    config: config
  };
};
/**
 * @param {object} config
 * @param {Array} fromPath
 * @param {Array} toPath
 * @param {String} placement, see constants PLACEMENT_*
 */

var tree_moveItem = function moveItem(config, fromPath, toPath, placement) {
  return {
    type: constants["d" /* MOVE_ITEM */],
    fromPath: new external_Immutable_default.a.List(fromPath),
    toPath: new external_Immutable_default.a.List(toPath),
    placement: placement,
    config: config
  };
};
// CONCATENATED MODULE: ./modules/actions/group.js

/**
 * @param {object} config
 * @param {Immutable.List} path
 * @param {string} conjunction
 */

var group_setConjunction = function setConjunction(config, path, conjunction) {
  return {
    type: constants["k" /* SET_CONJUNCTION */],
    path: path,
    conjunction: conjunction
  };
};
/**
 * @param {object} config
 * @param {Immutable.List} path
 * @param {bool} not
 */

var group_setNot = function setNot(config, path, not) {
  return {
    type: constants["p" /* SET_NOT */],
    path: path,
    not: not
  };
};
// CONCATENATED MODULE: ./modules/actions/rule.js

/**
 * @param {object} config
 * @param {Immutable.List} path
 * @param {string} field
 */

var rule_setField = function setField(config, path, field) {
  return {
    type: constants["o" /* SET_FIELD */],
    path: path,
    field: field,
    config: config
  };
};
/**
 * @param {object} config
 * @param {Immutable.List} path
 * @param {string} operator
 */

var rule_setOperator = function setOperator(config, path, operator) {
  return {
    type: constants["q" /* SET_OPERATOR */],
    path: path,
    operator: operator,
    config: config
  };
};
/**
 * @param {object} config
 * @param {Immutable.List} path
 * @param {integer} delta
 * @param {*} value
 * @param {string} valueType
 * @param {boolean} __isInternal
 */

var rule_setValue = function setValue(config, path, delta, value, valueType, __isInternal) {
  return {
    type: constants["t" /* SET_VALUE */],
    path: path,
    delta: delta,
    value: value,
    valueType: valueType,
    config: config,
    __isInternal: __isInternal
  };
};
/**
 * @param {object} config
 * @param {Immutable.List} path
 * @param {integer} delta
 * @param {*} srcKey
 */

var rule_setValueSrc = function setValueSrc(config, path, delta, srcKey) {
  return {
    type: constants["u" /* SET_VALUE_SRC */],
    path: path,
    delta: delta,
    srcKey: srcKey,
    config: config
  };
};
/**
 * @param {object} config
 * @param {Immutable.List} path
 * @param {string} name
 * @param {*} value
 */

var rule_setOperatorOption = function setOperatorOption(config, path, name, value) {
  return {
    type: constants["r" /* SET_OPERATOR_OPTION */],
    path: path,
    name: name,
    value: value,
    config: config
  };
};
// CONCATENATED MODULE: ./modules/actions/drag.js

/**
 * @param {Object} mousePos
 * @param {Object} dragging
 */

var drag_setDragProgress = function setDragProgress(mousePos, dragging) {
  return {
    type: constants["m" /* SET_DRAG_PROGRESS */],
    mousePos: mousePos,
    dragging: dragging
  };
};
/**
 * @param {Object} dragStart
 * @param {Object} dragging
 * @param {Object} mousePos
 */

var drag_setDragStart = function setDragStart(dragStart, dragging, mousePos) {
  return {
    type: constants["n" /* SET_DRAG_START */],
    dragStart: dragStart,
    dragging: dragging,
    mousePos: mousePos
  };
};
/**
 *
 */

var drag_setDragEnd = function setDragEnd() {
  return {
    type: constants["l" /* SET_DRAG_END */]
  };
};
// CONCATENATED MODULE: ./modules/actions/index.js






/***/ }),
/* 20 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__20__;

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

var clone = (function() {
'use strict';

function _instanceof(obj, type) {
  return type != null && obj instanceof type;
}

var nativeMap;
try {
  nativeMap = Map;
} catch(_) {
  // maybe a reference error because no `Map`. Give it a dummy value that no
  // value will ever be an instanceof.
  nativeMap = function() {};
}

var nativeSet;
try {
  nativeSet = Set;
} catch(_) {
  nativeSet = function() {};
}

var nativePromise;
try {
  nativePromise = Promise;
} catch(_) {
  nativePromise = function() {};
}

/**
 * Clones (copies) an Object using deep copying.
 *
 * This function supports circular references by default, but if you are certain
 * there are no circular references in your object, you can save some CPU time
 * by calling clone(obj, false).
 *
 * Caution: if `circular` is false and `parent` contains circular references,
 * your program may enter an infinite loop and crash.
 *
 * @param `parent` - the object to be cloned
 * @param `circular` - set to true if the object to be cloned may contain
 *    circular references. (optional - true by default)
 * @param `depth` - set to a number if the object is only to be cloned to
 *    a particular depth. (optional - defaults to Infinity)
 * @param `prototype` - sets the prototype to be used when cloning an object.
 *    (optional - defaults to parent prototype).
 * @param `includeNonEnumerable` - set to true if the non-enumerable properties
 *    should be cloned as well. Non-enumerable properties on the prototype
 *    chain will be ignored. (optional - false by default)
*/
function clone(parent, circular, depth, prototype, includeNonEnumerable) {
  if (typeof circular === 'object') {
    depth = circular.depth;
    prototype = circular.prototype;
    includeNonEnumerable = circular.includeNonEnumerable;
    circular = circular.circular;
  }
  // maintain two arrays for circular references, where corresponding parents
  // and children have the same index
  var allParents = [];
  var allChildren = [];

  var useBuffer = typeof Buffer != 'undefined';

  if (typeof circular == 'undefined')
    circular = true;

  if (typeof depth == 'undefined')
    depth = Infinity;

  // recurse this function so we don't reset allParents and allChildren
  function _clone(parent, depth) {
    // cloning null always returns null
    if (parent === null)
      return null;

    if (depth === 0)
      return parent;

    var child;
    var proto;
    if (typeof parent != 'object') {
      return parent;
    }

    if (_instanceof(parent, nativeMap)) {
      child = new nativeMap();
    } else if (_instanceof(parent, nativeSet)) {
      child = new nativeSet();
    } else if (_instanceof(parent, nativePromise)) {
      child = new nativePromise(function (resolve, reject) {
        parent.then(function(value) {
          resolve(_clone(value, depth - 1));
        }, function(err) {
          reject(_clone(err, depth - 1));
        });
      });
    } else if (clone.__isArray(parent)) {
      child = [];
    } else if (clone.__isRegExp(parent)) {
      child = new RegExp(parent.source, __getRegExpFlags(parent));
      if (parent.lastIndex) child.lastIndex = parent.lastIndex;
    } else if (clone.__isDate(parent)) {
      child = new Date(parent.getTime());
    } else if (useBuffer && Buffer.isBuffer(parent)) {
      if (Buffer.allocUnsafe) {
        // Node.js >= 4.5.0
        child = Buffer.allocUnsafe(parent.length);
      } else {
        // Older Node.js versions
        child = new Buffer(parent.length);
      }
      parent.copy(child);
      return child;
    } else if (_instanceof(parent, Error)) {
      child = Object.create(parent);
    } else {
      if (typeof prototype == 'undefined') {
        proto = Object.getPrototypeOf(parent);
        child = Object.create(proto);
      }
      else {
        child = Object.create(prototype);
        proto = prototype;
      }
    }

    if (circular) {
      var index = allParents.indexOf(parent);

      if (index != -1) {
        return allChildren[index];
      }
      allParents.push(parent);
      allChildren.push(child);
    }

    if (_instanceof(parent, nativeMap)) {
      parent.forEach(function(value, key) {
        var keyChild = _clone(key, depth - 1);
        var valueChild = _clone(value, depth - 1);
        child.set(keyChild, valueChild);
      });
    }
    if (_instanceof(parent, nativeSet)) {
      parent.forEach(function(value) {
        var entryChild = _clone(value, depth - 1);
        child.add(entryChild);
      });
    }

    for (var i in parent) {
      var attrs;
      if (proto) {
        attrs = Object.getOwnPropertyDescriptor(proto, i);
      }

      if (attrs && attrs.set == null) {
        continue;
      }
      child[i] = _clone(parent[i], depth - 1);
    }

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(parent);
      for (var i = 0; i < symbols.length; i++) {
        // Don't need to worry about cloning a symbol because it is a primitive,
        // like a number or string.
        var symbol = symbols[i];
        var descriptor = Object.getOwnPropertyDescriptor(parent, symbol);
        if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {
          continue;
        }
        child[symbol] = _clone(parent[symbol], depth - 1);
        if (!descriptor.enumerable) {
          Object.defineProperty(child, symbol, {
            enumerable: false
          });
        }
      }
    }

    if (includeNonEnumerable) {
      var allPropertyNames = Object.getOwnPropertyNames(parent);
      for (var i = 0; i < allPropertyNames.length; i++) {
        var propertyName = allPropertyNames[i];
        var descriptor = Object.getOwnPropertyDescriptor(parent, propertyName);
        if (descriptor && descriptor.enumerable) {
          continue;
        }
        child[propertyName] = _clone(parent[propertyName], depth - 1);
        Object.defineProperty(child, propertyName, {
          enumerable: false
        });
      }
    }

    return child;
  }

  return _clone(parent, depth);
}

/**
 * Simple flat clone using prototype, accepts only objects, usefull for property
 * override on FLAT configuration object (no nested props).
 *
 * USE WITH CAUTION! This may not behave as you wish if you do not know how this
 * works.
 */
clone.clonePrototype = function clonePrototype(parent) {
  if (parent === null)
    return null;

  var c = function () {};
  c.prototype = parent;
  return new c();
};

// private utility functions

function __objToStr(o) {
  return Object.prototype.toString.call(o);
}
clone.__objToStr = __objToStr;

function __isDate(o) {
  return typeof o === 'object' && __objToStr(o) === '[object Date]';
}
clone.__isDate = __isDate;

function __isArray(o) {
  return typeof o === 'object' && __objToStr(o) === '[object Array]';
}
clone.__isArray = __isArray;

function __isRegExp(o) {
  return typeof o === 'object' && __objToStr(o) === '[object RegExp]';
}
clone.__isRegExp = __isRegExp;

function __getRegExpFlags(re) {
  var flags = '';
  if (re.global) flags += 'g';
  if (re.ignoreCase) flags += 'i';
  if (re.multiline) flags += 'm';
  return flags;
}
clone.__getRegExpFlags = __getRegExpFlags;

return clone;
})();

if ( true && module.exports) {
  module.exports = clone;
}


/***/ }),
/* 22 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__22__;

/***/ }),
/* 23 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__23__;

/***/ }),
/* 24 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__24__;

/***/ }),
/* 25 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ Widget_Widget; });

// EXTERNAL MODULE: external "React"
var external_React_ = __webpack_require__(0);
var external_React_default = /*#__PURE__*/__webpack_require__.n(external_React_);

// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(1);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);

// EXTERNAL MODULE: external "lodash/range"
var range_ = __webpack_require__(24);
var range_default = /*#__PURE__*/__webpack_require__.n(range_);

// EXTERNAL MODULE: ./modules/utils/configUtils.js
var configUtils = __webpack_require__(2);

// EXTERNAL MODULE: ./modules/utils/stuff.js
var stuff = __webpack_require__(3);

// EXTERNAL MODULE: external "lodash/pick"
var pick_ = __webpack_require__(12);
var pick_default = /*#__PURE__*/__webpack_require__.n(pick_);

// EXTERNAL MODULE: external "Immutable"
var external_Immutable_ = __webpack_require__(5);
var external_Immutable_default = /*#__PURE__*/__webpack_require__.n(external_Immutable_);

// CONCATENATED MODULE: ./modules/components/containers/WidgetContainer.jsx
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }








var funcArgDummyOpDef = {
  cardinality: 1
};
/* harmony default export */ var containers_WidgetContainer = (function (Widget) {
  var _class, _temp;

  return _temp = _class = /*#__PURE__*/function (_PureComponent) {
    _inherits(WidgetContainer, _PureComponent);

    var _super = _createSuper(WidgetContainer);

    function WidgetContainer(props) {
      var _this;

      _classCallCheck(this, WidgetContainer);

      _this = _super.call(this, props);

      _this._setValue = function (isSpecialRange, delta, widgetType, value, __isInternal) {
        if (isSpecialRange && Array.isArray(value)) {
          var oldRange = [_this.props.value.get(0), _this.props.value.get(1)];
          if (oldRange[0] != value[0]) _this.props.setValue(0, value[0], widgetType, __isInternal);
          if (oldRange[1] != value[1]) _this.props.setValue(1, value[1], widgetType, __isInternal);
        } else {
          _this.props.setValue(delta, value, widgetType, __isInternal);
        }
      };

      _this._onChangeValueSrc = function (delta, srcKey) {
        _this.props.setValueSrc(delta, srcKey);
      };

      Object(stuff["m" /* useOnPropsChanged */])(_assertThisInitialized(_this));

      _this.onPropsChanged(props);

      return _this;
    }

    _createClass(WidgetContainer, [{
      key: "onPropsChanged",
      value: function onPropsChanged(nextProps) {
        var prevProps = this.props;
        var keysForMeta = ["config", "field", "fieldFunc", "fieldArg", "leftField", "operator", "valueSrc", "isFuncArg"];
        var needUpdateMeta = !this.meta || keysForMeta.map(function (k) {
          return nextProps[k] !== prevProps[k] //tip: for isFuncArg we need to wrap value in Imm list
          || k == "isFuncArg" && nextProps["isFuncArg"] && nextProps["value"] !== prevProps["value"];
        }).filter(function (ch) {
          return ch;
        }).length > 0;

        if (needUpdateMeta) {
          this.meta = this.getMeta(nextProps);
        }
      }
    }, {
      key: "getMeta",
      value: function getMeta(_ref) {
        var _this2 = this;

        var config = _ref.config,
            simpleField = _ref.field,
            fieldFunc = _ref.fieldFunc,
            fieldArg = _ref.fieldArg,
            operator = _ref.operator,
            valueSrcs = _ref.valueSrc,
            values = _ref.value,
            isFuncArg = _ref.isFuncArg,
            leftField = _ref.leftField;
        var field = isFuncArg ? {
          func: fieldFunc,
          arg: fieldArg
        } : simpleField;
        var _valueSrcs = valueSrcs;
        var _values = values;

        if (isFuncArg) {
          _valueSrcs = external_Immutable_default.a.List([valueSrcs]);
          _values = external_Immutable_default.a.List([values]);
        }

        var fieldDefinition = Object(configUtils["b" /* getFieldConfig */])(field, config);
        var defaultWidget = Object(configUtils["n" /* getWidgetForFieldOp */])(config, field, operator);

        var _widgets = Object(configUtils["o" /* getWidgetsForFieldOp */])(config, field, operator);

        var operatorDefinition = isFuncArg ? funcArgDummyOpDef : Object(configUtils["j" /* getOperatorConfig */])(config, operator, field);

        if (fieldDefinition == null || operatorDefinition == null) {
          return null;
        }

        var isSpecialRange = operatorDefinition.isSpecialRange;
        var isSpecialRangeForSrcField = isSpecialRange && (_valueSrcs.get(0) == "field" || _valueSrcs.get(1) == "field");
        var isTrueSpecialRange = isSpecialRange && !isSpecialRangeForSrcField;
        var cardinality = isTrueSpecialRange ? 1 : Object(stuff["c" /* defaultValue */])(operatorDefinition.cardinality, 1);

        if (cardinality === 0) {
          return null;
        }

        var valueSources = Object(configUtils["m" /* getValueSourcesForFieldOp */])(config, field, operator, fieldDefinition, isFuncArg ? leftField : null);
        var widgets = range_default()(0, cardinality).map(function (delta) {
          var valueSrc = _valueSrcs.get(delta) || null;
          var widget = Object(configUtils["n" /* getWidgetForFieldOp */])(config, field, operator, valueSrc);
          var widgetDefinition = Object(configUtils["e" /* getFieldWidgetConfig */])(config, field, operator, widget, valueSrc);

          if (isSpecialRangeForSrcField) {
            widget = widgetDefinition.singleWidget;
            widgetDefinition = Object(configUtils["e" /* getFieldWidgetConfig */])(config, field, operator, widget, valueSrc);
          }

          var widgetType = widgetDefinition.type;
          var valueLabel = Object(configUtils["l" /* getValueLabel */])(config, field, operator, delta, valueSrc, isTrueSpecialRange);
          var widgetValueLabel = Object(configUtils["l" /* getValueLabel */])(config, field, operator, delta, null, isTrueSpecialRange);
          var sepText = operatorDefinition.textSeparators ? operatorDefinition.textSeparators[delta] : null;

          var setValueSrcHandler = _this2._onChangeValueSrc.bind(_this2, delta);

          var valueLabels = null;
          var textSeparators = null;

          if (isSpecialRange) {
            valueLabels = [Object(configUtils["l" /* getValueLabel */])(config, field, operator, 0), Object(configUtils["l" /* getValueLabel */])(config, field, operator, 1)];
            valueLabels = {
              placeholder: [valueLabels[0].placeholder, valueLabels[1].placeholder],
              label: [valueLabels[0].label, valueLabels[1].label]
            };
            textSeparators = operatorDefinition.textSeparators;
          }

          var setValueHandler = _this2._setValue.bind(_this2, isSpecialRange, delta, widgetType);

          return {
            valueSrc: valueSrc,
            valueLabel: valueLabel,
            widget: widget,
            sepText: sepText,
            setValueSrcHandler: setValueSrcHandler,
            widgetDefinition: widgetDefinition,
            widgetValueLabel: widgetValueLabel,
            valueLabels: valueLabels,
            textSeparators: textSeparators,
            setValueHandler: setValueHandler
          };
        });
        return {
          defaultWidget: defaultWidget,
          fieldDefinition: fieldDefinition,
          operatorDefinition: operatorDefinition,
          isSpecialRange: isTrueSpecialRange,
          cardinality: cardinality,
          valueSources: valueSources,
          widgets: widgets,
          _values: _values,
          //correct for isFuncArg
          _field: field //correct for isFuncArg

        };
      }
    }, {
      key: "render",
      value: function render() {
        var _this$props = this.props,
            config = _this$props.config,
            isFuncArg = _this$props.isFuncArg,
            leftField = _this$props.leftField,
            operator = _this$props.operator,
            values = _this$props.value,
            valueError = _this$props.valueError,
            readonly = _this$props.readonly;
        var meta = this.meta;
        if (!meta) return null;
        var defaultWidget = meta.defaultWidget,
            cardinality = meta.cardinality,
            valueSources = meta.valueSources,
            widgets = meta.widgets,
            _values = meta._values,
            _field = meta._field;
        var value = isFuncArg ? _values : values;
        var field = isFuncArg ? leftField : _field;
        var settings = config.settings;
        var valueSourcesInfo = settings.valueSourcesInfo,
            ValueSources = settings.renderValueSources;
        var valueSourcesOptions = valueSources.map(function (srcKey) {
          return [srcKey, {
            label: valueSourcesInfo[srcKey].label
          }];
        });
        return /*#__PURE__*/external_React_default.a.createElement(Widget, {
          name: defaultWidget,
          config: config
        }, range_default()(0, cardinality).map(function (delta) {
          var _widgets$delta = widgets[delta],
              valueSrc = _widgets$delta.valueSrc,
              valueLabel = _widgets$delta.valueLabel,
              sepText = _widgets$delta.sepText,
              setValueSrcHandler = _widgets$delta.setValueSrcHandler; //if (!valueSrc && valueSources.length == 1) {
          //    this.props.setValueSrc(delta, valueSources[0]);
          //}

          var sepLabel = settings.showLabels ? /*#__PURE__*/external_React_default.a.createElement("label", {
            className: "rule--label"
          }, "\xA0") : null;
          var sourceLabel = settings.showLabels ? /*#__PURE__*/external_React_default.a.createElement("label", {
            className: "rule--label"
          }, "\xA0") : null;
          var widgetLabel = settings.showLabels ? /*#__PURE__*/external_React_default.a.createElement("label", {
            className: "rule--label"
          }, valueLabel.label) : null;
          var sep = sepText && /*#__PURE__*/external_React_default.a.createElement("div", {
            key: "widget-separators-" + delta,
            className: "widget--sep"
          }, sepLabel, /*#__PURE__*/external_React_default.a.createElement("span", null, sepText));
          var sources = valueSources.length > 1 && !readonly && /*#__PURE__*/external_React_default.a.createElement("div", {
            key: "valuesrc-" + field + "-" + delta,
            className: "widget--valuesrc"
          }, sourceLabel, /*#__PURE__*/external_React_default.a.createElement(ValueSources, {
            key: "valuesrc-" + delta,
            delta: delta,
            valueSources: valueSourcesOptions,
            valueSrc: valueSrc,
            config: config,
            field: field,
            operator: operator,
            setValueSrc: setValueSrcHandler,
            readonly: readonly,
            title: settings.valueSourcesPopupTitle
          }));
          var widgetCmp = /*#__PURE__*/external_React_default.a.createElement("div", {
            key: "widget-" + field + "-" + delta,
            className: "widget--widget"
          }, valueSrc == "func" ? null : widgetLabel, /*#__PURE__*/external_React_default.a.createElement(WidgetContainer_WidgetFactory, _extends({
            valueSrc: valueSrc,
            delta: delta,
            value: value,
            valueError: valueError,
            isFuncArg: isFuncArg
          }, pick_default()(meta, ["isSpecialRange", "fieldDefinition"]), pick_default()(widgets[delta], ["widget", "widgetDefinition", "widgetValueLabel", "valueLabels", "textSeparators", "setValueHandler"]), {
            config: config,
            field: field,
            operator: operator,
            readonly: readonly
          })));
          return [sep, sources, widgetCmp];
        }));
      }
    }]);

    return WidgetContainer;
  }(external_React_["PureComponent"]), _class.propTypes = {
    config: prop_types_default.a.object.isRequired,
    value: prop_types_default.a.any,
    //instanceOf(Immutable.List)
    valueSrc: prop_types_default.a.any,
    //instanceOf(Immutable.List)
    valueError: prop_types_default.a.any,
    field: prop_types_default.a.string,
    operator: prop_types_default.a.string,
    readonly: prop_types_default.a.bool,
    //actions
    setValue: prop_types_default.a.func,
    setValueSrc: prop_types_default.a.func,
    // for isFuncArg
    isFuncArg: prop_types_default.a.bool,
    fieldFunc: prop_types_default.a.string,
    fieldArg: prop_types_default.a.string,
    leftField: prop_types_default.a.string
  }, _temp;
});

var WidgetContainer_WidgetFactory = function WidgetFactory(_ref2) {
  var delta = _ref2.delta,
      isFuncArg = _ref2.isFuncArg,
      valueSrc = _ref2.valueSrc,
      immValue = _ref2.value,
      immValueError = _ref2.valueError,
      isSpecialRange = _ref2.isSpecialRange,
      fieldDefinition = _ref2.fieldDefinition,
      widget = _ref2.widget,
      widgetDefinition = _ref2.widgetDefinition,
      widgetValueLabel = _ref2.widgetValueLabel,
      valueLabels = _ref2.valueLabels,
      textSeparators = _ref2.textSeparators,
      setValueHandler = _ref2.setValueHandler,
      config = _ref2.config,
      field = _ref2.field,
      operator = _ref2.operator,
      readonly = _ref2.readonly;

  var widgetFactory = widgetDefinition.factory,
      fieldWidgetProps = _objectWithoutProperties(widgetDefinition, ["factory"]);

  var isConst = isFuncArg && fieldDefinition.valueSources && fieldDefinition.valueSources.length == 1 && fieldDefinition.valueSources[0] == "const";
  var defaultValue = fieldDefinition.defaultValue;

  if (!widgetFactory) {
    return "?";
  }

  var value = isSpecialRange ? [immValue.get(0), immValue.get(1)] : immValue.get(delta);
  var valueError = immValueError && (isSpecialRange ? [immValueError.get(0), immValueError.get(1)] : immValueError.get(delta)) || null;
  if (isSpecialRange && value[0] === undefined && value[1] === undefined) value = undefined;

  var _ref3 = fieldDefinition || {},
      fieldSettings = _ref3.fieldSettings;

  var widgetProps = Object.assign({}, fieldWidgetProps, fieldSettings, {
    config: config,
    field: field,
    fieldDefinition: fieldDefinition,
    operator: operator,
    delta: delta,
    isSpecialRange: isSpecialRange,
    isFuncArg: isFuncArg,
    value: value,
    valueError: valueError,
    label: widgetValueLabel.label,
    placeholder: widgetValueLabel.placeholder,
    placeholders: valueLabels ? valueLabels.placeholder : null,
    textSeparators: textSeparators,
    setValue: setValueHandler,
    readonly: readonly
  });

  if (widget == "field") {//
  }

  if (isConst && defaultValue) {
    if (typeof defaultValue == "boolean") {
      return defaultValue ? widgetProps.labelYes || "YES" : widgetProps.labelNo || "NO";
    } else if (fieldSettings.listValues) {
      if (Array.isArray(defaultValue)) return defaultValue.map(function (v) {
        return Object(stuff["f" /* getTitleInListValues */])(fieldSettings.listValues, v) || v;
      }).join(", ");else return Object(stuff["f" /* getTitleInListValues */])(fieldSettings.listValues, defaultValue) || defaultValue;
    }

    return "" + defaultValue;
  }

  return widgetFactory(widgetProps);
};
// CONCATENATED MODULE: ./modules/components/Widget.jsx
function Widget_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Widget_typeof = function _typeof(obj) { return typeof obj; }; } else { Widget_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Widget_typeof(obj); }

var Widget_class, _class2, Widget_temp;

function Widget_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Widget_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Widget_createClass(Constructor, protoProps, staticProps) { if (protoProps) Widget_defineProperties(Constructor.prototype, protoProps); if (staticProps) Widget_defineProperties(Constructor, staticProps); return Constructor; }

function Widget_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Widget_setPrototypeOf(subClass, superClass); }

function Widget_setPrototypeOf(o, p) { Widget_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Widget_setPrototypeOf(o, p); }

function Widget_createSuper(Derived) { var hasNativeReflectConstruct = Widget_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = Widget_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = Widget_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return Widget_possibleConstructorReturn(this, result); }; }

function Widget_possibleConstructorReturn(self, call) { if (call && (Widget_typeof(call) === "object" || typeof call === "function")) { return call; } return Widget_assertThisInitialized(self); }

function Widget_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Widget_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function Widget_getPrototypeOf(o) { Widget_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Widget_getPrototypeOf(o); }

function Widget_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Widget_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function Widget_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }





var Widget_Col = function Col(_ref) {
  var children = _ref.children,
      props = Widget_objectWithoutProperties(_ref, ["children"]);

  return /*#__PURE__*/external_React_default.a.createElement("div", props, children);
};

var Widget_Widget = containers_WidgetContainer(Widget_class = (Widget_temp = _class2 = /*#__PURE__*/function (_PureComponent) {
  Widget_inherits(Widget, _PureComponent);

  var _super = Widget_createSuper(Widget);

  function Widget() {
    Widget_classCallCheck(this, Widget);

    return _super.apply(this, arguments);
  }

  Widget_createClass(Widget, [{
    key: "render",
    value: function render() {
      return /*#__PURE__*/external_React_default.a.createElement(Widget_Col, {
        className: "rule--widget rule--widget--".concat(this.props.name.toUpperCase()),
        key: "widget-col-" + this.props.name
      }, this.props.children);
    }
  }]);

  return Widget;
}(external_React_["PureComponent"]), _class2.propTypes = {
  config: prop_types_default.a.object.isRequired,
  name: prop_types_default.a.string.isRequired,
  children: prop_types_default.a.oneOfType([prop_types_default.a.array, prop_types_default.a.element])
}, Widget_temp)) || Widget_class;



/***/ }),
/* 26 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__26__;

/***/ }),
/* 27 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__27__;

/***/ }),
/* 28 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__28__;

/***/ }),
/* 29 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__29__;

/***/ }),
/* 30 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__30__;

/***/ }),
/* 31 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(18);
/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react_redux__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _utils_treeUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(6);
/* harmony import */ var clone__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(21);
/* harmony import */ var clone__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(clone__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(1);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _actions__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(19);
/* harmony import */ var _utils_renderUtils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(16);
/* harmony import */ var _utils_stuff__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(3);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }











var isDev = function isDev() {
  return process && process.env && "production" == "development";
};

/* harmony default export */ __webpack_exports__["a"] = (function (Builder) {
  var CanMoveFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

  var SortableContainer = /*#__PURE__*/function (_Component) {
    _inherits(SortableContainer, _Component);

    var _super = _createSuper(SortableContainer);

    function SortableContainer(props) {
      var _this;

      _classCallCheck(this, SortableContainer);

      _this = _super.call(this, props);

      _this.onDragStart = function (id, dom, e) {
        var treeEl = dom.closest(".query-builder");
        document.body.classList.add("qb-dragging");
        treeEl.classList.add("qb-dragging");
        var treeElContainer = treeEl.closest(".query-builder-container") || treeEl;
        treeElContainer = _this._getScrollParent(treeElContainer) || document.body;
        var scrollTop = treeElContainer.scrollTop;

        var _dragEl = _this._getDraggableNodeEl(treeEl);

        var _plhEl = _this._getPlaceholderNodeEl(treeEl);

        var tmpAllGroups = treeEl.querySelectorAll(".group--children");
        var anyGroup = tmpAllGroups.length ? tmpAllGroups[0] : null;
        var groupPadding;

        if (anyGroup) {
          groupPadding = window.getComputedStyle(anyGroup, null).getPropertyValue("padding-left");
          groupPadding = parseInt(groupPadding);
        }

        var dragging = {
          id: id,
          x: dom.offsetLeft,
          y: dom.offsetTop,
          w: dom.offsetWidth,
          h: dom.offsetHeight,
          itemInfo: _this.tree.items[id],
          paddingLeft: groupPadding
        };
        var dragStart = {
          id: id,
          x: dom.offsetLeft,
          y: dom.offsetTop,
          scrollTop: scrollTop,
          clientX: e.clientX,
          clientY: e.clientY,
          itemInfo: clone__WEBPACK_IMPORTED_MODULE_4___default()(_this.tree.items[id]),
          treeEl: treeEl,
          treeElContainer: treeElContainer
        };
        var mousePos = {
          clientX: e.clientX,
          clientY: e.clientY
        };
        var target = e.__mocked_window || window;
        target.addEventListener("mousemove", _this.onDrag);
        target.addEventListener("mouseup", _this.onDragEnd);

        _this.props.setDragStart(dragStart, dragging, mousePos);
      };

      _this.onDrag = function (e) {
        var doHandleDrag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        var dragging = Object.assign({}, _this.props.dragging);
        var startDragging = _this.props.dragStart;
        var paddingLeft = dragging.paddingLeft; //this.props.paddingLeft;

        var treeElContainer = startDragging.treeElContainer;
        var scrollTop = treeElContainer.scrollTop;
        dragging.itemInfo = _this.tree.items[dragging.id];

        if (!dragging.itemInfo) {
          return;
        }

        var mousePos = {
          clientX: e.clientX,
          clientY: e.clientY
        };
        var startMousePos = {
          clientX: startDragging.clientX,
          clientY: startDragging.clientY
        };

        if (e.__mock_dom) {
          var treeEl = startDragging.treeEl;

          var dragEl = _this._getDraggableNodeEl(treeEl);

          var plhEl = _this._getPlaceholderNodeEl(treeEl);

          e.__mock_dom({
            treeEl: treeEl,
            dragEl: dragEl,
            plhEl: plhEl
          });
        } //first init plX/plY


        if (!startDragging.plX) {
          var _treeEl = startDragging.treeEl;

          var _plhEl2 = _this._getPlaceholderNodeEl(_treeEl);

          if (_plhEl2) {
            startDragging.plX = _plhEl2.getBoundingClientRect().left + window.scrollX;
            startDragging.plY = _plhEl2.getBoundingClientRect().top + window.scrollY;
          }
        }

        var startX = startDragging.x;
        var startY = startDragging.y;
        var startClientX = startDragging.clientX;
        var startClientY = startDragging.clientY;
        var startScrollTop = startDragging.scrollTop;
        var pos = {
          x: startX + (e.clientX - startClientX),
          y: startY + (e.clientY - startClientY) + (scrollTop - startScrollTop)
        };
        dragging.x = pos.x;
        dragging.y = pos.y;
        dragging.paddingLeft = paddingLeft;
        dragging.mousePos = mousePos;
        dragging.startMousePos = startMousePos;

        _this.props.setDragProgress(mousePos, dragging);

        var moved = doHandleDrag ? _this.handleDrag(dragging, e, CanMoveFn) : false;

        if (!moved) {
          if (e.preventDefault) e.preventDefault();
        }
      };

      _this.onDragEnd = function () {
        var treeEl = _this.props.dragStart.treeEl;

        _this.props.setDragEnd();

        treeEl.classList.remove("qb-dragging");
        document.body.classList.remove("qb-dragging");
        _this._cacheEls = {};
        window.removeEventListener("mousemove", _this.onDrag);
        window.removeEventListener("mouseup", _this.onDragEnd);
      };

      Object(_utils_stuff__WEBPACK_IMPORTED_MODULE_8__[/* useOnPropsChanged */ "m"])(_assertThisInitialized(_this));

      _this.onPropsChanged(props);

      return _this;
    }

    _createClass(SortableContainer, [{
      key: "onPropsChanged",
      value: function onPropsChanged(nextProps) {
        this.tree = Object(_utils_treeUtils__WEBPACK_IMPORTED_MODULE_2__[/* getFlatTree */ "e"])(nextProps.tree);
      }
    }, {
      key: "shouldComponentUpdate",
      value: function shouldComponentUpdate(nextProps, nextState) {
        var prevProps = this.props;
        var prevState = this.state;
        var should = Object(_utils_renderUtils__WEBPACK_IMPORTED_MODULE_7__[/* pureShouldComponentUpdate */ "b"])(this)(nextProps, nextState);

        if (should) {
          if (prevState == nextState && prevProps != nextProps) {
            var chs = [];

            for (var k in nextProps) {
              var changed = nextProps[k] != prevProps[k];

              if (changed) {
                //don't render <Builder> on dragging - appropriate redux-connected components will do it
                if (k != "dragging" && k != "mousePos") chs.push(k);
              }
            }

            if (!chs.length) should = false;
          }
        }

        return should;
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate(_prevProps, _prevState) {
        var dragging = this.props.dragging;
        var startDragging = this.props.dragStart;

        if (startDragging && startDragging.id) {
          dragging.itemInfo = this.tree.items[dragging.id];

          if (dragging.itemInfo) {
            if (dragging.itemInfo.index != startDragging.itemInfo.index || dragging.itemInfo.parent != startDragging.itemInfo.parent) {
              var treeEl = startDragging.treeEl;
              var treeElContainer = startDragging.treeElContainer;

              var plhEl = this._getPlaceholderNodeEl(treeEl, true);

              if (plhEl) {
                var plX = plhEl.getBoundingClientRect().left + window.scrollX;
                var plY = plhEl.getBoundingClientRect().top + window.scrollY;
                var oldPlX = startDragging.plX;
                var oldPlY = startDragging.plY;
                var scrollTop = treeElContainer.scrollTop;
                startDragging.plX = plX;
                startDragging.plY = plY;
                startDragging.itemInfo = clone__WEBPACK_IMPORTED_MODULE_4___default()(dragging.itemInfo);
                startDragging.y = plhEl.offsetTop;
                startDragging.x = plhEl.offsetLeft;
                startDragging.clientY += plY - oldPlY;
                startDragging.clientX += plX - oldPlX;
                if (treeElContainer != document.body) startDragging.scrollTop = scrollTop;
                this.onDrag(this.props.mousePos, false);
              }
            }
          }
        }
      }
    }, {
      key: "_getNodeElById",
      value: function _getNodeElById(treeEl, indexId) {
        var ignoreCache = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        if (indexId == null) return null;
        if (!this._cacheEls) this._cacheEls = {};
        var el = this._cacheEls[indexId];
        if (el && document.contains(el) && !ignoreCache) return el;
        el = treeEl.querySelector('.group-or-rule-container[data-id="' + indexId + '"]');
        this._cacheEls[indexId] = el;
        return el;
      }
    }, {
      key: "_getDraggableNodeEl",
      value: function _getDraggableNodeEl(treeEl) {
        var ignoreCache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        if (!this._cacheEls) this._cacheEls = {};
        var el = this._cacheEls["draggable"];
        if (el && document.contains(el) && !ignoreCache) return el;
        var els = treeEl.getElementsByClassName("qb-draggable");
        el = els.length ? els[0] : null;
        this._cacheEls["draggable"] = el;
        return el;
      }
    }, {
      key: "_getPlaceholderNodeEl",
      value: function _getPlaceholderNodeEl(treeEl) {
        var ignoreCache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        if (!this._cacheEls) this._cacheEls = {};
        var el = this._cacheEls["placeholder"];
        if (el && document.contains(el) && !ignoreCache) return el;
        var els = treeEl.getElementsByClassName("qb-placeholder");
        el = els.length ? els[0] : null;
        this._cacheEls["placeholder"] = el;
        return el;
      }
    }, {
      key: "_isScrollable",
      value: function _isScrollable(node) {
        var overflowY = window.getComputedStyle(node)["overflow-y"];
        return (overflowY === "scroll" || overflowY === "auto") && node.scrollHeight > node.offsetHeight;
      }
    }, {
      key: "_getScrollParent",
      value: function _getScrollParent(node) {
        if (node == null) return null;

        if (node === document.body || this._isScrollable(node)) {
          return node;
        } else {
          return this._getScrollParent(node.parentNode);
        }
      }
    }, {
      key: "handleDrag",
      value: function handleDrag(dragInfo, e, canMoveFn) {
        var _this2 = this;

        var canMoveBeforeAfterGroup = true;
        var itemInfo = dragInfo.itemInfo;
        var paddingLeft = dragInfo.paddingLeft;
        var moveInfo = null;
        var treeEl = this.props.dragStart.treeEl;
        var dragId = dragInfo.id;

        var dragEl = this._getDraggableNodeEl(treeEl);

        var plhEl = this._getPlaceholderNodeEl(treeEl);

        var dragRect, plhRect, hovRect, treeRect;

        if (dragEl && plhEl) {
          dragRect = dragEl.getBoundingClientRect();
          plhRect = plhEl.getBoundingClientRect();

          if (!plhRect.width) {
            return;
          }

          var dragDirs = {
            hrz: 0,
            vrt: 0
          };
          if (dragRect.top < plhRect.top) dragDirs.vrt = -1; //up
          else if (dragRect.bottom > plhRect.bottom) dragDirs.vrt = +1; //down

          if (dragRect.left > plhRect.left) dragDirs.hrz = +1; //right
          else if (dragRect.left < plhRect.left) dragDirs.hrz = -1; //left

          treeRect = treeEl.getBoundingClientRect();
          var trgCoord = {
            x: treeRect.left + (treeRect.right - treeRect.left) / 2,
            y: dragDirs.vrt >= 0 ? dragRect.bottom : dragRect.top
          };
          var hovCNodeEl;

          if (e.__mocked_hov_container) {
            hovCNodeEl = e.__mocked_hov_container;
          } else {
            var hovNodeEl = document.elementFromPoint(trgCoord.x, trgCoord.y - 1);
            hovCNodeEl = hovNodeEl ? hovNodeEl.closest(".group-or-rule-container") : null;
          }

          if (!hovCNodeEl) {
            console.log("out of tree bounds!");
          } else {
            var isGroup = hovCNodeEl.classList.contains("group-container");
            var hovNodeId = hovCNodeEl.getAttribute("data-id");
            var hovEl = hovCNodeEl;
            var doAppend = false;
            var doPrepend = false;

            if (hovEl) {
              hovRect = hovEl.getBoundingClientRect();
              var hovHeight = hovRect.bottom - hovRect.top;
              var hovII = this.tree.items[hovNodeId];
              var trgRect = null,
                  trgEl = null,
                  trgII = null,
                  altII = null; //for canMoveBeforeAfterGroup

              if (dragDirs.vrt == 0) {
                trgII = itemInfo;
                trgEl = plhEl;
                if (trgEl) trgRect = trgEl.getBoundingClientRect();
              } else {
                if (isGroup) {
                  if (dragDirs.vrt > 0) {
                    //down
                    //take group header (for prepend only)
                    var hovInnerEl = hovCNodeEl.getElementsByClassName("group--header");
                    var hovEl2 = hovInnerEl.length ? hovInnerEl[0] : null;

                    if (hovEl2) {
                      var hovRect2 = hovEl2.getBoundingClientRect();
                      var hovHeight2 = hovRect2.bottom - hovRect2.top;
                      var isOverHover = dragRect.bottom - hovRect2.top > hovHeight2 * 3 / 4;

                      if (isOverHover && hovII.top > dragInfo.itemInfo.top) {
                        trgII = hovII;
                        trgRect = hovRect2;
                        trgEl = hovEl2;
                        doPrepend = true;
                      }
                    }
                  } else if (dragDirs.vrt < 0) {
                    //up
                    if (hovII.lev >= itemInfo.lev) {
                      //take whole group
                      //todo: 5 is magic for now (bottom margin), configure it!
                      var isClimbToHover = hovRect.bottom - dragRect.top >= 2;

                      if (isClimbToHover && hovII.top < dragInfo.itemInfo.top) {
                        trgII = hovII;
                        trgRect = hovRect;
                        trgEl = hovEl;
                        doAppend = true;
                      }
                    }
                  }

                  if (!doPrepend && !doAppend || canMoveBeforeAfterGroup) {
                    //take whole group and check if we can move before/after group
                    var _isOverHover = dragDirs.vrt < 0 //up
                    ? hovRect.bottom - dragRect.top > hovHeight - 5 : dragRect.bottom - hovRect.top > hovHeight - 5;

                    if (_isOverHover) {
                      if (!doPrepend && !doAppend) {
                        trgII = hovII;
                        trgRect = hovRect;
                        trgEl = hovEl;
                      }

                      if (canMoveBeforeAfterGroup) {
                        altII = hovII;
                      }
                    }
                  }
                } else {
                  //check if we can move before/after group
                  var _isOverHover2 = dragDirs.vrt < 0 //up
                  ? hovRect.bottom - dragRect.top > hovHeight / 2 : dragRect.bottom - hovRect.top > hovHeight / 2;

                  if (_isOverHover2) {
                    trgII = hovII;
                    trgRect = hovRect;
                    trgEl = hovEl;
                  }
                }
              }

              var isSamePos = trgII && trgII.id == dragId;

              if (trgRect) {
                var dragLeftOffset = dragRect.left - treeRect.left;
                var trgLeftOffset = trgRect.left - treeRect.left;

                var _trgLev = trgLeftOffset / paddingLeft;

                var dragLev = Math.max(0, Math.round(dragLeftOffset / paddingLeft)); //find all possible moves

                var availMoves = [];
                var altMoves = []; //alternatively can move after/before group, if can't move into it

                if (isSamePos) {//do nothing
                } else {
                  if (isGroup) {
                    if (doAppend) {
                      availMoves.push([_constants__WEBPACK_IMPORTED_MODULE_3__[/* PLACEMENT_APPEND */ "f"], trgII, trgII.lev + 1]);
                    } else if (doPrepend) {
                      availMoves.push([_constants__WEBPACK_IMPORTED_MODULE_3__[/* PLACEMENT_PREPEND */ "h"], trgII, trgII.lev + 1]);
                    } //alt


                    if (canMoveBeforeAfterGroup && altII) {
                      if (dragDirs.vrt > 0) {
                        //down
                        altMoves.push([_constants__WEBPACK_IMPORTED_MODULE_3__[/* PLACEMENT_AFTER */ "e"], altII, altII.lev]);
                      } else if (dragDirs.vrt < 0) {
                        //up
                        altMoves.push([_constants__WEBPACK_IMPORTED_MODULE_3__[/* PLACEMENT_BEFORE */ "g"], altII, altII.lev]);
                      }
                    }
                  }

                  if (!doAppend && !doPrepend) {
                    if (dragDirs.vrt < 0) {
                      //up
                      availMoves.push([_constants__WEBPACK_IMPORTED_MODULE_3__[/* PLACEMENT_BEFORE */ "g"], trgII, trgII.lev]);
                    } else if (dragDirs.vrt > 0) {
                      //down
                      availMoves.push([_constants__WEBPACK_IMPORTED_MODULE_3__[/* PLACEMENT_AFTER */ "e"], trgII, trgII.lev]);
                    }
                  }
                } //sanitize


                availMoves = availMoves.filter(function (am) {
                  var placement = am[0];
                  var trg = am[1];
                  if ((placement == _constants__WEBPACK_IMPORTED_MODULE_3__[/* PLACEMENT_BEFORE */ "g"] || placement == _constants__WEBPACK_IMPORTED_MODULE_3__[/* PLACEMENT_AFTER */ "e"]) && trg.parent == null) return false;
                  if (trg.collapsed && (placement == _constants__WEBPACK_IMPORTED_MODULE_3__[/* PLACEMENT_APPEND */ "f"] || placement == _constants__WEBPACK_IMPORTED_MODULE_3__[/* PLACEMENT_PREPEND */ "h"])) return false;
                  var isInside = trg.id == itemInfo.id;

                  if (!isInside) {
                    var tmp = trg;

                    while (tmp.parent) {
                      tmp = _this2.tree.items[tmp.parent];

                      if (tmp.id == itemInfo.id) {
                        isInside = true;
                        break;
                      }
                    }
                  }

                  return !isInside;
                }).map(function (am) {
                  var placement = am[0],
                      toII = am[1];
                  var toParentII = null;
                  if (placement == _constants__WEBPACK_IMPORTED_MODULE_3__[/* PLACEMENT_APPEND */ "f"] || placement == _constants__WEBPACK_IMPORTED_MODULE_3__[/* PLACEMENT_PREPEND */ "h"]) toParentII = toII;else toParentII = _this2.tree.items[toII.parent];
                  if (toParentII && toParentII.parent == null) toParentII = null;
                  am[3] = toParentII;
                  return am;
                });
                var bestMode = null;
                var filteredMoves = availMoves.filter(function (am) {
                  return _this2.canMove(itemInfo, am[1], am[0], am[3], canMoveFn);
                });

                if (canMoveBeforeAfterGroup && filteredMoves.length == 0 && altMoves.length > 0) {
                  filteredMoves = altMoves.filter(function (am) {
                    return _this2.canMove(itemInfo, am[1], am[0], am[3], canMoveFn);
                  });
                }

                var levs = filteredMoves.map(function (am) {
                  return am[2];
                });
                var curLev = itemInfo.lev;
                var allLevs = levs.concat(curLev);
                var closestDragLev = null;
                if (allLevs.indexOf(dragLev) != -1) closestDragLev = dragLev;else if (dragLev > Math.max.apply(Math, _toConsumableArray(allLevs))) closestDragLev = Math.max.apply(Math, _toConsumableArray(allLevs));else if (dragLev < Math.min.apply(Math, _toConsumableArray(allLevs))) closestDragLev = Math.min.apply(Math, _toConsumableArray(allLevs));
                bestMode = filteredMoves.find(function (am) {
                  return am[2] == closestDragLev;
                });
                if (!isSamePos && !bestMode && filteredMoves.length) bestMode = filteredMoves[0];
                moveInfo = bestMode;
              }
            }
          }
        }

        if (moveInfo) {
          this.move(itemInfo, moveInfo[1], moveInfo[0], moveInfo[3]); // if (isDev())  console.log("DRAG-N-DROP", JSON.stringify({
          //   dragRect,
          //   plhRect,
          //   treeRect,
          //   hovRect,
          //   startMousePos: dragInfo.startMousePos,
          //   mousePos: dragInfo.mousePos,
          // }));

          return true;
        }

        return false;
      }
    }, {
      key: "canMove",
      value: function canMove(fromII, toII, placement, toParentII, canMoveFn) {
        if (!fromII || !toII) return false;
        if (fromII.id === toII.id) return false;
        var canRegroup = this.props.config.settings.canRegroup;
        var maxNesting = this.props.config.settings.maxNesting;
        var newLev = toParentII ? toParentII.lev : 0;
        var isPend = placement == _constants__WEBPACK_IMPORTED_MODULE_3__[/* PLACEMENT_PREPEND */ "h"] || placement == _constants__WEBPACK_IMPORTED_MODULE_3__[/* PLACEMENT_APPEND */ "f"];
        var isParentChange = fromII.parent != toII.parent;
        var isStructChange = isPend || isParentChange;
        var isForbiddenStructChange = fromII.parentType == "rule_group" || toII.type == "rule_group" || toII.parentType == "rule_group";
        if (maxNesting && newLev + 1 > maxNesting) return false;
        if (isStructChange && (!canRegroup || isForbiddenStructChange)) return false;
        var res = true;
        if (canMoveFn) res = canMoveFn(fromII.node.toJS(), toII.node.toJS(), placement, toParentII ? toParentII.node.toJS() : null);
        return res;
      }
    }, {
      key: "move",
      value: function move(fromII, toII, placement, toParentII) {
        //if (isDev())  console.log("move", fromII, toII, placement, toParentII);
        this.props.actions.moveItem(fromII.path, toII.path, placement);
      }
    }, {
      key: "render",
      value: function render() {
        return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(Builder, _extends({}, this.props, {
          onDragStart: this.onDragStart
        }));
      }
    }]);

    return SortableContainer;
  }(react__WEBPACK_IMPORTED_MODULE_0__["Component"]);

  SortableContainer.propTypes = {
    tree: prop_types__WEBPACK_IMPORTED_MODULE_5___default.a.any.isRequired,
    //instanceOf(Immutable.Map)
    actions: prop_types__WEBPACK_IMPORTED_MODULE_5___default.a.object.isRequired // {moveItem: Function, ..}
    //... see Builder

  };
  var ConnectedSortableContainer = Object(react_redux__WEBPACK_IMPORTED_MODULE_1__["connect"])(function (state) {
    return {
      dragging: state.dragging,
      dragStart: state.dragStart,
      mousePos: state.mousePos
    };
  }, {
    setDragStart: _actions__WEBPACK_IMPORTED_MODULE_6__[/* drag */ "a"].setDragStart,
    setDragProgress: _actions__WEBPACK_IMPORTED_MODULE_6__[/* drag */ "a"].setDragProgress,
    setDragEnd: _actions__WEBPACK_IMPORTED_MODULE_6__[/* drag */ "a"].setDragEnd
  })(SortableContainer);
  ConnectedSortableContainer.displayName = "ConnectedSortableContainer";
  return ConnectedSortableContainer;
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(34)))

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = __webpack_require__(33);

function emptyFunction() {}
function emptyFunctionWithReset() {}
emptyFunctionWithReset.resetWarningCache = emptyFunction;

module.exports = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }
    var err = new Error(
      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
      'Use PropTypes.checkPropTypes() to call them. ' +
      'Read more at http://fb.me/use-check-prop-types'
    );
    err.name = 'Invariant Violation';
    throw err;
  };
  shim.isRequired = shim;
  function getShim() {
    return shim;
  };
  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    elementType: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim,

    checkPropTypes: emptyFunctionWithReset,
    resetWarningCache: emptyFunction
  };

  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),
/* 34 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 35 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__35__;

/***/ }),
/* 36 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "Query", function() { return /* reexport */ Query_QueryContainer; });
__webpack_require__.d(__webpack_exports__, "Builder", function() { return /* reexport */ Builder_Builder; });
__webpack_require__.d(__webpack_exports__, "Widgets", function() { return /* reexport */ components_widgets; });
__webpack_require__.d(__webpack_exports__, "Operators", function() { return /* reexport */ operators_namespaceObject; });
__webpack_require__.d(__webpack_exports__, "Utils", function() { return /* binding */ Utils; });
__webpack_require__.d(__webpack_exports__, "Export", function() { return /* reexport */ export_namespaceObject; });
__webpack_require__.d(__webpack_exports__, "Import", function() { return /* reexport */ import_namespaceObject; });
__webpack_require__.d(__webpack_exports__, "BasicConfig", function() { return /* reexport */ basic; });

// NAMESPACE OBJECT: ./modules/export/index.js
var export_namespaceObject = {};
__webpack_require__.r(export_namespaceObject);
__webpack_require__.d(export_namespaceObject, "queryBuilderFormat", function() { return queryBuilderFormat; });
__webpack_require__.d(export_namespaceObject, "jsonLogicFormat", function() { return jsonLogic_jsonLogicFormat; });
__webpack_require__.d(export_namespaceObject, "mongodbFormat", function() { return mongodbFormat; });
__webpack_require__.d(export_namespaceObject, "sqlFormat", function() { return sqlFormat; });
__webpack_require__.d(export_namespaceObject, "queryString", function() { return queryString_queryString; });

// NAMESPACE OBJECT: ./modules/import/index.js
var import_namespaceObject = {};
__webpack_require__.r(import_namespaceObject);
__webpack_require__.d(import_namespaceObject, "getTree", function() { return tree_getTree; });
__webpack_require__.d(import_namespaceObject, "loadTree", function() { return loadTree; });
__webpack_require__.d(import_namespaceObject, "checkTree", function() { return tree_checkTree; });
__webpack_require__.d(import_namespaceObject, "isValidTree", function() { return tree_isValidTree; });
__webpack_require__.d(import_namespaceObject, "isImmutableTree", function() { return tree_isImmutableTree; });
__webpack_require__.d(import_namespaceObject, "isTree", function() { return isTree; });
__webpack_require__.d(import_namespaceObject, "isJsonLogic", function() { return stuff["h" /* isJsonLogic */]; });
__webpack_require__.d(import_namespaceObject, "loadFromJsonLogic", function() { return jsonLogic_loadFromJsonLogic; });

// NAMESPACE OBJECT: ./modules/components/operators/index.js
var operators_namespaceObject = {};
__webpack_require__.r(operators_namespaceObject);
__webpack_require__.d(operators_namespaceObject, "ProximityOperator", function() { return Proximity_Proximity; });

// NAMESPACE OBJECT: ./modules/utils/index.js
var utils_namespaceObject = {};
__webpack_require__.r(utils_namespaceObject);
__webpack_require__.d(utils_namespaceObject, "validateTree", function() { return validation["b" /* validateTree */]; });
__webpack_require__.d(utils_namespaceObject, "uuid", function() { return uuid["a" /* default */]; });

// EXTERNAL MODULE: external "React"
var external_React_ = __webpack_require__(0);
var external_React_default = /*#__PURE__*/__webpack_require__.n(external_React_);

// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(1);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);

// EXTERNAL MODULE: external "Immutable"
var external_Immutable_ = __webpack_require__(5);
var external_Immutable_default = /*#__PURE__*/__webpack_require__.n(external_Immutable_);

// EXTERNAL MODULE: ./modules/utils/treeUtils.js
var treeUtils = __webpack_require__(4);

// EXTERNAL MODULE: ./modules/utils/defaultUtils.js
var defaultUtils = __webpack_require__(7);

// EXTERNAL MODULE: ./modules/constants.js
var constants = __webpack_require__(6);

// EXTERNAL MODULE: ./modules/utils/uuid.js
var uuid = __webpack_require__(8);

// EXTERNAL MODULE: ./modules/utils/configUtils.js
var configUtils = __webpack_require__(2);

// EXTERNAL MODULE: ./modules/utils/stuff.js
var stuff = __webpack_require__(3);

// EXTERNAL MODULE: ./modules/utils/validation.js
var validation = __webpack_require__(14);

// CONCATENATED MODULE: ./modules/stores/tree.js
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }










var tree_hasChildren = function hasChildren(tree, path) {
  return tree.getIn(Object(treeUtils["a" /* expandTreePath */])(path, "children1")).size > 0;
};
/**
 * @param {object} config
 * @param {Immutable.List} path
 * @param {Immutable.Map} properties
 */


var tree_addNewGroup = function addNewGroup(state, path, properties, config) {
  var groupUuid = Object(uuid["a" /* default */])();
  var rulesNumber = Object(treeUtils["i" /* getTotalRulesCountInTree */])(state);
  var maxNumberOfRules = config.settings.maxNumberOfRules;
  var canAddNewRule = !(maxNumberOfRules && rulesNumber + 1 > maxNumberOfRules);
  state = tree_addItem(state, path, "group", groupUuid, Object(defaultUtils["c" /* defaultGroupProperties */])(config).merge(properties || {}), config);
  var groupPath = path.push(groupUuid); // If we don't set the empty map, then the following merge of addItem will create a Map rather than an OrderedMap for some reason

  state = state.setIn(Object(treeUtils["a" /* expandTreePath */])(groupPath, "children1"), new external_Immutable_default.a.OrderedMap());

  if (canAddNewRule) {
    state = tree_addItem(state, groupPath, "rule", Object(uuid["a" /* default */])(), Object(defaultUtils["g" /* defaultRuleProperties */])(config), config);
  }

  state = Object(treeUtils["d" /* fixPathsInTree */])(state);
  return state;
};
/**
 * @param {object} config
 * @param {Immutable.List} path
 * @param {Immutable.Map} properties
 */


var tree_removeGroup = function removeGroup(state, path, config) {
  state = tree_removeItem(state, path);
  var parentPath = path.slice(0, -1);
  var isEmptyGroup = !tree_hasChildren(state, parentPath);
  var isEmptyRoot = isEmptyGroup && parentPath.size == 1;
  var canLeaveEmpty = isEmptyGroup && config.settings.canLeaveEmptyGroup && !isEmptyRoot;

  if (isEmptyRoot) {
    state = tree_addItem(state, parentPath, "rule", Object(uuid["a" /* default */])(), Object(defaultUtils["g" /* defaultRuleProperties */])(config), config);
  } else if (!canLeaveEmpty) {
    state = Object(treeUtils["c" /* fixEmptyGroupsInTree */])(state);
  }

  state = Object(treeUtils["d" /* fixPathsInTree */])(state);
  return state;
};
/**
 * @param {object} config
 * @param {Immutable.List} path
 */


var tree_removeRule = function removeRule(state, path, config) {
  state = tree_removeItem(state, path);
  var parentPath = path.pop();
  var parent = state.getIn(Object(treeUtils["a" /* expandTreePath */])(parentPath));
  var parentField = parent.getIn(["properties", "field"]);
  var isParentRuleGroup = parent.get("type") == "rule_group";
  var isEmptyGroup = !tree_hasChildren(state, parentPath);
  var isEmptyRoot = isEmptyGroup && parentPath.size == 1;
  var canLeaveEmpty = isEmptyGroup && (isParentRuleGroup ? true : config.settings.canLeaveEmptyGroup && !isEmptyRoot);

  if (isEmptyGroup) {
    if (isParentRuleGroup) {
      state = state.deleteIn(Object(treeUtils["a" /* expandTreePath */])(parentPath));
    } else if (isEmptyRoot) {
      state = tree_addItem(state, parentPath, "rule", Object(uuid["a" /* default */])(), Object(defaultUtils["g" /* defaultRuleProperties */])(config, parentField), config);
    } else if (!canLeaveEmpty) {
      state = Object(treeUtils["c" /* fixEmptyGroupsInTree */])(state);
    }
  }

  state = Object(treeUtils["d" /* fixPathsInTree */])(state);
  return state;
};
/**
 * @param {Immutable.Map} state
 * @param {Immutable.List} path
 * @param {bool} not
 */


var tree_setNot = function setNot(state, path, not) {
  return state.setIn(Object(treeUtils["a" /* expandTreePath */])(path, "properties", "not"), not);
};
/**
 * @param {Immutable.Map} state
 * @param {Immutable.List} path
 * @param {string} conjunction
 */


var tree_setConjunction = function setConjunction(state, path, conjunction) {
  return state.setIn(Object(treeUtils["a" /* expandTreePath */])(path, "properties", "conjunction"), conjunction);
};
/**
 * @param {Immutable.Map} state
 * @param {Immutable.List} path
 * @param {string} type
 * @param {string} id
 * @param {Immutable.OrderedMap} properties
 * @param {object} config
 */


var tree_addItem = function addItem(state, path, type, id, properties, config) {
  var rulesNumber = Object(treeUtils["i" /* getTotalRulesCountInTree */])(state);
  var maxNumberOfRules = config.settings.maxNumberOfRules;
  var canAddNewRule = !(type == "rule" && maxNumberOfRules && rulesNumber + 1 > maxNumberOfRules);

  if (canAddNewRule) {
    state = state.mergeIn(Object(treeUtils["a" /* expandTreePath */])(path, "children1"), new external_Immutable_default.a.OrderedMap(_defineProperty({}, id, new external_Immutable_default.a.Map({
      type: type,
      id: id,
      properties: properties
    }))));
  }

  state = Object(treeUtils["d" /* fixPathsInTree */])(state);
  return state;
};
/**
 * @param {Immutable.Map} state
 * @param {Immutable.List} path
 */


var tree_removeItem = function removeItem(state, path) {
  state = state.deleteIn(Object(treeUtils["a" /* expandTreePath */])(path));
  state = Object(treeUtils["d" /* fixPathsInTree */])(state);
  return state;
};
/**
 * @param {Immutable.Map} state
 * @param {Immutable.List} fromPath
 * @param {Immutable.List} toPath
 * @param {string} placement, see constants PLACEMENT_*: PLACEMENT_AFTER, PLACEMENT_BEFORE, PLACEMENT_APPEND, PLACEMENT_PREPEND
 * @param {object} config
 */


var tree_moveItem = function moveItem(state, fromPath, toPath, placement, config) {
  var from = Object(treeUtils["f" /* getItemByPath */])(state, fromPath);
  var sourcePath = fromPath.pop();
  var source = fromPath.size > 1 ? Object(treeUtils["f" /* getItemByPath */])(state, sourcePath) : null;
  var sourceChildren = source ? source.get("children1") : null;
  var to = Object(treeUtils["f" /* getItemByPath */])(state, toPath);
  var targetPath = placement == constants["f" /* PLACEMENT_APPEND */] || placement == constants["h" /* PLACEMENT_PREPEND */] ? toPath : toPath.pop();
  var target = placement == constants["f" /* PLACEMENT_APPEND */] || placement == constants["h" /* PLACEMENT_PREPEND */] ? to : toPath.size > 1 ? Object(treeUtils["f" /* getItemByPath */])(state, targetPath) : null;
  var targetChildren = target ? target.get("children1") : null;
  if (!source || !target) return state;
  var isSameParent = source.get("id") == target.get("id");
  var isSourceInsideTarget = targetPath.size < sourcePath.size && Object(stuff["b" /* deepEqual */])(targetPath.toArray(), sourcePath.toArray().slice(0, targetPath.size));
  var isTargetInsideSource = targetPath.size > sourcePath.size && Object(stuff["b" /* deepEqual */])(sourcePath.toArray(), targetPath.toArray().slice(0, sourcePath.size));
  var sourceSubpathFromTarget = null;
  var targetSubpathFromSource = null;

  if (isSourceInsideTarget) {
    sourceSubpathFromTarget = external_Immutable_default.a.List(sourcePath.toArray().slice(targetPath.size));
  } else if (isTargetInsideSource) {
    targetSubpathFromSource = external_Immutable_default.a.List(targetPath.toArray().slice(sourcePath.size));
  }

  var newTargetChildren = targetChildren,
      newSourceChildren = sourceChildren;
  if (!isTargetInsideSource) newSourceChildren = newSourceChildren["delete"](from.get("id"));

  if (isSameParent) {
    newTargetChildren = newSourceChildren;
  } else if (isSourceInsideTarget) {
    newTargetChildren = newTargetChildren.updateIn(Object(treeUtils["b" /* expandTreeSubpath */])(sourceSubpathFromTarget, "children1"), function (_oldChildren) {
      return newSourceChildren;
    });
  }

  if (placement == constants["g" /* PLACEMENT_BEFORE */] || placement == constants["e" /* PLACEMENT_AFTER */]) {
    newTargetChildren = external_Immutable_default.a.OrderedMap().withMutations(function (r) {
      var _iterator = _createForOfIteratorHelper(newTargetChildren.entries()),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var _step$value = _slicedToArray(_step.value, 2),
              itemId = _step$value[0],
              item = _step$value[1];

          if (itemId == to.get("id") && placement == constants["g" /* PLACEMENT_BEFORE */]) {
            r.set(from.get("id"), from);
          }

          r.set(itemId, item);

          if (itemId == to.get("id") && placement == constants["e" /* PLACEMENT_AFTER */]) {
            r.set(from.get("id"), from);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    });
  } else if (placement == constants["f" /* PLACEMENT_APPEND */]) {
    newTargetChildren = newTargetChildren.merge(_defineProperty({}, from.get("id"), from));
  } else if (placement == constants["h" /* PLACEMENT_PREPEND */]) {
    newTargetChildren = external_Immutable_default.a.OrderedMap(_defineProperty({}, from.get("id"), from)).merge(newTargetChildren);
  }

  if (isTargetInsideSource) {
    newSourceChildren = newSourceChildren.updateIn(Object(treeUtils["b" /* expandTreeSubpath */])(targetSubpathFromSource, "children1"), function (_oldChildren) {
      return newTargetChildren;
    });
    newSourceChildren = newSourceChildren["delete"](from.get("id"));
  }

  if (!isSameParent && !isSourceInsideTarget) state = state.updateIn(Object(treeUtils["a" /* expandTreePath */])(sourcePath, "children1"), function (_oldChildren) {
    return newSourceChildren;
  });
  if (!isTargetInsideSource) state = state.updateIn(Object(treeUtils["a" /* expandTreePath */])(targetPath, "children1"), function (_oldChildren) {
    return newTargetChildren;
  });
  state = Object(treeUtils["d" /* fixPathsInTree */])(state);
  return state;
};
/**
 * @param {Immutable.Map} state
 * @param {Immutable.List} path
 * @param {string} field
 */


var tree_setField = function setField(state, path, newField, config) {
  if (!newField) return tree_removeItem(state, path);
  var _config$settings = config.settings,
      fieldSeparator = _config$settings.fieldSeparator,
      setOpOnChangeField = _config$settings.setOpOnChangeField,
      showErrorMessage = _config$settings.showErrorMessage;
  if (Array.isArray(newField)) newField = newField.join(fieldSeparator);
  var currentType = state.getIn(Object(treeUtils["a" /* expandTreePath */])(path, "type"));
  var wasRuleGroup = currentType == "rule_group";
  var newFieldConfig = Object(configUtils["b" /* getFieldConfig */])(newField, config);
  var isRuleGroup = newFieldConfig.type == "!group";

  if (!isRuleGroup && !newFieldConfig.operators) {
    console.warn("Type ".concat(newFieldConfig.type, " is not supported"));
    return state;
  }

  if (wasRuleGroup && !isRuleGroup) {
    state = state.setIn(Object(treeUtils["a" /* expandTreePath */])(path, "type"), "rule");
    state = state.deleteIn(Object(treeUtils["a" /* expandTreePath */])(path, "children1"));
    state = state.setIn(Object(treeUtils["a" /* expandTreePath */])(path, "properties"), new external_Immutable_default.a.OrderedMap());
  }

  if (isRuleGroup) {
    state = state.setIn(Object(treeUtils["a" /* expandTreePath */])(path, "type"), "rule_group");
    var groupProperties = Object(defaultUtils["c" /* defaultGroupProperties */])(config).merge({
      field: newField
    });
    state = state.setIn(Object(treeUtils["a" /* expandTreePath */])(path, "properties"), groupProperties);
    state = state.setIn(Object(treeUtils["a" /* expandTreePath */])(path, "children1"), new external_Immutable_default.a.OrderedMap());
    state = tree_addItem(state, path, "rule", Object(uuid["a" /* default */])(), Object(defaultUtils["g" /* defaultRuleProperties */])(config, newField), config);
    state = Object(treeUtils["d" /* fixPathsInTree */])(state);
    return state;
  }

  return state.updateIn(Object(treeUtils["a" /* expandTreePath */])(path, "properties"), function (map) {
    return map.withMutations(function (current) {
      var currentOperator = current.get("operator");
      var currentOperatorOptions = current.get("operatorOptions");

      var _currentField = current.get("field");

      var _currentValue = current.get("value");

      var _currentValueSrc = current.get("valueSrc", new external_Immutable_default.a.List());

      var _currentValueType = current.get("valueType", new external_Immutable_default.a.List()); // If the newly selected field supports the same operator the rule currently
      // uses, keep it selected.


      var lastOp = newFieldConfig && newFieldConfig.operators.indexOf(currentOperator) !== -1 ? currentOperator : null;
      var newOperator = null;
      var availOps = Object(configUtils["k" /* getOperatorsForField */])(config, newField);
      if (availOps && availOps.length == 1) newOperator = availOps[0];else if (availOps && availOps.length > 1) {
        var _iterator2 = _createForOfIteratorHelper(setOpOnChangeField || []),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var strategy = _step2.value;
            if (strategy == "keep") newOperator = lastOp;else if (strategy == "default") newOperator = Object(defaultUtils["d" /* defaultOperator */])(config, newField, false);else if (strategy == "first") newOperator = Object(configUtils["g" /* getFirstOperator */])(config, newField);
            if (newOperator) //found op for strategy
              break;
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }

      var _getNewValueForFieldO = Object(validation["a" /* getNewValueForFieldOp */])(config, config, current, newField, newOperator, "field", true),
          canReuseValue = _getNewValueForFieldO.canReuseValue,
          newValue = _getNewValueForFieldO.newValue,
          newValueSrc = _getNewValueForFieldO.newValueSrc,
          newValueType = _getNewValueForFieldO.newValueType,
          newValueError = _getNewValueForFieldO.newValueError;

      if (showErrorMessage) {
        current = current.set("valueError", newValueError);
      }

      var newOperatorOptions = canReuseValue ? currentOperatorOptions : Object(defaultUtils["e" /* defaultOperatorOptions */])(config, newOperator, newField);
      return current.set("field", newField).set("operator", newOperator).set("operatorOptions", newOperatorOptions).set("value", newValue).set("valueSrc", newValueSrc).set("valueType", newValueType);
    });
  });
};
/**
 * @param {Immutable.Map} state
 * @param {Immutable.List} path
 * @param {string} operator
 */


var tree_setOperator = function setOperator(state, path, newOperator, config) {
  var showErrorMessage = config.settings.showErrorMessage;
  return state.updateIn(Object(treeUtils["a" /* expandTreePath */])(path, "properties"), function (map) {
    return map.withMutations(function (current) {
      var currentField = current.get("field");
      var currentOperatorOptions = current.get("operatorOptions");

      var _currentValue = current.get("value", new external_Immutable_default.a.List());

      var _currentValueSrc = current.get("valueSrc", new external_Immutable_default.a.List());

      var _currentOperator = current.get("operator");

      var _getNewValueForFieldO2 = Object(validation["a" /* getNewValueForFieldOp */])(config, config, current, currentField, newOperator, "operator", true),
          canReuseValue = _getNewValueForFieldO2.canReuseValue,
          newValue = _getNewValueForFieldO2.newValue,
          newValueSrc = _getNewValueForFieldO2.newValueSrc,
          newValueType = _getNewValueForFieldO2.newValueType,
          newValueError = _getNewValueForFieldO2.newValueError;

      if (showErrorMessage) {
        current = current.set("valueError", newValueError);
      }

      var newOperatorOptions = canReuseValue ? currentOperatorOptions : Object(defaultUtils["e" /* defaultOperatorOptions */])(config, newOperator, currentField);
      return current.set("operator", newOperator).set("operatorOptions", newOperatorOptions).set("value", newValue).set("valueSrc", newValueSrc).set("valueType", newValueType);
    });
  });
};
/**
 * @param {Immutable.Map} state
 * @param {Immutable.List} path
 * @param {integer} delta
 * @param {*} value
 * @param {string} valueType
 * @param {boolean} __isInternal
 */


var tree_setValue = function setValue(state, path, delta, value, valueType, config, __isInternal) {
  var _config$settings2 = config.settings,
      fieldSeparator = _config$settings2.fieldSeparator,
      showErrorMessage = _config$settings2.showErrorMessage;
  var valueSrc = state.getIn(Object(treeUtils["a" /* expandTreePath */])(path, "properties", "valueSrc", delta + "")) || null;
  if (valueSrc === "field" && Array.isArray(value)) value = value.join(fieldSeparator);
  var field = state.getIn(Object(treeUtils["a" /* expandTreePath */])(path, "properties", "field")) || null;
  var operator = state.getIn(Object(treeUtils["a" /* expandTreePath */])(path, "properties", "operator")) || null;
  var isEndValue = false;
  var canFix = false;
  var calculatedValueType = valueType || tree_calculateValueType(value, valueSrc, config);

  var _validateValue = Object(validation["c" /* validateValue */])(config, field, field, operator, value, calculatedValueType, valueSrc, canFix, isEndValue),
      _validateValue2 = _slicedToArray(_validateValue, 2),
      validateError = _validateValue2[0],
      fixedValue = _validateValue2[1];

  var isValid = !validateError;

  if (isValid && fixedValue !== value) {
    // eg, get exact value from listValues (not string)
    value = fixedValue;
  } // Additional validation for range values


  if (showErrorMessage) {
    var w = Object(configUtils["n" /* getWidgetForFieldOp */])(config, field, operator, valueSrc);
    var fieldWidgetDefinition = Object(configUtils["e" /* getFieldWidgetConfig */])(config, field, operator, w, valueSrc);
    var operatorConfig = Object(configUtils["j" /* getOperatorConfig */])(config, operator, field);
    var operatorCardinality = operator ? Object(stuff["c" /* defaultValue */])(operatorConfig.cardinality, 1) : null;
    var valueSrcs = Array.from({
      length: operatorCardinality
    }, function (_, i) {
      return state.getIn(Object(treeUtils["a" /* expandTreePath */])(path, "properties", "valueSrc", i + "")) || null;
    });

    if (operatorConfig && operatorConfig.validateValues && valueSrcs.filter(function (vs) {
      return vs == "value" || vs == null;
    }).length == operatorCardinality) {
      var values = Array.from({
        length: operatorCardinality
      }, function (_, i) {
        return i == delta ? value : state.getIn(Object(treeUtils["a" /* expandTreePath */])(path, "properties", "value", i + "")) || null;
      });
      var jsValues = fieldWidgetDefinition && fieldWidgetDefinition.toJS ? values.map(function (v) {
        return fieldWidgetDefinition.toJS(v, fieldWidgetDefinition);
      }) : values;
      var rangeValidateError = operatorConfig.validateValues(jsValues);
      state = state.setIn(Object(treeUtils["a" /* expandTreePath */])(path, "properties", "valueError", operatorCardinality), rangeValidateError);
    }
  }

  var lastValue = state.getIn(Object(treeUtils["a" /* expandTreePath */])(path, "properties", "value", delta + ""));
  var lastError = state.getIn(Object(treeUtils["a" /* expandTreePath */])(path, "properties", "valueError", delta));
  var isLastEmpty = lastValue == undefined;
  var isLastError = !!lastError;

  if (isValid || showErrorMessage) {
    // set only good value
    if (typeof value === "undefined") {
      state = state.setIn(Object(treeUtils["a" /* expandTreePath */])(path, "properties", "value", delta + ""), undefined);
      state = state.setIn(Object(treeUtils["a" /* expandTreePath */])(path, "properties", "valueType", delta + ""), null);
    } else {
      state = state.setIn(Object(treeUtils["a" /* expandTreePath */])(path, "properties", "value", delta + ""), value);
      state = state.setIn(Object(treeUtils["a" /* expandTreePath */])(path, "properties", "valueType", delta + ""), calculatedValueType);
      state.__isInternalValueChange = __isInternal && !isLastEmpty && !isLastError;
    }
  }

  if (showErrorMessage) {
    state = state.setIn(Object(treeUtils["a" /* expandTreePath */])(path, "properties", "valueError", delta), validateError);
  }

  if (__isInternal && (isValid && isLastError || !isValid && !isLastError)) {
    state = state.setIn(Object(treeUtils["a" /* expandTreePath */])(path, "properties", "valueError", delta), validateError);
    state.__isInternalValueChange = false;
  }

  return state;
};
/**
 * @param {Immutable.Map} state
 * @param {Immutable.List} path
 * @param {integer} delta
 * @param {*} srcKey
 */


var tree_setValueSrc = function setValueSrc(state, path, delta, srcKey, config) {
  var showErrorMessage = config.settings.showErrorMessage;
  state = state.setIn(Object(treeUtils["a" /* expandTreePath */])(path, "properties", "value", delta + ""), undefined);
  state = state.setIn(Object(treeUtils["a" /* expandTreePath */])(path, "properties", "valueType", delta + ""), null);

  if (showErrorMessage) {
    // clear value error
    state = state.setIn(Object(treeUtils["a" /* expandTreePath */])(path, "properties", "valueError", delta), null); // if current operator is range, clear possible range error

    var field = state.getIn(Object(treeUtils["a" /* expandTreePath */])(path, "properties", "field")) || null;
    var operator = state.getIn(Object(treeUtils["a" /* expandTreePath */])(path, "properties", "operator")) || null;
    var operatorConfig = Object(configUtils["j" /* getOperatorConfig */])(config, operator, field);
    var operatorCardinality = operator ? Object(stuff["c" /* defaultValue */])(operatorConfig.cardinality, 1) : null;

    if (operatorConfig.validateValues) {
      state = state.setIn(Object(treeUtils["a" /* expandTreePath */])(path, "properties", "valueError", operatorCardinality), null);
    }
  }

  if (typeof srcKey === "undefined") {
    state = state.setIn(Object(treeUtils["a" /* expandTreePath */])(path, "properties", "valueSrc", delta + ""), null);
  } else {
    state = state.setIn(Object(treeUtils["a" /* expandTreePath */])(path, "properties", "valueSrc", delta + ""), srcKey);
  }

  return state;
};
/**
 * @param {Immutable.Map} state
 * @param {Immutable.List} path
 * @param {string} name
 * @param {*} value
 */


var tree_setOperatorOption = function setOperatorOption(state, path, name, value) {
  return state.setIn(Object(treeUtils["a" /* expandTreePath */])(path, "properties", "operatorOptions", name), value);
};
/**
 * @param {Immutable.Map} state
 */


var tree_checkEmptyGroups = function checkEmptyGroups(state, config) {
  var canLeaveEmptyGroup = config.settings.canLeaveEmptyGroup;

  if (!canLeaveEmptyGroup) {
    state = Object(treeUtils["c" /* fixEmptyGroupsInTree */])(state);
  }

  return state;
};
/**
 * 
 */


var tree_calculateValueType = function calculateValueType(value, valueSrc, config) {
  var calculatedValueType = null;

  if (value) {
    if (valueSrc === "field") {
      var fieldConfig = Object(configUtils["b" /* getFieldConfig */])(value, config);

      if (fieldConfig) {
        calculatedValueType = fieldConfig.type;
      }
    } else if (valueSrc === "func") {
      var funcKey = value.get("func");

      if (funcKey) {
        var funcConfig = Object(configUtils["h" /* getFuncConfig */])(funcKey, config);

        if (funcConfig) {
          calculatedValueType = funcConfig.returnType;
        }
      }
    }
  }

  return calculatedValueType;
};

var emptyDrag = {
  dragging: {
    id: null,
    x: null,
    y: null,
    w: null,
    h: null
  },
  mousePos: {},
  dragStart: {
    id: null
  }
};
/**
 * @param {Immutable.Map} state
 * @param {object} action
 */

/* harmony default export */ var stores_tree = (function (config) {
  var emptyTree = Object(defaultUtils["f" /* defaultRoot */])(config);
  var emptyState = Object.assign({}, {
    tree: emptyTree
  }, emptyDrag);
  var unset = {
    __isInternalValueChange: undefined
  };
  return function () {
    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : emptyState;
    var action = arguments.length > 1 ? arguments[1] : undefined;

    switch (action.type) {
      case constants["s" /* SET_TREE */]:
        return Object.assign({}, state, _objectSpread({}, unset), {
          tree: action.tree
        });

      case constants["b" /* ADD_NEW_GROUP */]:
        return Object.assign({}, state, _objectSpread({}, unset), {
          tree: tree_addNewGroup(state.tree, action.path, action.properties, action.config)
        });

      case constants["a" /* ADD_GROUP */]:
        return Object.assign({}, state, _objectSpread({}, unset), {
          tree: tree_addItem(state.tree, action.path, "group", action.id, action.properties, action.config)
        });

      case constants["i" /* REMOVE_GROUP */]:
        return Object.assign({}, state, _objectSpread({}, unset), {
          tree: tree_removeGroup(state.tree, action.path, action.config)
        });

      case constants["c" /* ADD_RULE */]:
        return Object.assign({}, state, _objectSpread({}, unset), {
          tree: tree_addItem(state.tree, action.path, "rule", action.id, action.properties, action.config)
        });

      case constants["j" /* REMOVE_RULE */]:
        return Object.assign({}, state, _objectSpread({}, unset), {
          tree: tree_removeRule(state.tree, action.path, action.config)
        });

      case constants["k" /* SET_CONJUNCTION */]:
        return Object.assign({}, state, _objectSpread({}, unset), {
          tree: tree_setConjunction(state.tree, action.path, action.conjunction)
        });

      case constants["p" /* SET_NOT */]:
        return Object.assign({}, state, _objectSpread({}, unset), {
          tree: tree_setNot(state.tree, action.path, action.not)
        });

      case constants["o" /* SET_FIELD */]:
        return Object.assign({}, state, _objectSpread({}, unset), {
          tree: tree_setField(state.tree, action.path, action.field, action.config)
        });

      case constants["q" /* SET_OPERATOR */]:
        return Object.assign({}, state, _objectSpread({}, unset), {
          tree: tree_setOperator(state.tree, action.path, action.operator, action.config)
        });

      case constants["t" /* SET_VALUE */]:
        {
          var set = {};
          var tree = tree_setValue(state.tree, action.path, action.delta, action.value, action.valueType, action.config, action.__isInternal);
          if (tree.__isInternalValueChange) set.__isInternalValueChange = true;
          return Object.assign({}, state, _objectSpread(_objectSpread({}, unset), set), {
            tree: tree
          });
        }

      case constants["u" /* SET_VALUE_SRC */]:
        return Object.assign({}, state, _objectSpread({}, unset), {
          tree: tree_setValueSrc(state.tree, action.path, action.delta, action.srcKey, action.config)
        });

      case constants["r" /* SET_OPERATOR_OPTION */]:
        return Object.assign({}, state, _objectSpread({}, unset), {
          tree: tree_setOperatorOption(state.tree, action.path, action.name, action.value)
        });

      case constants["d" /* MOVE_ITEM */]:
        return Object.assign({}, state, _objectSpread({}, unset), {
          tree: tree_moveItem(state.tree, action.fromPath, action.toPath, action.placement, action.config)
        });

      case constants["n" /* SET_DRAG_START */]:
        return Object.assign({}, state, _objectSpread({}, unset), {
          dragStart: action.dragStart,
          dragging: action.dragging,
          mousePos: action.mousePos
        });

      case constants["m" /* SET_DRAG_PROGRESS */]:
        return Object.assign({}, state, _objectSpread({}, unset), {
          mousePos: action.mousePos,
          dragging: action.dragging
        });

      case constants["l" /* SET_DRAG_END */]:
        return Object.assign({}, state, _objectSpread({}, unset), _objectSpread(_objectSpread({}, emptyDrag), {}, {
          tree: tree_checkEmptyGroups(state.tree, config)
        }));

      default:
        return state;
    }
  };
});
// EXTERNAL MODULE: external "Redux"
var external_Redux_ = __webpack_require__(28);

// EXTERNAL MODULE: external "ReactRedux"
var external_ReactRedux_ = __webpack_require__(18);

// EXTERNAL MODULE: ./modules/actions/index.js + 4 modules
var modules_actions = __webpack_require__(19);

// EXTERNAL MODULE: ./modules/utils/renderUtils.js
var renderUtils = __webpack_require__(16);

// EXTERNAL MODULE: external "lodash/pick"
var pick_ = __webpack_require__(12);
var pick_default = /*#__PURE__*/__webpack_require__.n(pick_);

// CONCATENATED MODULE: ./modules/components/Query.jsx
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function Query_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function Query_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Query_ownKeys(Object(source), true).forEach(function (key) { Query_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Query_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function Query_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }














var configKeys = ["conjunctions", "fields", "types", "operators", "widgets", "settings", "funcs"];

var Query_validateAndFixTree = function validateAndFixTree(newTree, _oldTree, newConfig, oldConfig) {
  var tree = Object(validation["b" /* validateTree */])(newTree, _oldTree, newConfig, oldConfig, true, true);
  tree = Object(treeUtils["d" /* fixPathsInTree */])(tree);
  return tree;
};

var Query_Query = /*#__PURE__*/function (_PureComponent) {
  _inherits(Query, _PureComponent);

  var _super = _createSuper(Query);

  function Query(props) {
    var _this;

    _classCallCheck(this, Query);

    _this = _super.call(this, props);
    Object(stuff["m" /* useOnPropsChanged */])(_assertThisInitialized(_this));

    _this._updateActions(props);

    _this.validatedTree = _this.validateTree(props, props); //props.onChange && props.onChange(this.validatedTree, props.config);

    return _this;
  }

  _createClass(Query, [{
    key: "validateTree",
    value: function validateTree(props, oldProps) {
      return Query_validateAndFixTree(props.tree, oldProps.tree, props.config, oldProps.config);
    }
  }, {
    key: "_updateActions",
    value: function _updateActions(props) {
      var config = props.config,
          dispatch = props.dispatch;
      this.actions = Object(stuff["a" /* bindActionCreators */])(Query_objectSpread(Query_objectSpread(Query_objectSpread({}, modules_actions["d" /* tree */]), modules_actions["b" /* group */]), modules_actions["c" /* rule */]), config, dispatch);
    }
  }, {
    key: "onPropsChanged",
    value: function onPropsChanged(nextProps) {
      var onChange = nextProps.onChange;
      var oldConfig = this.props.config;
      var newTree = nextProps.tree;
      var newConfig = nextProps.config;
      var oldValidatedTree = this.validatedTree;
      this.validatedTree = newTree;

      if (oldConfig !== newConfig) {
        this._updateActions(nextProps);

        this.validatedTree = this.validateTree(nextProps, this.props);
      }

      var validatedTreeChanged = !Object(stuff["g" /* immutableEqual */])(this.validatedTree, oldValidatedTree);

      if (validatedTreeChanged) {
        onChange && onChange(this.validatedTree, newConfig);
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props = this.props,
          config = _this$props.config,
          renderBuilder = _this$props.renderBuilder,
          dispatch = _this$props.dispatch,
          __isInternalValueChange = _this$props.__isInternalValueChange;
      var builderProps = {
        tree: this.validatedTree,
        actions: this.actions,
        config: config,
        dispatch: dispatch,
        __isInternalValueChange: __isInternalValueChange
      };
      return renderBuilder(builderProps);
    }
  }]);

  return Query;
}(external_React_["PureComponent"]);

Query_Query.propTypes = {
  config: prop_types_default.a.object.isRequired,
  onChange: prop_types_default.a.func,
  renderBuilder: prop_types_default.a.func,
  tree: prop_types_default.a.any //instanceOf(Immutable.Map)
  //dispatch: PropTypes.func.isRequired,

};
var ConnectedQuery = Object(external_ReactRedux_["connect"])(function (state) {
  return {
    tree: state.tree,
    __isInternalValueChange: state.__isInternalValueChange
  };
})(Query_Query);
ConnectedQuery.displayName = "ConnectedQuery";

var Query_QueryContainer = /*#__PURE__*/function (_Component) {
  _inherits(QueryContainer, _Component);

  var _super2 = _createSuper(QueryContainer);

  function QueryContainer(props, context) {
    var _this2;

    _classCallCheck(this, QueryContainer);

    _this2 = _super2.call(this, props, context);
    _this2.shouldComponentUpdate = Object(renderUtils["a" /* liteShouldComponentUpdate */])(_assertThisInitialized(_this2), {
      value: function value(nextValue, prevValue, state) {
        return false;
      }
    });
    Object(stuff["m" /* useOnPropsChanged */])(_assertThisInitialized(_this2));
    var config = pick_default()(props, configKeys);
    var extendedConfig = Object(configUtils["a" /* extendConfig */])(config);
    var tree = props.value;
    var validatedTree = tree ? Query_validateAndFixTree(tree, null, config, config) : null;
    var store = stores_tree(Query_objectSpread(Query_objectSpread({}, config), {}, {
      tree: validatedTree
    }));
    _this2.state = {
      store: Object(external_Redux_["createStore"])(store),
      config: extendedConfig
    };
    return _this2;
  }

  _createClass(QueryContainer, [{
    key: "onPropsChanged",
    value: function onPropsChanged(nextProps) {
      var _this3 = this;

      // compare configs
      var oldConfig = pick_default()(this.props, configKeys);
      var nextConfig = pick_default()(nextProps, configKeys);
      var isConfigChanged = !Object(stuff["k" /* shallowEqual */])(oldConfig, nextConfig, true);

      if (isConfigChanged) {
        nextConfig = Object(configUtils["a" /* extendConfig */])(nextConfig);
        this.setState({
          config: nextConfig
        });
      } // compare trees


      var storeValue = this.state.store.getState().tree;
      var isTreeChanged = !Object(stuff["g" /* immutableEqual */])(nextProps.value, this.props.value) && !Object(stuff["g" /* immutableEqual */])(nextProps.value, storeValue);

      if (isTreeChanged) {
        var nextTree = nextProps.value || Object(defaultUtils["f" /* defaultRoot */])(Query_objectSpread(Query_objectSpread({}, nextProps), {}, {
          tree: null
        }));
        var validatedTree = Query_validateAndFixTree(nextTree, null, nextConfig, oldConfig);
        return Promise.resolve().then(function () {
          _this3.state.store.dispatch(modules_actions["d" /* tree */].setTree(nextProps, validatedTree));
        });
      }
    }
  }, {
    key: "render",
    value: function render() {
      // `get_children` is deprecated!
      var _this$props2 = this.props,
          renderBuilder = _this$props2.renderBuilder,
          get_children = _this$props2.get_children,
          onChange = _this$props2.onChange,
          settings = _this$props2.settings;
      var _this$state = this.state,
          config = _this$state.config,
          store = _this$state.store;
      var QueryWrapper = settings.renderProvider;
      return /*#__PURE__*/external_React_default.a.createElement(QueryWrapper, {
        config: config
      }, /*#__PURE__*/external_React_default.a.createElement(external_ReactRedux_["Provider"], {
        store: store
      }, /*#__PURE__*/external_React_default.a.createElement(ConnectedQuery, {
        store: store,
        config: config,
        onChange: onChange,
        renderBuilder: renderBuilder || get_children
      })));
    }
  }]);

  return QueryContainer;
}(external_React_["Component"]);

Query_QueryContainer.propTypes = {
  //config
  conjunctions: prop_types_default.a.object.isRequired,
  fields: prop_types_default.a.object.isRequired,
  types: prop_types_default.a.object.isRequired,
  operators: prop_types_default.a.object.isRequired,
  widgets: prop_types_default.a.object.isRequired,
  settings: prop_types_default.a.object.isRequired,
  onChange: prop_types_default.a.func,
  renderBuilder: prop_types_default.a.func,
  value: prop_types_default.a.any //instanceOf(Immutable.Map)

};

// CONCATENATED MODULE: ./modules/components/containers/RuleContainer.jsx
function RuleContainer_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { RuleContainer_typeof = function _typeof(obj) { return typeof obj; }; } else { RuleContainer_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return RuleContainer_typeof(obj); }

function RuleContainer_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function RuleContainer_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function RuleContainer_createClass(Constructor, protoProps, staticProps) { if (protoProps) RuleContainer_defineProperties(Constructor.prototype, protoProps); if (staticProps) RuleContainer_defineProperties(Constructor, staticProps); return Constructor; }

function RuleContainer_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) RuleContainer_setPrototypeOf(subClass, superClass); }

function RuleContainer_setPrototypeOf(o, p) { RuleContainer_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return RuleContainer_setPrototypeOf(o, p); }

function RuleContainer_createSuper(Derived) { var hasNativeReflectConstruct = RuleContainer_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = RuleContainer_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = RuleContainer_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return RuleContainer_possibleConstructorReturn(this, result); }; }

function RuleContainer_possibleConstructorReturn(self, call) { if (call && (RuleContainer_typeof(call) === "object" || typeof call === "function")) { return call; } return RuleContainer_assertThisInitialized(self); }

function RuleContainer_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function RuleContainer_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function RuleContainer_getPrototypeOf(o) { RuleContainer_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return RuleContainer_getPrototypeOf(o); }







var classNames = __webpack_require__(26);

/* harmony default export */ var containers_RuleContainer = (function (Rule) {
  var RuleContainer = /*#__PURE__*/function (_Component) {
    RuleContainer_inherits(RuleContainer, _Component);

    var _super = RuleContainer_createSuper(RuleContainer);

    function RuleContainer(props) {
      var _this;

      RuleContainer_classCallCheck(this, RuleContainer);

      _this = _super.call(this, props);

      _this.dummyFn = function () {};

      _this.removeSelf = function () {
        _this.props.actions.removeRule(_this.props.path);
      };

      _this.setField = function (field) {
        _this.props.actions.setField(_this.props.path, field);
      };

      _this.setOperator = function (operator) {
        _this.props.actions.setOperator(_this.props.path, operator);
      };

      _this.setOperatorOption = function (name, value) {
        _this.props.actions.setOperatorOption(_this.props.path, name, value);
      };

      _this.setValue = function (delta, value, type, __isInternal) {
        _this.props.actions.setValue(_this.props.path, delta, value, type, __isInternal);
      };

      _this.setValueSrc = function (delta, srcKey) {
        _this.props.actions.setValueSrc(_this.props.path, delta, srcKey);
      };

      _this.dummyFn.isDummyFn = true;
      return _this;
    }

    RuleContainer_createClass(RuleContainer, [{
      key: "shouldComponentUpdate",
      value: function shouldComponentUpdate(nextProps, nextState) {
        var prevProps = this.props;
        var prevState = this.state;
        var should = Object(renderUtils["b" /* pureShouldComponentUpdate */])(this)(nextProps, nextState);

        if (should) {
          if (prevState == nextState && prevProps != nextProps) {
            var draggingId = nextProps.dragging.id || prevProps.dragging.id;
            var isDraggingMe = draggingId == nextProps.id;
            var chs = [];

            for (var k in nextProps) {
              var changed = nextProps[k] != prevProps[k];

              if (k == "dragging" && !isDraggingMe) {
                changed = false; //dragging another item -> ignore
              }

              if (changed) {
                chs.push(k);
              }
            }

            if (!chs.length) should = false;
          }
        }

        return should;
      }
    }, {
      key: "render",
      value: function render() {
        var isDraggingMe = this.props.dragging.id == this.props.id;
        var fieldConfig = Object(configUtils["b" /* getFieldConfig */])(this.props.field, this.props.config);
        var showErrorMessage = this.props.config.settings.showErrorMessage;

        var _isGroup = fieldConfig && fieldConfig.type == "!struct";

        var isInDraggingTempo = !isDraggingMe && this.props.isDraggingTempo;
        var valueError = this.props.valueError;
        var oneValueError = valueError && valueError.toArray().filter(function (e) {
          return !!e;
        }).shift() || null;
        var hasError = oneValueError != null && showErrorMessage;
        return /*#__PURE__*/external_React_default.a.createElement("div", {
          className: classNames("group-or-rule-container", "rule-container", hasError ? "rule-with-error" : null),
          "data-id": this.props.id
        }, [isDraggingMe ? /*#__PURE__*/external_React_default.a.createElement(Rule, {
          key: "dragging",
          id: this.props.id,
          isDraggingMe: true,
          isDraggingTempo: true,
          dragging: this.props.dragging,
          setField: this.dummyFn,
          setOperator: this.dummyFn,
          setOperatorOption: this.dummyFn,
          removeSelf: this.dummyFn,
          setValue: this.dummyFn,
          setValueSrc: this.dummyFn,
          selectedField: this.props.field || null,
          parentField: this.props.parentField || null,
          selectedOperator: this.props.operator || null,
          value: this.props.value || null,
          valueSrc: this.props.valueSrc || null,
          valueError: this.props.valueError || null,
          operatorOptions: this.props.operatorOptions,
          config: this.props.config,
          reordableNodesCnt: this.props.reordableNodesCnt,
          totalRulesCnt: this.props.totalRulesCnt
        }) : null, /*#__PURE__*/external_React_default.a.createElement(Rule, {
          key: this.props.id,
          id: this.props.id,
          isDraggingMe: isDraggingMe,
          isDraggingTempo: isInDraggingTempo,
          onDragStart: this.props.onDragStart,
          removeSelf: isInDraggingTempo ? this.dummyFn : this.removeSelf,
          setField: isInDraggingTempo ? this.dummyFn : this.setField,
          setOperator: isInDraggingTempo ? this.dummyFn : this.setOperator,
          setOperatorOption: isInDraggingTempo ? this.dummyFn : this.setOperatorOption,
          setValue: isInDraggingTempo ? this.dummyFn : this.setValue,
          setValueSrc: isInDraggingTempo ? this.dummyFn : this.setValueSrc,
          selectedField: this.props.field || null,
          parentField: this.props.parentField || null,
          selectedOperator: this.props.operator || null,
          value: this.props.value || null,
          valueSrc: this.props.valueSrc || null,
          valueError: this.props.valueError || null,
          operatorOptions: this.props.operatorOptions,
          config: this.props.config,
          reordableNodesCnt: this.props.reordableNodesCnt,
          totalRulesCnt: this.props.totalRulesCnt
        })]);
      }
    }]);

    return RuleContainer;
  }(external_React_["Component"]);

  RuleContainer.propTypes = {
    id: prop_types_default.a.string.isRequired,
    config: prop_types_default.a.object.isRequired,
    path: prop_types_default.a.any.isRequired,
    //instanceOf(Immutable.List)
    operator: prop_types_default.a.string,
    field: prop_types_default.a.string,
    actions: prop_types_default.a.object.isRequired,
    //{removeRule: Funciton, setField, setOperator, setOperatorOption, setValue, setValueSrc, ...}
    onDragStart: prop_types_default.a.func,
    value: prop_types_default.a.any,
    //depends on widget
    valueSrc: prop_types_default.a.any,
    valueError: prop_types_default.a.any,
    operatorOptions: prop_types_default.a.object,
    reordableNodesCnt: prop_types_default.a.number,
    parentField: prop_types_default.a.string,
    //from RuleGroup
    //connected:
    dragging: prop_types_default.a.object,
    //{id, x, y, w, h}
    isDraggingTempo: prop_types_default.a.bool
  };
  var ConnectedRuleContainer = Object(external_ReactRedux_["connect"])(function (state) {
    return {
      dragging: state.dragging
    };
  })(RuleContainer);
  ConnectedRuleContainer.displayName = "ConnectedRuleContainer";
  return ConnectedRuleContainer;
});
// CONCATENATED MODULE: ./modules/components/containers/Draggable.jsx
function Draggable_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Draggable_typeof = function _typeof(obj) { return typeof obj; }; } else { Draggable_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Draggable_typeof(obj); }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function Draggable_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Draggable_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Draggable_createClass(Constructor, protoProps, staticProps) { if (protoProps) Draggable_defineProperties(Constructor.prototype, protoProps); if (staticProps) Draggable_defineProperties(Constructor, staticProps); return Constructor; }

function Draggable_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Draggable_setPrototypeOf(subClass, superClass); }

function Draggable_setPrototypeOf(o, p) { Draggable_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Draggable_setPrototypeOf(o, p); }

function Draggable_createSuper(Derived) { var hasNativeReflectConstruct = Draggable_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = Draggable_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = Draggable_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return Draggable_possibleConstructorReturn(this, result); }; }

function Draggable_possibleConstructorReturn(self, call) { if (call && (Draggable_typeof(call) === "object" || typeof call === "function")) { return call; } return Draggable_assertThisInitialized(self); }

function Draggable_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Draggable_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function Draggable_getPrototypeOf(o) { Draggable_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Draggable_getPrototypeOf(o); }




var Draggable_classNames = __webpack_require__(26);

/* harmony default export */ var containers_Draggable = (function (className) {
  return function (GroupOrRule) {
    var _class, _temp;

    return _temp = _class = /*#__PURE__*/function (_PureComponent) {
      Draggable_inherits(Draggable, _PureComponent);

      var _super = Draggable_createSuper(Draggable);

      function Draggable(props) {
        var _this;

        Draggable_classCallCheck(this, Draggable);

        _this = _super.call(this, props);

        _this.handleDraggerMouseDown = function (e) {
          var nodeId = _this.props.id;
          var dom = _this.wrapper.current;

          if (_this.props.onDragStart) {
            _this.props.onDragStart(nodeId, dom, e);
          }
        };

        _this.wrapper = /*#__PURE__*/external_React_default.a.createRef();
        return _this;
      }

      Draggable_createClass(Draggable, [{
        key: "render",
        value: function render() {
          var _this$props = this.props,
              isDraggingTempo = _this$props.isDraggingTempo,
              isDraggingMe = _this$props.isDraggingMe,
              dragging = _this$props.dragging,
              otherProps = _objectWithoutProperties(_this$props, ["isDraggingTempo", "isDraggingMe", "dragging"]);

          var styles = {};

          if (isDraggingMe && isDraggingTempo) {
            styles = {
              top: dragging.y,
              left: dragging.x,
              width: dragging.w
            };
          }

          var cn = Draggable_classNames(className, "group-or-rule", isDraggingMe && isDraggingTempo ? "qb-draggable" : null, isDraggingMe && !isDraggingTempo ? "qb-placeholder" : null);
          return /*#__PURE__*/external_React_default.a.createElement("div", {
            className: cn,
            style: styles,
            ref: this.wrapper,
            "data-id": this.props.id
          }, /*#__PURE__*/external_React_default.a.createElement(GroupOrRule, _extends({
            handleDraggerMouseDown: this.handleDraggerMouseDown,
            isDraggingMe: isDraggingMe,
            isDraggingTempo: isDraggingTempo
          }, otherProps)));
        }
      }]);

      return Draggable;
    }(external_React_["PureComponent"]), _class.propTypes = {
      isDraggingTempo: prop_types_default.a.bool,
      isDraggingMe: prop_types_default.a.bool,
      onDragStart: prop_types_default.a.func,
      dragging: prop_types_default.a.object //{id, x, y, w, h}

    }, _temp;
  };
});
// EXTERNAL MODULE: external "lodash/last"
var last_ = __webpack_require__(20);
var last_default = /*#__PURE__*/__webpack_require__.n(last_);

// EXTERNAL MODULE: external "lodash/keys"
var keys_ = __webpack_require__(17);
var keys_default = /*#__PURE__*/__webpack_require__.n(keys_);

// CONCATENATED MODULE: ./modules/components/Field.jsx
function Field_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Field_typeof = function _typeof(obj) { return typeof obj; }; } else { Field_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Field_typeof(obj); }

function Field_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function Field_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Field_ownKeys(Object(source), true).forEach(function (key) { Field_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Field_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function Field_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function Field_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Field_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Field_createClass(Constructor, protoProps, staticProps) { if (protoProps) Field_defineProperties(Constructor.prototype, protoProps); if (staticProps) Field_defineProperties(Constructor, staticProps); return Constructor; }

function Field_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Field_setPrototypeOf(subClass, superClass); }

function Field_setPrototypeOf(o, p) { Field_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Field_setPrototypeOf(o, p); }

function Field_createSuper(Derived) { var hasNativeReflectConstruct = Field_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = Field_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = Field_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return Field_possibleConstructorReturn(this, result); }; }

function Field_possibleConstructorReturn(self, call) { if (call && (Field_typeof(call) === "object" || typeof call === "function")) { return call; } return Field_assertThisInitialized(self); }

function Field_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Field_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function Field_getPrototypeOf(o) { Field_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Field_getPrototypeOf(o); }








var Field_Field = /*#__PURE__*/function (_PureComponent) {
  Field_inherits(Field, _PureComponent);

  var _super = Field_createSuper(Field);

  function Field(props) {
    var _this;

    Field_classCallCheck(this, Field);

    _this = _super.call(this, props);
    Object(stuff["m" /* useOnPropsChanged */])(Field_assertThisInitialized(_this));

    _this.onPropsChanged(props);

    return _this;
  }

  Field_createClass(Field, [{
    key: "onPropsChanged",
    value: function onPropsChanged(nextProps) {
      var prevProps = this.props;
      var keysForMeta = ["selectedField", "config", "parentField"];
      var needUpdateMeta = !this.meta || keysForMeta.map(function (k) {
        return nextProps[k] !== prevProps[k];
      }).filter(function (ch) {
        return ch;
      }).length > 0;

      if (needUpdateMeta) {
        this.meta = this.getMeta(nextProps);
      }
    }
  }, {
    key: "getMeta",
    value: function getMeta(_ref) {
      var selectedField = _ref.selectedField,
          config = _ref.config,
          parentField = _ref.parentField;
      var selectedKey = selectedField;
      var _config$settings = config.settings,
          maxLabelsLength = _config$settings.maxLabelsLength,
          fieldSeparatorDisplay = _config$settings.fieldSeparatorDisplay,
          fieldPlaceholder = _config$settings.fieldPlaceholder,
          fieldSeparator = _config$settings.fieldSeparator;
      var isFieldSelected = !!selectedField;
      var placeholder = !isFieldSelected ? Object(stuff["l" /* truncateString */])(fieldPlaceholder, maxLabelsLength) : null;
      var currField = isFieldSelected ? Object(configUtils["b" /* getFieldConfig */])(selectedKey, config) : null;
      var selectedOpts = currField || {};
      var selectedKeys = Object(configUtils["c" /* getFieldPath */])(selectedKey, config);
      var selectedPath = Object(configUtils["c" /* getFieldPath */])(selectedKey, config, true);
      var selectedLabel = this.getFieldLabel(currField, selectedKey, config);
      var partsLabels = Object(configUtils["d" /* getFieldPathLabels */])(selectedKey, config);
      var selectedFullLabel = partsLabels ? partsLabels.join(fieldSeparatorDisplay) : null;
      if (selectedFullLabel == selectedLabel || parentField) selectedFullLabel = null;
      var selectedAltLabel = selectedOpts.label2;
      var parentFieldPath = typeof parentField == "string" ? parentField.split(fieldSeparator) : parentField;
      var parentFieldConfig = parentField ? Object(configUtils["b" /* getFieldConfig */])(parentField, config) : null;
      var sourceFields = parentField ? parentFieldConfig && parentFieldConfig.subfields : config.fields;
      var items = this.buildOptions(parentFieldPath, config, sourceFields, parentFieldPath);
      return {
        placeholder: placeholder,
        items: items,
        parentField: parentField,
        selectedKey: selectedKey,
        selectedKeys: selectedKeys,
        selectedPath: selectedPath,
        selectedLabel: selectedLabel,
        selectedOpts: selectedOpts,
        selectedAltLabel: selectedAltLabel,
        selectedFullLabel: selectedFullLabel
      };
    }
  }, {
    key: "getFieldLabel",
    value: function getFieldLabel(fieldOpts, fieldKey, config) {
      if (!fieldKey) return null;
      var fieldSeparator = config.settings.fieldSeparator;
      var maxLabelsLength = config.settings.maxLabelsLength;
      var fieldParts = Array.isArray(fieldKey) ? fieldKey : fieldKey.split(fieldSeparator);
      var label = fieldOpts && fieldOpts.label || last_default()(fieldParts);
      label = Object(stuff["l" /* truncateString */])(label, maxLabelsLength);
      return label;
    }
  }, {
    key: "buildOptions",
    value: function buildOptions(parentFieldPath, config, fields) {
      var _this2 = this;

      var path = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      var optGroupLabel = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
      if (!fields) return null;
      var _config$settings2 = config.settings,
          fieldSeparator = _config$settings2.fieldSeparator,
          fieldSeparatorDisplay = _config$settings2.fieldSeparatorDisplay;
      var prefix = path ? path.join(fieldSeparator) + fieldSeparator : "";
      return keys_default()(fields).map(function (fieldKey) {
        var field = fields[fieldKey];

        var label = _this2.getFieldLabel(field, fieldKey, config);

        var partsLabels = Object(configUtils["d" /* getFieldPathLabels */])(prefix + fieldKey, config);
        var fullLabel = partsLabels.join(fieldSeparatorDisplay);
        if (fullLabel == label || parentFieldPath) fullLabel = null;
        var altLabel = field.label2;
        var tooltip = field.tooltip;
        var subpath = (path ? path : []).concat(fieldKey);
        var disabled = field.disabled;
        if (field.hideForSelect) return undefined;

        if (field.type == "!struct") {
          return {
            disabled: disabled,
            key: fieldKey,
            path: prefix + fieldKey,
            label: label,
            fullLabel: fullLabel,
            altLabel: altLabel,
            tooltip: tooltip,
            items: _this2.buildOptions(parentFieldPath, config, field.subfields, subpath, label)
          };
        } else {
          return {
            disabled: disabled,
            key: fieldKey,
            path: prefix + fieldKey,
            label: label,
            fullLabel: fullLabel,
            altLabel: altLabel,
            tooltip: tooltip,
            grouplabel: optGroupLabel
          };
        }
      }).filter(function (o) {
        return !!o;
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props = this.props,
          config = _this$props.config,
          customProps = _this$props.customProps,
          setField = _this$props.setField,
          readonly = _this$props.readonly;
      var renderField = config.settings.renderField;

      var renderProps = Field_objectSpread({
        config: config,
        customProps: customProps,
        readonly: readonly,
        setField: setField
      }, this.meta);

      return renderField(renderProps);
    }
  }]);

  return Field;
}(external_React_["PureComponent"]);

Field_Field.propTypes = {
  config: prop_types_default.a.object.isRequired,
  selectedField: prop_types_default.a.string,
  parentField: prop_types_default.a.string,
  customProps: prop_types_default.a.object,
  readonly: prop_types_default.a.bool,
  //actions
  setField: prop_types_default.a.func.isRequired
};

// EXTERNAL MODULE: external "lodash/pickBy"
var pickBy_ = __webpack_require__(29);
var pickBy_default = /*#__PURE__*/__webpack_require__.n(pickBy_);

// EXTERNAL MODULE: external "lodash/mapValues"
var mapValues_ = __webpack_require__(22);
var mapValues_default = /*#__PURE__*/__webpack_require__.n(mapValues_);

// CONCATENATED MODULE: ./modules/components/Operator.jsx
function Operator_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Operator_typeof = function _typeof(obj) { return typeof obj; }; } else { Operator_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Operator_typeof(obj); }

function Operator_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function Operator_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Operator_ownKeys(Object(source), true).forEach(function (key) { Operator_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Operator_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function Operator_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function Operator_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Operator_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Operator_createClass(Constructor, protoProps, staticProps) { if (protoProps) Operator_defineProperties(Constructor.prototype, protoProps); if (staticProps) Operator_defineProperties(Constructor, staticProps); return Constructor; }

function Operator_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Operator_setPrototypeOf(subClass, superClass); }

function Operator_setPrototypeOf(o, p) { Operator_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Operator_setPrototypeOf(o, p); }

function Operator_createSuper(Derived) { var hasNativeReflectConstruct = Operator_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = Operator_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = Operator_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return Operator_possibleConstructorReturn(this, result); }; }

function Operator_possibleConstructorReturn(self, call) { if (call && (Operator_typeof(call) === "object" || typeof call === "function")) { return call; } return Operator_assertThisInitialized(self); }

function Operator_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Operator_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function Operator_getPrototypeOf(o) { Operator_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Operator_getPrototypeOf(o); }









var Operator_Operator = /*#__PURE__*/function (_PureComponent) {
  Operator_inherits(Operator, _PureComponent);

  var _super = Operator_createSuper(Operator);

  function Operator(props) {
    var _this;

    Operator_classCallCheck(this, Operator);

    _this = _super.call(this, props);
    Object(stuff["m" /* useOnPropsChanged */])(Operator_assertThisInitialized(_this));

    _this.onPropsChanged(props);

    return _this;
  }

  Operator_createClass(Operator, [{
    key: "onPropsChanged",
    value: function onPropsChanged(nextProps) {
      var prevProps = this.props;
      var keysForMeta = ["config", "selectedField", "selectedOperator"];
      var needUpdateMeta = !this.meta || keysForMeta.map(function (k) {
        return nextProps[k] !== prevProps[k];
      }).filter(function (ch) {
        return ch;
      }).length > 0;

      if (needUpdateMeta) {
        this.meta = this.getMeta(nextProps);
      }
    }
  }, {
    key: "getMeta",
    value: function getMeta(_ref) {
      var config = _ref.config,
          selectedField = _ref.selectedField,
          selectedOperator = _ref.selectedOperator;
      var fieldConfig = Object(configUtils["b" /* getFieldConfig */])(selectedField, config);
      var operatorOptions = mapValues_default()(pickBy_default()(config.operators, function (item, key) {
        return fieldConfig && fieldConfig.operators && fieldConfig.operators.indexOf(key) !== -1;
      }), function (_opts, op) {
        return Object(configUtils["j" /* getOperatorConfig */])(config, op, selectedField);
      });
      var items = this.buildOptions(config, operatorOptions);
      var isOpSelected = !!selectedOperator;
      var currOp = isOpSelected ? operatorOptions[selectedOperator] : null;
      var selectedOpts = currOp || {};
      var placeholder = this.props.config.settings.operatorPlaceholder;
      var selectedKey = selectedOperator;
      var selectedKeys = isOpSelected ? [selectedKey] : null;
      var selectedPath = selectedKeys;
      var selectedLabel = selectedOpts.label;
      return {
        placeholder: placeholder,
        items: items,
        selectedKey: selectedKey,
        selectedKeys: selectedKeys,
        selectedPath: selectedPath,
        selectedLabel: selectedLabel,
        selectedOpts: selectedOpts
      };
    }
  }, {
    key: "buildOptions",
    value: function buildOptions(config, fields) {
      if (!fields) return null;
      return keys_default()(fields).map(function (fieldKey) {
        var field = fields[fieldKey];
        var label = field.label;
        return {
          key: fieldKey,
          path: fieldKey,
          label: label
        };
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props = this.props,
          config = _this$props.config,
          customProps = _this$props.customProps,
          setOperator = _this$props.setOperator,
          readonly = _this$props.readonly;
      var renderOperator = config.settings.renderOperator;

      var renderProps = Operator_objectSpread({
        config: config,
        customProps: customProps,
        readonly: readonly,
        setField: setOperator
      }, this.meta);

      return renderOperator(renderProps);
    }
  }]);

  return Operator;
}(external_React_["PureComponent"]);

Operator_Operator.propTypes = {
  config: prop_types_default.a.object.isRequired,
  selectedField: prop_types_default.a.string,
  selectedOperator: prop_types_default.a.string,
  readonly: prop_types_default.a.bool,
  //actions
  setOperator: prop_types_default.a.func.isRequired
};

// EXTERNAL MODULE: ./modules/components/Widget.jsx + 1 modules
var Widget = __webpack_require__(25);

// CONCATENATED MODULE: ./modules/components/containers/OperatorOptionsContainer.jsx
function OperatorOptionsContainer_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { OperatorOptionsContainer_typeof = function _typeof(obj) { return typeof obj; }; } else { OperatorOptionsContainer_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return OperatorOptionsContainer_typeof(obj); }

function OperatorOptionsContainer_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = OperatorOptionsContainer_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function OperatorOptionsContainer_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function OperatorOptionsContainer_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function OperatorOptionsContainer_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function OperatorOptionsContainer_createClass(Constructor, protoProps, staticProps) { if (protoProps) OperatorOptionsContainer_defineProperties(Constructor.prototype, protoProps); if (staticProps) OperatorOptionsContainer_defineProperties(Constructor, staticProps); return Constructor; }

function OperatorOptionsContainer_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) OperatorOptionsContainer_setPrototypeOf(subClass, superClass); }

function OperatorOptionsContainer_setPrototypeOf(o, p) { OperatorOptionsContainer_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return OperatorOptionsContainer_setPrototypeOf(o, p); }

function OperatorOptionsContainer_createSuper(Derived) { var hasNativeReflectConstruct = OperatorOptionsContainer_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = OperatorOptionsContainer_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = OperatorOptionsContainer_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return OperatorOptionsContainer_possibleConstructorReturn(this, result); }; }

function OperatorOptionsContainer_possibleConstructorReturn(self, call) { if (call && (OperatorOptionsContainer_typeof(call) === "object" || typeof call === "function")) { return call; } return OperatorOptionsContainer_assertThisInitialized(self); }

function OperatorOptionsContainer_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function OperatorOptionsContainer_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function OperatorOptionsContainer_getPrototypeOf(o) { OperatorOptionsContainer_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return OperatorOptionsContainer_getPrototypeOf(o); }




/* harmony default export */ var containers_OperatorOptionsContainer = (function (OperatorOptions) {
  var _class, _temp;

  return _temp = _class = /*#__PURE__*/function (_PureComponent) {
    OperatorOptionsContainer_inherits(OperatorOptionsContainer, _PureComponent);

    var _super = OperatorOptionsContainer_createSuper(OperatorOptionsContainer);

    function OperatorOptionsContainer() {
      OperatorOptionsContainer_classCallCheck(this, OperatorOptionsContainer);

      return _super.apply(this, arguments);
    }

    OperatorOptionsContainer_createClass(OperatorOptionsContainer, [{
      key: "render",
      value: function render() {
        if (!this.props.selectedOperator) return null;
        var operatorDefinitions = Object(configUtils["j" /* getOperatorConfig */])(this.props.config, this.props.selectedOperator, this.props.selectedField);

        if (typeof operatorDefinitions.options === "undefined") {
          return null;
        }

        var _operatorDefinitions$ = operatorDefinitions.options,
            optionsFactory = _operatorDefinitions$.factory,
            optionsProps = OperatorOptionsContainer_objectWithoutProperties(_operatorDefinitions$, ["factory"]);

        return /*#__PURE__*/external_React_default.a.createElement(OperatorOptions, {
          name: this.props.selectedOperator,
          config: this.props.config
        }, optionsFactory(Object.assign({}, optionsProps, {
          config: this.props.config,
          field: this.props.selectedField,
          operator: this.props.selectedOperator,
          options: this.props.operatorOptions,
          setOption: this.props.setOperatorOption,
          readonly: this.props.readonly
        })));
      }
    }]);

    return OperatorOptionsContainer;
  }(external_React_["PureComponent"]), _class.propTypes = {
    config: prop_types_default.a.object.isRequired,
    operatorOptions: prop_types_default.a.any.isRequired,
    //instanceOf(Immutable.Map)
    selectedField: prop_types_default.a.string.isRequired,
    selectedOperator: prop_types_default.a.string.isRequired,
    readonly: prop_types_default.a.bool,
    //actions
    setOperatorOption: prop_types_default.a.func.isRequired
  }, _temp;
});
// CONCATENATED MODULE: ./modules/components/OperatorOptions.jsx
function OperatorOptions_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { OperatorOptions_typeof = function _typeof(obj) { return typeof obj; }; } else { OperatorOptions_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return OperatorOptions_typeof(obj); }

var OperatorOptions_class, _class2, OperatorOptions_temp;

function OperatorOptions_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function OperatorOptions_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function OperatorOptions_createClass(Constructor, protoProps, staticProps) { if (protoProps) OperatorOptions_defineProperties(Constructor.prototype, protoProps); if (staticProps) OperatorOptions_defineProperties(Constructor, staticProps); return Constructor; }

function OperatorOptions_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) OperatorOptions_setPrototypeOf(subClass, superClass); }

function OperatorOptions_setPrototypeOf(o, p) { OperatorOptions_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return OperatorOptions_setPrototypeOf(o, p); }

function OperatorOptions_createSuper(Derived) { var hasNativeReflectConstruct = OperatorOptions_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = OperatorOptions_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = OperatorOptions_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return OperatorOptions_possibleConstructorReturn(this, result); }; }

function OperatorOptions_possibleConstructorReturn(self, call) { if (call && (OperatorOptions_typeof(call) === "object" || typeof call === "function")) { return call; } return OperatorOptions_assertThisInitialized(self); }

function OperatorOptions_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function OperatorOptions_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function OperatorOptions_getPrototypeOf(o) { OperatorOptions_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return OperatorOptions_getPrototypeOf(o); }





var OperatorOptions_OperatorOptions = containers_OperatorOptionsContainer(OperatorOptions_class = (OperatorOptions_temp = _class2 = /*#__PURE__*/function (_PureComponent) {
  OperatorOptions_inherits(OperatorOptions, _PureComponent);

  var _super = OperatorOptions_createSuper(OperatorOptions);

  function OperatorOptions() {
    OperatorOptions_classCallCheck(this, OperatorOptions);

    return _super.apply(this, arguments);
  }

  OperatorOptions_createClass(OperatorOptions, [{
    key: "render",
    value: function render() {
      return /*#__PURE__*/external_React_default.a.createElement("div", {
        className: "rule--operator rule--operator--".concat(this.props.name.toUpperCase())
      }, this.props.children);
    }
  }]);

  return OperatorOptions;
}(external_React_["PureComponent"]), _class2.propTypes = {
  config: prop_types_default.a.object.isRequired,
  name: prop_types_default.a.string.isRequired,
  children: prop_types_default.a.oneOfType([prop_types_default.a.array, prop_types_default.a.element])
}, OperatorOptions_temp)) || OperatorOptions_class;


// CONCATENATED MODULE: ./modules/components/Rule.jsx
function Rule_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Rule_typeof = function _typeof(obj) { return typeof obj; }; } else { Rule_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Rule_typeof(obj); }

var _dec, Rule_class, Rule_class2, Rule_temp;

function Rule_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function Rule_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Rule_ownKeys(Object(source), true).forEach(function (key) { Rule_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Rule_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function Rule_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function Rule_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Rule_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Rule_createClass(Constructor, protoProps, staticProps) { if (protoProps) Rule_defineProperties(Constructor.prototype, protoProps); if (staticProps) Rule_defineProperties(Constructor, staticProps); return Constructor; }

function Rule_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Rule_setPrototypeOf(subClass, superClass); }

function Rule_setPrototypeOf(o, p) { Rule_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Rule_setPrototypeOf(o, p); }

function Rule_createSuper(Derived) { var hasNativeReflectConstruct = Rule_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = Rule_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = Rule_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return Rule_possibleConstructorReturn(this, result); }; }

function Rule_possibleConstructorReturn(self, call) { if (call && (Rule_typeof(call) === "object" || typeof call === "function")) { return call; } return Rule_assertThisInitialized(self); }

function Rule_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Rule_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function Rule_getPrototypeOf(o) { Rule_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Rule_getPrototypeOf(o); }

function Rule_extends() { Rule_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return Rule_extends.apply(this, arguments); }

function Rule_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Rule_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function Rule_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }












var Rule_Col = function Col(_ref) {
  var children = _ref.children,
      props = Rule_objectWithoutProperties(_ref, ["children"]);

  return /*#__PURE__*/external_React_default.a.createElement("div", props, children);
};

var dummyFn = function dummyFn() {};

var Rule_DragIcon = function DragIcon() {
  return /*#__PURE__*/external_React_default.a.createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "gray",
    width: "18px",
    height: "18px"
  }, /*#__PURE__*/external_React_default.a.createElement("path", {
    d: "M0 0h24v24H0V0z",
    fill: "none"
  }), /*#__PURE__*/external_React_default.a.createElement("path", {
    d: "M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"
  }));
};

var Rule_ConfirmFn = function ConfirmFn(Cmp) {
  return function (props) {
    var useConfirm = props.config.settings.useConfirm;
    var confirmFn = useConfirm ? useConfirm() : null;
    return /*#__PURE__*/external_React_default.a.createElement(Cmp, Rule_extends({}, props, {
      confirmFn: confirmFn
    }));
  };
};

var Rule_Rule = (_dec = containers_Draggable("rule"), containers_RuleContainer(Rule_class = _dec(Rule_class = Rule_ConfirmFn(Rule_class = (Rule_temp = Rule_class2 = /*#__PURE__*/function (_PureComponent) {
  Rule_inherits(Rule, _PureComponent);

  var _super = Rule_createSuper(Rule);

  function Rule(props) {
    var _this;

    Rule_classCallCheck(this, Rule);

    _this = _super.call(this, props);

    _this.removeSelf = function () {
      var confirmFn = _this.props.confirmFn;
      var _this$props$config$se = _this.props.config.settings,
          renderConfirm = _this$props$config$se.renderConfirm,
          confirmOptions = _this$props$config$se.removeRuleConfirmOptions;

      var doRemove = function doRemove() {
        _this.props.removeSelf();
      };

      if (confirmOptions && !_this.isEmptyCurrentRule()) {
        renderConfirm(Rule_objectSpread(Rule_objectSpread({}, confirmOptions), {}, {
          onOk: doRemove,
          onCancel: null,
          confirmFn: confirmFn
        }));
      } else {
        doRemove();
      }
    };

    _this.isEmptyCurrentRule = function () {
      return !(_this.props.selectedField !== null && _this.props.selectedOperator !== null && _this.props.value.filter(function (val) {
        return val !== undefined;
      }).size > 0);
    };

    Object(stuff["m" /* useOnPropsChanged */])(Rule_assertThisInitialized(_this));

    _this.onPropsChanged(props);

    return _this;
  }

  Rule_createClass(Rule, [{
    key: "onPropsChanged",
    value: function onPropsChanged(nextProps) {
      var prevProps = this.props;
      var keysForMeta = ["selectedField", "selectedOperator", "config", "reordableNodesCnt"];
      var needUpdateMeta = !this.meta || keysForMeta.map(function (k) {
        return nextProps[k] !== prevProps[k];
      }).filter(function (ch) {
        return ch;
      }).length > 0;

      if (needUpdateMeta) {
        this.meta = this.getMeta(nextProps);
      }
    }
  }, {
    key: "getMeta",
    value: function getMeta(_ref2) {
      var selectedField = _ref2.selectedField,
          selectedOperator = _ref2.selectedOperator,
          config = _ref2.config,
          reordableNodesCnt = _ref2.reordableNodesCnt;
      var selectedFieldPartsLabels = Object(configUtils["d" /* getFieldPathLabels */])(selectedField, config);
      var selectedFieldConfig = Object(configUtils["b" /* getFieldConfig */])(selectedField, config);
      var isSelectedGroup = selectedFieldConfig && selectedFieldConfig.type == "!struct";
      var isFieldAndOpSelected = selectedField && selectedOperator && !isSelectedGroup;
      var selectedOperatorConfig = Object(configUtils["j" /* getOperatorConfig */])(config, selectedOperator, selectedField);
      var selectedOperatorHasOptions = selectedOperatorConfig && selectedOperatorConfig.options != null;
      var selectedFieldWidgetConfig = Object(configUtils["e" /* getFieldWidgetConfig */])(config, selectedField, selectedOperator) || {};
      var isOnlyValue = selectedField && selectedFieldConfig.valueSources.length == 1 && selectedFieldConfig.valueSources[0] == "value";
      var hideOperator = selectedFieldWidgetConfig.hideOperator && isOnlyValue;
      var showDragIcon = config.settings.canReorder && reordableNodesCnt > 1;
      var showOperator = selectedField && !hideOperator;
      var showOperatorLabel = selectedField && hideOperator && selectedFieldWidgetConfig.operatorInlineLabel;
      var showWidget = isFieldAndOpSelected;
      var showOperatorOptions = isFieldAndOpSelected && selectedOperatorHasOptions;
      return {
        selectedFieldPartsLabels: selectedFieldPartsLabels,
        selectedFieldWidgetConfig: selectedFieldWidgetConfig,
        showDragIcon: showDragIcon,
        showOperator: showOperator,
        showOperatorLabel: showOperatorLabel,
        showWidget: showWidget,
        showOperatorOptions: showOperatorOptions
      };
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props = this.props,
          config = _this$props.config,
          valueError = _this$props.valueError;
      var _this$meta = this.meta,
          selectedFieldPartsLabels = _this$meta.selectedFieldPartsLabels,
          selectedFieldWidgetConfig = _this$meta.selectedFieldWidgetConfig,
          showDragIcon = _this$meta.showDragIcon,
          showOperator = _this$meta.showOperator,
          showOperatorLabel = _this$meta.showOperatorLabel,
          showWidget = _this$meta.showWidget,
          showOperatorOptions = _this$meta.showOperatorOptions;
      var _config$settings = config.settings,
          deleteLabel = _config$settings.deleteLabel,
          renderBeforeWidget = _config$settings.renderBeforeWidget,
          renderAfterWidget = _config$settings.renderAfterWidget,
          renderSize = _config$settings.renderSize,
          immutableGroupsMode = _config$settings.immutableGroupsMode,
          immutableFieldsMode = _config$settings.immutableFieldsMode,
          immutableOpsMode = _config$settings.immutableOpsMode,
          immutableValuesMode = _config$settings.immutableValuesMode,
          renderRuleError = _config$settings.renderRuleError,
          showErrorMessage = _config$settings.showErrorMessage,
          Btn = _config$settings.renderButton;
      var field = /*#__PURE__*/external_React_default.a.createElement(Rule_FieldWrapper, {
        key: "field",
        classname: "rule--field",
        config: config,
        selectedField: this.props.selectedField,
        setField: !immutableOpsMode ? this.props.setField : dummyFn,
        parentField: this.props.parentField,
        readonly: immutableFieldsMode
      });
      var operator = /*#__PURE__*/external_React_default.a.createElement(Rule_OperatorWrapper, {
        key: "operator",
        config: config,
        selectedField: this.props.selectedField,
        selectedOperator: this.props.selectedOperator,
        setOperator: !immutableOpsMode ? this.props.setOperator : dummyFn,
        selectedFieldPartsLabels: selectedFieldPartsLabels,
        showOperator: showOperator,
        showOperatorLabel: showOperatorLabel,
        selectedFieldWidgetConfig: selectedFieldWidgetConfig,
        readonly: immutableOpsMode
      });
      var widget = showWidget && /*#__PURE__*/external_React_default.a.createElement(Rule_Col, {
        key: "widget-for-" + this.props.selectedOperator,
        className: "rule--value"
      }, /*#__PURE__*/external_React_default.a.createElement(Widget["a" /* default */], {
        key: "values",
        field: this.props.selectedField,
        operator: this.props.selectedOperator,
        value: this.props.value,
        valueSrc: this.props.valueSrc,
        valueError: valueError,
        config: config,
        setValue: !immutableValuesMode ? this.props.setValue : dummyFn,
        setValueSrc: !immutableValuesMode ? this.props.setValueSrc : dummyFn,
        readonly: immutableValuesMode
      }));
      var operatorOptions = showOperatorOptions && /*#__PURE__*/external_React_default.a.createElement(Rule_Col, {
        key: "op-options-for-" + this.props.selectedOperator,
        className: "rule--operator-options"
      }, /*#__PURE__*/external_React_default.a.createElement(OperatorOptions_OperatorOptions, {
        key: "operatorOptions",
        selectedField: this.props.selectedField,
        selectedOperator: this.props.selectedOperator,
        operatorOptions: this.props.operatorOptions,
        setOperatorOption: !immutableOpsMode ? this.props.setOperatorOption : dummyFn,
        config: config,
        readonly: immutableValuesMode
      }));
      var beforeWidget = renderBeforeWidget && /*#__PURE__*/external_React_default.a.createElement(Rule_Col, {
        key: "before-widget-for-" + this.props.selectedOperator,
        className: "rule--before-widget"
      }, typeof renderBeforeWidget === "function" ? renderBeforeWidget(this.props) : renderBeforeWidget);
      var afterWidget = renderAfterWidget && /*#__PURE__*/external_React_default.a.createElement(Rule_Col, {
        key: "after-widget-for-" + this.props.selectedOperator,
        className: "rule--after-widget"
      }, typeof renderAfterWidget === "function" ? renderAfterWidget(this.props) : renderAfterWidget);
      var oneValueError = valueError && valueError.toArray().filter(function (e) {
        return !!e;
      }).shift() || null;
      var error = showErrorMessage && oneValueError && /*#__PURE__*/external_React_default.a.createElement("div", {
        className: "rule--error"
      }, renderRuleError ? renderRuleError({
        error: oneValueError
      }) : oneValueError);
      var parts = [field, operator, beforeWidget, widget, afterWidget, operatorOptions];
      var drag = showDragIcon && /*#__PURE__*/external_React_default.a.createElement("span", {
        key: "rule-drag-icon",
        className: "qb-drag-handler rule--drag-handler",
        onMouseDown: this.props.handleDraggerMouseDown
      }, /*#__PURE__*/external_React_default.a.createElement(Rule_DragIcon, null), " ");
      var del = /*#__PURE__*/external_React_default.a.createElement("div", {
        key: "rule-header",
        className: "rule--header"
      }, !immutableGroupsMode && /*#__PURE__*/external_React_default.a.createElement(Btn, {
        type: "delRule",
        onClick: this.removeSelf,
        label: deleteLabel,
        config: config
      }));
      var body = /*#__PURE__*/external_React_default.a.createElement("div", {
        key: "rule-body",
        className: "rule--body"
      }, parts);
      return /*#__PURE__*/external_React_default.a.createElement(external_React_default.a.Fragment, null, drag, /*#__PURE__*/external_React_default.a.createElement("div", {
        className: "rule--body--wrapper"
      }, body, error), del);
    }
  }]);

  return Rule;
}(external_React_["PureComponent"]), Rule_class2.propTypes = {
  selectedField: prop_types_default.a.string,
  selectedOperator: prop_types_default.a.string,
  operatorOptions: prop_types_default.a.object,
  config: prop_types_default.a.object.isRequired,
  value: prop_types_default.a.any,
  //depends on widget
  valueSrc: prop_types_default.a.any,
  isDraggingMe: prop_types_default.a.bool,
  isDraggingTempo: prop_types_default.a.bool,
  parentField: prop_types_default.a.string,
  //from RuleGroup
  valueError: prop_types_default.a.any,
  //path: PropTypes.instanceOf(Immutable.List),
  //actions
  handleDraggerMouseDown: prop_types_default.a.func,
  setField: prop_types_default.a.func,
  setOperator: prop_types_default.a.func,
  setOperatorOption: prop_types_default.a.func,
  removeSelf: prop_types_default.a.func,
  setValue: prop_types_default.a.func,
  setValueSrc: prop_types_default.a.func,
  reordableNodesCnt: prop_types_default.a.number
}, Rule_temp)) || Rule_class) || Rule_class) || Rule_class);
var Rule_FieldWrapper = /*#__PURE__*/function (_PureComponent2) {
  Rule_inherits(FieldWrapper, _PureComponent2);

  var _super2 = Rule_createSuper(FieldWrapper);

  function FieldWrapper() {
    Rule_classCallCheck(this, FieldWrapper);

    return _super2.apply(this, arguments);
  }

  Rule_createClass(FieldWrapper, [{
    key: "render",
    value: function render() {
      var _this$props2 = this.props,
          config = _this$props2.config,
          selectedField = _this$props2.selectedField,
          setField = _this$props2.setField,
          parentField = _this$props2.parentField,
          classname = _this$props2.classname,
          readonly = _this$props2.readonly;
      return /*#__PURE__*/external_React_default.a.createElement(Rule_Col, {
        className: classname
      }, config.settings.showLabels && /*#__PURE__*/external_React_default.a.createElement("label", {
        className: "rule--label"
      }, config.settings.fieldLabel), /*#__PURE__*/external_React_default.a.createElement(Field_Field, {
        config: config,
        selectedField: selectedField,
        parentField: parentField,
        setField: setField,
        customProps: config.settings.customFieldSelectProps,
        readonly: readonly
      }));
    }
  }]);

  return FieldWrapper;
}(external_React_["PureComponent"]);

var Rule_OperatorWrapper = /*#__PURE__*/function (_PureComponent3) {
  Rule_inherits(OperatorWrapper, _PureComponent3);

  var _super3 = Rule_createSuper(OperatorWrapper);

  function OperatorWrapper() {
    Rule_classCallCheck(this, OperatorWrapper);

    return _super3.apply(this, arguments);
  }

  Rule_createClass(OperatorWrapper, [{
    key: "render",
    value: function render() {
      var _this$props3 = this.props,
          config = _this$props3.config,
          selectedField = _this$props3.selectedField,
          selectedOperator = _this$props3.selectedOperator,
          setOperator = _this$props3.setOperator,
          selectedFieldPartsLabels = _this$props3.selectedFieldPartsLabels,
          showOperator = _this$props3.showOperator,
          showOperatorLabel = _this$props3.showOperatorLabel,
          selectedFieldWidgetConfig = _this$props3.selectedFieldWidgetConfig,
          readonly = _this$props3.readonly;
      var operator = showOperator && /*#__PURE__*/external_React_default.a.createElement(Rule_Col, {
        key: "operators-for-" + (selectedFieldPartsLabels || []).join("_"),
        className: "rule--operator"
      }, config.settings.showLabels && /*#__PURE__*/external_React_default.a.createElement("label", {
        className: "rule--label"
      }, config.settings.operatorLabel), /*#__PURE__*/external_React_default.a.createElement(Operator_Operator, {
        key: "operator",
        config: config,
        selectedField: selectedField,
        selectedOperator: selectedOperator,
        setOperator: setOperator,
        readonly: readonly
      }));
      var hiddenOperator = showOperatorLabel && /*#__PURE__*/external_React_default.a.createElement(Rule_Col, {
        key: "operators-for-" + (selectedFieldPartsLabels || []).join("_"),
        className: "rule--operator"
      }, /*#__PURE__*/external_React_default.a.createElement("div", {
        className: "rule--operator"
      }, config.settings.showLabels ? /*#__PURE__*/external_React_default.a.createElement("label", {
        className: "rule--label"
      }, "\xA0") : null, /*#__PURE__*/external_React_default.a.createElement("span", null, selectedFieldWidgetConfig.operatorInlineLabel)));
      return [operator, hiddenOperator];
    }
  }]);

  return OperatorWrapper;
}(external_React_["PureComponent"]);

/* harmony default export */ var components_Rule = (Rule_Rule);
// EXTERNAL MODULE: external "lodash/startsWith"
var startsWith_ = __webpack_require__(30);
var startsWith_default = /*#__PURE__*/__webpack_require__.n(startsWith_);

// CONCATENATED MODULE: ./modules/components/containers/GroupContainer.jsx
function GroupContainer_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { GroupContainer_typeof = function _typeof(obj) { return typeof obj; }; } else { GroupContainer_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return GroupContainer_typeof(obj); }

function GroupContainer_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function GroupContainer_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function GroupContainer_createClass(Constructor, protoProps, staticProps) { if (protoProps) GroupContainer_defineProperties(Constructor.prototype, protoProps); if (staticProps) GroupContainer_defineProperties(Constructor, staticProps); return Constructor; }

function GroupContainer_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) GroupContainer_setPrototypeOf(subClass, superClass); }

function GroupContainer_setPrototypeOf(o, p) { GroupContainer_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return GroupContainer_setPrototypeOf(o, p); }

function GroupContainer_createSuper(Derived) { var hasNativeReflectConstruct = GroupContainer_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = GroupContainer_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = GroupContainer_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return GroupContainer_possibleConstructorReturn(this, result); }; }

function GroupContainer_possibleConstructorReturn(self, call) { if (call && (GroupContainer_typeof(call) === "object" || typeof call === "function")) { return call; } return GroupContainer_assertThisInitialized(self); }

function GroupContainer_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function GroupContainer_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function GroupContainer_getPrototypeOf(o) { GroupContainer_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return GroupContainer_getPrototypeOf(o); }







/* harmony default export */ var containers_GroupContainer = (function (Group) {
  var GroupContainer = /*#__PURE__*/function (_Component) {
    GroupContainer_inherits(GroupContainer, _Component);

    var _super = GroupContainer_createSuper(GroupContainer);

    function GroupContainer(props) {
      var _this;

      GroupContainer_classCallCheck(this, GroupContainer);

      _this = _super.call(this, props);

      _this.setConjunction = function () {
        var conj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

        _this.props.actions.setConjunction(_this.props.path, conj);
      };

      _this.setNot = function () {
        var not = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

        _this.props.actions.setNot(_this.props.path, not);
      };

      _this.dummyFn = function () {};

      _this.removeSelf = function () {
        _this.props.actions.removeGroup(_this.props.path);
      };

      _this.addGroup = function () {
        _this.props.actions.addGroup(_this.props.path);
      };

      _this.addRule = function () {
        _this.props.actions.addRule(_this.props.path);
      };

      _this.setField = function (field) {
        _this.props.actions.setField(_this.props.path, field);
      };

      Object(stuff["m" /* useOnPropsChanged */])(GroupContainer_assertThisInitialized(_this));
      _this.conjunctionOptions = _this._getConjunctionOptions(props);
      _this.dummyFn.isDummyFn = true;
      return _this;
    }

    GroupContainer_createClass(GroupContainer, [{
      key: "shouldComponentUpdate",
      value: function shouldComponentUpdate(nextProps, nextState) {
        var prevProps = this.props;
        var prevState = this.state;
        var should = Object(renderUtils["b" /* pureShouldComponentUpdate */])(this)(nextProps, nextState);

        if (should) {
          if (prevState == nextState && prevProps != nextProps) {
            var draggingId = nextProps.dragging.id || prevProps.dragging.id;
            var isDraggingMe = draggingId == nextProps.id;
            var chs = [];

            for (var k in nextProps) {
              var changed = nextProps[k] != prevProps[k];

              if (k == "dragging" && !isDraggingMe) {
                changed = false; //dragging another item -> ignore
              }

              if (changed) {
                chs.push(k);
              }
            }

            if (!chs.length) should = false;
          }
        }

        return should;
      }
    }, {
      key: "onPropsChanged",
      value: function onPropsChanged(nextProps) {
        var config = nextProps.config,
            id = nextProps.id,
            conjunction = nextProps.conjunction;
        var oldConfig = this.props.config;
        var oldConjunction = this.props.conjunction;

        if (oldConfig != config || oldConjunction != conjunction) {
          this.conjunctionOptions = this._getConjunctionOptions(nextProps);
        }
      }
    }, {
      key: "_getConjunctionOptions",
      value: function _getConjunctionOptions(props) {
        return mapValues_default()(props.config.conjunctions, function (item, index) {
          return {
            id: "conjunction-".concat(props.id, "-").concat(index),
            name: "conjunction[".concat(props.id, "]"),
            key: index,
            label: item.label,
            checked: index === props.conjunction
          };
        });
      }
    }, {
      key: "render",
      value: function render() {
        var isDraggingMe = this.props.dragging.id == this.props.id;
        var currentNesting = this.props.path.size;
        var maxNesting = this.props.config.settings.maxNesting;
        var isInDraggingTempo = !isDraggingMe && this.props.isDraggingTempo; // Don't allow nesting further than the maximum configured depth and don't
        // allow removal of the root group.

        var allowFurtherNesting = typeof maxNesting === "undefined" || currentNesting < maxNesting;
        var isRoot = currentNesting == 1;
        return /*#__PURE__*/external_React_default.a.createElement("div", {
          className: "group-or-rule-container group-container",
          "data-id": this.props.id
        }, [isDraggingMe ? /*#__PURE__*/external_React_default.a.createElement(Group, {
          key: "dragging",
          id: this.props.id,
          isDraggingMe: true,
          isDraggingTempo: true,
          dragging: this.props.dragging,
          isRoot: isRoot,
          allowFurtherNesting: allowFurtherNesting,
          conjunctionOptions: this.conjunctionOptions,
          not: this.props.not,
          selectedConjunction: this.props.conjunction,
          setConjunction: this.dummyFn,
          setNot: this.dummyFn,
          removeSelf: this.dummyFn,
          addGroup: this.dummyFn,
          addRule: this.dummyFn,
          setField: this.dummyFn,
          config: this.props.config,
          children1: this.props.children1,
          actions: this.props.actions //tree={this.props.tree}
          ,
          reordableNodesCnt: this.props.reordableNodesCnt,
          totalRulesCnt: this.props.totalRulesCnt,
          selectedField: this.props.field || null,
          parentField: this.props.parentField || null
        }) : null, /*#__PURE__*/external_React_default.a.createElement(Group, {
          key: this.props.id,
          id: this.props.id,
          isDraggingMe: isDraggingMe,
          isDraggingTempo: isInDraggingTempo,
          onDragStart: this.props.onDragStart,
          isRoot: isRoot,
          allowFurtherNesting: allowFurtherNesting,
          conjunctionOptions: this.conjunctionOptions,
          not: this.props.not,
          selectedConjunction: this.props.conjunction,
          setConjunction: isInDraggingTempo ? this.dummyFn : this.setConjunction,
          setNot: isInDraggingTempo ? this.dummyFn : this.setNot,
          removeSelf: isInDraggingTempo ? this.dummyFn : this.removeSelf,
          addGroup: isInDraggingTempo ? this.dummyFn : this.addGroup,
          addRule: isInDraggingTempo ? this.dummyFn : this.addRule,
          setField: isInDraggingTempo ? this.dummyFn : this.setField,
          config: this.props.config,
          children1: this.props.children1,
          actions: this.props.actions //tree={this.props.tree}
          ,
          reordableNodesCnt: this.props.reordableNodesCnt,
          totalRulesCnt: this.props.totalRulesCnt,
          selectedField: this.props.field || null,
          parentField: this.props.parentField || null
        })]);
      }
    }]);

    return GroupContainer;
  }(external_React_["Component"]);

  GroupContainer.propTypes = {
    //tree: PropTypes.instanceOf(Immutable.Map).isRequired,
    config: prop_types_default.a.object.isRequired,
    actions: prop_types_default.a.object.isRequired,
    //{setConjunction: Funciton, removeGroup, addGroup, addRule, ...}
    path: prop_types_default.a.any.isRequired,
    //instanceOf(Immutable.List)
    id: prop_types_default.a.string.isRequired,
    not: prop_types_default.a.bool,
    conjunction: prop_types_default.a.string,
    children1: prop_types_default.a.any,
    //instanceOf(Immutable.OrderedMap)
    onDragStart: prop_types_default.a.func,
    reordableNodesCnt: prop_types_default.a.number,
    selectedField: prop_types_default.a.string,
    // for RuleGroup
    parentField: prop_types_default.a.string,
    //from RuleGroup
    //connected:
    dragging: prop_types_default.a.object,
    //{id, x, y, w, h}
    isDraggingTempo: prop_types_default.a.bool
  };
  var ConnectedGroupContainer = Object(external_ReactRedux_["connect"])(function (state) {
    return {
      dragging: state.dragging
    };
  })(GroupContainer);
  ConnectedGroupContainer.displayName = "ConnectedGroupContainer";
  return ConnectedGroupContainer;
});
// CONCATENATED MODULE: ./modules/components/GroupActions.jsx
function GroupActions_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { GroupActions_typeof = function _typeof(obj) { return typeof obj; }; } else { GroupActions_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return GroupActions_typeof(obj); }

function GroupActions_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function GroupActions_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function GroupActions_createClass(Constructor, protoProps, staticProps) { if (protoProps) GroupActions_defineProperties(Constructor.prototype, protoProps); if (staticProps) GroupActions_defineProperties(Constructor, staticProps); return Constructor; }

function GroupActions_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) GroupActions_setPrototypeOf(subClass, superClass); }

function GroupActions_setPrototypeOf(o, p) { GroupActions_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return GroupActions_setPrototypeOf(o, p); }

function GroupActions_createSuper(Derived) { var hasNativeReflectConstruct = GroupActions_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = GroupActions_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = GroupActions_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return GroupActions_possibleConstructorReturn(this, result); }; }

function GroupActions_possibleConstructorReturn(self, call) { if (call && (GroupActions_typeof(call) === "object" || typeof call === "function")) { return call; } return GroupActions_assertThisInitialized(self); }

function GroupActions_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function GroupActions_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function GroupActions_getPrototypeOf(o) { GroupActions_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return GroupActions_getPrototypeOf(o); }


var groupActionsPositionList = {
  topLeft: "group--actions--tl",
  topCenter: "group--actions--tc",
  topRight: "group--actions--tr",
  bottomLeft: "group--actions--bl",
  bottomCenter: "group--actions--bc",
  bottomRight: "group--actions--br"
};
var defaultPosition = "topRight";
var GroupActions_GroupActions = /*#__PURE__*/function (_PureComponent) {
  GroupActions_inherits(GroupActions, _PureComponent);

  var _super = GroupActions_createSuper(GroupActions);

  function GroupActions() {
    GroupActions_classCallCheck(this, GroupActions);

    return _super.apply(this, arguments);
  }

  GroupActions_createClass(GroupActions, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          config = _this$props.config,
          addRule = _this$props.addRule,
          addGroup = _this$props.addGroup,
          canAddGroup = _this$props.canAddGroup,
          canAddRule = _this$props.canAddRule,
          canDeleteGroup = _this$props.canDeleteGroup,
          removeSelf = _this$props.removeSelf;
      var _config$settings = config.settings,
          immutableGroupsMode = _config$settings.immutableGroupsMode,
          addRuleLabel = _config$settings.addRuleLabel,
          addGroupLabel = _config$settings.addGroupLabel,
          delGroupLabel = _config$settings.delGroupLabel,
          groupActionsPosition = _config$settings.groupActionsPosition,
          Btn = _config$settings.renderButton,
          BtnGrp = _config$settings.renderButtonGroup;
      var position = groupActionsPositionList[groupActionsPosition || defaultPosition];
      var addRuleBtn = !immutableGroupsMode && canAddRule && /*#__PURE__*/external_React_default.a.createElement(Btn, {
        type: "addRule",
        onClick: addRule,
        label: addRuleLabel,
        config: config
      });
      var addGroupBtn = !immutableGroupsMode && canAddGroup && /*#__PURE__*/external_React_default.a.createElement(Btn, {
        type: "addGroup",
        onClick: addGroup,
        label: addGroupLabel,
        config: config
      });
      var delGroupBtn = !immutableGroupsMode && canDeleteGroup && /*#__PURE__*/external_React_default.a.createElement(Btn, {
        type: "delGroup",
        onClick: removeSelf,
        label: delGroupLabel,
        config: config
      });
      return /*#__PURE__*/external_React_default.a.createElement("div", {
        className: "group--actions ".concat(position)
      }, /*#__PURE__*/external_React_default.a.createElement(BtnGrp, {
        config: config
      }, addRuleBtn, addGroupBtn, delGroupBtn));
    }
  }]);

  return GroupActions;
}(external_React_["PureComponent"]);
// CONCATENATED MODULE: ./modules/components/Group.jsx
function Group_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Group_typeof = function _typeof(obj) { return typeof obj; }; } else { Group_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Group_typeof(obj); }

function Group_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function Group_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { Group_ownKeys(Object(source), true).forEach(function (key) { Group_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { Group_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function Group_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function Group_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Group_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Group_createClass(Constructor, protoProps, staticProps) { if (protoProps) Group_defineProperties(Constructor.prototype, protoProps); if (staticProps) Group_defineProperties(Constructor, staticProps); return Constructor; }

function Group_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Group_setPrototypeOf(subClass, superClass); }

function Group_setPrototypeOf(o, p) { Group_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Group_setPrototypeOf(o, p); }

function Group_createSuper(Derived) { var hasNativeReflectConstruct = Group_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = Group_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = Group_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return Group_possibleConstructorReturn(this, result); }; }

function Group_possibleConstructorReturn(self, call) { if (call && (Group_typeof(call) === "object" || typeof call === "function")) { return call; } return Group_assertThisInitialized(self); }

function Group_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Group_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function Group_getPrototypeOf(o) { Group_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Group_getPrototypeOf(o); }

function Group_extends() { Group_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return Group_extends.apply(this, arguments); }







var Group_classNames = __webpack_require__(26);



var Group_defaultPosition = "topRight";

var Group_dummyFn = function dummyFn() {};

var Group_DragIcon = function DragIcon() {
  return /*#__PURE__*/external_React_default.a.createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "gray",
    width: "18px",
    height: "18px"
  }, /*#__PURE__*/external_React_default.a.createElement("path", {
    d: "M0 0h24v24H0V0z",
    fill: "none"
  }), /*#__PURE__*/external_React_default.a.createElement("path", {
    d: "M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"
  }));
};

var Group_ConfirmFn = function ConfirmFn(Cmp) {
  return function (props) {
    var useConfirm = props.config.settings.useConfirm;
    var confirmFn = useConfirm ? useConfirm() : null;
    return /*#__PURE__*/external_React_default.a.createElement(Cmp, Group_extends({}, props, {
      confirmFn: confirmFn
    }));
  };
};

var Group_Group = /*#__PURE__*/function (_PureComponent) {
  Group_inherits(Group, _PureComponent);

  var _super = Group_createSuper(Group);

  function Group(props) {
    var _this;

    Group_classCallCheck(this, Group);

    _this = _super.call(this, props);

    _this.childrenClassName = function () {
      return "";
    };

    _this.renderBeforeActions = function () {
      var BeforeActions = _this.props.config.settings.renderBeforeActions;
      if (BeforeActions == undefined) return null;
      return typeof BeforeActions === "function" ? /*#__PURE__*/external_React_default.a.createElement(BeforeActions, _this.props) : BeforeActions;
    };

    _this.renderAfterActions = function () {
      var AfterActions = _this.props.config.settings.renderAfterActions;
      if (AfterActions == undefined) return null;
      return typeof AfterActions === "function" ? /*#__PURE__*/external_React_default.a.createElement(AfterActions, _this.props) : AfterActions;
    };

    _this.canAddGroup = function () {
      return _this.props.allowFurtherNesting;
    };

    _this.canAddRule = function () {
      var maxNumberOfRules = _this.props.config.settings.maxNumberOfRules;
      var totalRulesCnt = _this.props.totalRulesCnt;

      if (maxNumberOfRules) {
        return totalRulesCnt < maxNumberOfRules;
      }

      return true;
    };

    _this.canDeleteGroup = function () {
      return !_this.props.isRoot;
    };

    _this.removeSelf = _this.removeSelf.bind(Group_assertThisInitialized(_this));
    return _this;
  }

  Group_createClass(Group, [{
    key: "isGroupTopPosition",
    value: function isGroupTopPosition() {
      return startsWith_default()(this.props.config.settings.groupActionsPosition || Group_defaultPosition, "top");
    }
  }, {
    key: "removeSelf",
    value: function removeSelf() {
      var _this2 = this;

      var confirmFn = this.props.confirmFn;
      var _this$props$config$se = this.props.config.settings,
          renderConfirm = _this$props$config$se.renderConfirm,
          confirmOptions = _this$props$config$se.removeGroupConfirmOptions;

      var doRemove = function doRemove() {
        _this2.props.removeSelf();
      };

      if (confirmOptions && !this.isEmptyCurrentGroup()) {
        renderConfirm(Group_objectSpread(Group_objectSpread({}, confirmOptions), {}, {
          onOk: doRemove,
          onCancel: null,
          confirmFn: confirmFn
        }));
      } else {
        doRemove();
      }
    }
  }, {
    key: "isEmptyCurrentGroup",
    value: function isEmptyCurrentGroup() {
      var children = this.props.children1;
      return children.size == 0 || children.size == 1 && this.isEmpty(children.first());
    }
  }, {
    key: "isEmpty",
    value: function isEmpty(item) {
      return item.get("type") == "group" || item.get("type") == "rule_group" ? this.isEmptyGroup(item) : this.isEmptyRule(item);
    }
  }, {
    key: "isEmptyGroup",
    value: function isEmptyGroup(group) {
      var children = group.get("children1");
      return children.size == 0 || children.size == 1 && this.isEmpty(children.first());
    }
  }, {
    key: "isEmptyRule",
    value: function isEmptyRule(rule) {
      var properties = rule.get("properties");
      return !(properties.get("field") !== null && properties.get("operator") !== null && properties.get("value").filter(function (val) {
        return val !== undefined;
      }).size > 0);
    }
  }, {
    key: "render",
    value: function render() {
      return /*#__PURE__*/external_React_default.a.createElement(external_React_default.a.Fragment, null, this.renderHeaderWrapper(), this.renderChildrenWrapper(), this.renderFooterWrapper());
    }
  }, {
    key: "renderChildrenWrapper",
    value: function renderChildrenWrapper() {
      var _this$props = this.props,
          conjunctionOptions = _this$props.conjunctionOptions,
          children1 = _this$props.children1,
          config = _this$props.config;
      var conjunctionCount = Object.keys(conjunctionOptions).length;
      var showConjs = conjunctionCount > 1 || config.settings.showNot;
      return children1 && /*#__PURE__*/external_React_default.a.createElement("div", {
        key: "group-children",
        className: Group_classNames("group--children", !showConjs ? "hide--conjs" : "", children1.size < 2 && config.settings.hideConjForOne ? "hide--line" : "", children1.size < 2 ? "one--child" : "", this.childrenClassName())
      }, this.renderChildren());
    }
  }, {
    key: "renderHeaderWrapper",
    value: function renderHeaderWrapper() {
      var isGroupTopPosition = this.isGroupTopPosition();
      return /*#__PURE__*/external_React_default.a.createElement("div", {
        key: "group-header",
        className: "group--header"
      }, this.renderHeader(), isGroupTopPosition && this.renderBeforeActions(), isGroupTopPosition && this.renderActions(), isGroupTopPosition && this.renderAfterActions());
    }
  }, {
    key: "renderFooterWrapper",
    value: function renderFooterWrapper() {
      var isGroupTopPosition = this.isGroupTopPosition();
      return !isGroupTopPosition && /*#__PURE__*/external_React_default.a.createElement("div", {
        key: "group-footer",
        className: "group--footer"
      }, this.renderBeforeActions(), this.renderActions(), this.renderAfterActions());
    }
  }, {
    key: "renderActions",
    value: function renderActions() {
      var _this$props2 = this.props,
          config = _this$props2.config,
          addRule = _this$props2.addRule,
          addGroup = _this$props2.addGroup;
      return /*#__PURE__*/external_React_default.a.createElement(GroupActions_GroupActions, {
        config: config,
        addRule: addRule,
        addGroup: addGroup,
        canAddGroup: this.canAddGroup(),
        canAddRule: this.canAddRule(),
        canDeleteGroup: this.canDeleteGroup(),
        removeSelf: this.removeSelf
      });
    }
  }, {
    key: "renderChildren",
    value: function renderChildren() {
      var children1 = this.props.children1;
      return children1 ? children1.map(this.renderItem.bind(this)).toList() : null;
    }
  }, {
    key: "renderItem",
    value: function renderItem(item) {
      var props = this.props;
      var config = props.config,
          actions = props.actions,
          onDragStart = props.onDragStart;
      var isRuleGroup = item.get("type") == "group" && item.getIn(["properties", "field"]) != null;
      var type = isRuleGroup ? "rule_group" : item.get("type");
      return /*#__PURE__*/external_React_default.a.createElement(components_Item, Group_extends({}, this.extraPropsForItem(item), {
        key: item.get("id"),
        id: item.get("id") //path={props.path.push(item.get('id'))}
        ,
        path: item.get("path"),
        type: type,
        properties: item.get("properties"),
        config: config,
        actions: actions,
        children1: item.get("children1") //tree={props.tree}
        ,
        reordableNodesCnt: this.reordableNodesCnt(),
        totalRulesCnt: this.props.totalRulesCnt,
        onDragStart: onDragStart,
        isDraggingTempo: this.props.isDraggingTempo
      }));
    }
  }, {
    key: "extraPropsForItem",
    value: function extraPropsForItem(_item) {
      return {};
    }
  }, {
    key: "reordableNodesCnt",
    value: function reordableNodesCnt() {
      return this.props.reordableNodesCnt;
    }
  }, {
    key: "renderDrag",
    value: function renderDrag() {
      var _this$props3 = this.props,
          config = _this$props3.config,
          isRoot = _this$props3.isRoot,
          reordableNodesCnt = _this$props3.reordableNodesCnt,
          handleDraggerMouseDown = _this$props3.handleDraggerMouseDown;
      var showDragIcon = config.settings.canReorder && !isRoot && reordableNodesCnt > 1;
      var drag = showDragIcon && /*#__PURE__*/external_React_default.a.createElement("span", {
        key: "group-drag-icon",
        className: "qb-drag-handler group--drag-handler",
        onMouseDown: handleDraggerMouseDown
      }, /*#__PURE__*/external_React_default.a.createElement(Group_DragIcon, null), " ");
      return drag;
    }
  }, {
    key: "renderConjs",
    value: function renderConjs() {
      var _this$props4 = this.props,
          config = _this$props4.config,
          children1 = _this$props4.children1,
          id = _this$props4.id,
          selectedConjunction = _this$props4.selectedConjunction,
          setConjunction = _this$props4.setConjunction,
          conjunctionOptions = _this$props4.conjunctionOptions,
          not = _this$props4.not,
          setNot = _this$props4.setNot;
      var _config$settings = config.settings,
          immutableGroupsMode = _config$settings.immutableGroupsMode,
          Conjs = _config$settings.renderConjs,
          showNot = _config$settings.showNot;
      var conjunctionCount = Object.keys(conjunctionOptions).length;
      var showConjs = conjunctionCount > 1 || showNot;
      if (!showConjs) return null;
      if (!children1.size) return null;
      var renderProps = {
        disabled: children1.size < 2,
        readonly: immutableGroupsMode,
        selectedConjunction: selectedConjunction,
        setConjunction: immutableGroupsMode ? Group_dummyFn : setConjunction,
        conjunctionOptions: conjunctionOptions,
        config: config,
        not: not || false,
        id: id,
        setNot: immutableGroupsMode ? Group_dummyFn : setNot
      };
      return /*#__PURE__*/external_React_default.a.createElement(Conjs, renderProps);
    }
  }, {
    key: "renderHeader",
    value: function renderHeader() {
      return /*#__PURE__*/external_React_default.a.createElement("div", {
        className: Group_classNames("group--conjunctions" // children1.size < 2 && config.settings.hideConjForOne ? 'hide--conj' : ''
        )
      }, this.renderConjs(), this.renderDrag());
    }
  }]);

  return Group;
}(external_React_["PureComponent"]);
Group_Group.propTypes = {
  //tree: PropTypes.instanceOf(Immutable.Map).isRequired,
  reordableNodesCnt: prop_types_default.a.number,
  conjunctionOptions: prop_types_default.a.object.isRequired,
  allowFurtherNesting: prop_types_default.a.bool.isRequired,
  isRoot: prop_types_default.a.bool.isRequired,
  not: prop_types_default.a.bool,
  selectedConjunction: prop_types_default.a.string,
  config: prop_types_default.a.object.isRequired,
  id: prop_types_default.a.string.isRequired,
  path: prop_types_default.a.any,
  //instanceOf(Immutable.List)
  children1: prop_types_default.a.any,
  //instanceOf(Immutable.OrderedMap)
  isDraggingMe: prop_types_default.a.bool,
  isDraggingTempo: prop_types_default.a.bool,
  //actions
  handleDraggerMouseDown: prop_types_default.a.func,
  onDragStart: prop_types_default.a.func,
  addRule: prop_types_default.a.func.isRequired,
  addGroup: prop_types_default.a.func.isRequired,
  removeSelf: prop_types_default.a.func.isRequired,
  setConjunction: prop_types_default.a.func.isRequired,
  setNot: prop_types_default.a.func.isRequired,
  actions: prop_types_default.a.object.isRequired
};
/* harmony default export */ var components_Group = (containers_GroupContainer(containers_Draggable("group")(Group_ConfirmFn(Group_Group))));
// CONCATENATED MODULE: ./modules/components/RuleGroupActions.jsx
function RuleGroupActions_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { RuleGroupActions_typeof = function _typeof(obj) { return typeof obj; }; } else { RuleGroupActions_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return RuleGroupActions_typeof(obj); }

function RuleGroupActions_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function RuleGroupActions_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function RuleGroupActions_createClass(Constructor, protoProps, staticProps) { if (protoProps) RuleGroupActions_defineProperties(Constructor.prototype, protoProps); if (staticProps) RuleGroupActions_defineProperties(Constructor, staticProps); return Constructor; }

function RuleGroupActions_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) RuleGroupActions_setPrototypeOf(subClass, superClass); }

function RuleGroupActions_setPrototypeOf(o, p) { RuleGroupActions_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return RuleGroupActions_setPrototypeOf(o, p); }

function RuleGroupActions_createSuper(Derived) { var hasNativeReflectConstruct = RuleGroupActions_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = RuleGroupActions_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = RuleGroupActions_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return RuleGroupActions_possibleConstructorReturn(this, result); }; }

function RuleGroupActions_possibleConstructorReturn(self, call) { if (call && (RuleGroupActions_typeof(call) === "object" || typeof call === "function")) { return call; } return RuleGroupActions_assertThisInitialized(self); }

function RuleGroupActions_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function RuleGroupActions_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function RuleGroupActions_getPrototypeOf(o) { RuleGroupActions_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return RuleGroupActions_getPrototypeOf(o); }


var RuleGroupActions_RuleGroupActions = /*#__PURE__*/function (_PureComponent) {
  RuleGroupActions_inherits(RuleGroupActions, _PureComponent);

  var _super = RuleGroupActions_createSuper(RuleGroupActions);

  function RuleGroupActions() {
    RuleGroupActions_classCallCheck(this, RuleGroupActions);

    return _super.apply(this, arguments);
  }

  RuleGroupActions_createClass(RuleGroupActions, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          config = _this$props.config,
          addRule = _this$props.addRule,
          canAddRule = _this$props.canAddRule,
          canDeleteGroup = _this$props.canDeleteGroup,
          removeSelf = _this$props.removeSelf;
      var _config$settings = config.settings,
          immutableGroupsMode = _config$settings.immutableGroupsMode,
          addRuleLabel = _config$settings.addRuleLabel,
          delGroupLabel = _config$settings.delGroupLabel,
          Btn = _config$settings.renderButton;
      var addRuleBtn = !immutableGroupsMode && canAddRule && /*#__PURE__*/external_React_default.a.createElement(Btn, {
        type: "addRuleGroup",
        onClick: addRule,
        label: addRuleLabel,
        config: config
      });
      var delGroupBtn = !immutableGroupsMode && canDeleteGroup && /*#__PURE__*/external_React_default.a.createElement(Btn, {
        type: "delRuleGroup",
        onClick: removeSelf,
        label: delGroupLabel,
        config: config
      });
      return /*#__PURE__*/external_React_default.a.createElement("div", {
        className: "group--actions"
      }, addRuleBtn);
    }
  }]);

  return RuleGroupActions;
}(external_React_["PureComponent"]);
// CONCATENATED MODULE: ./modules/components/RuleGroup.jsx
function RuleGroup_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { RuleGroup_typeof = function _typeof(obj) { return typeof obj; }; } else { RuleGroup_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return RuleGroup_typeof(obj); }

var RuleGroup_dec, RuleGroup_class, RuleGroup_class2, RuleGroup_temp;

function RuleGroup_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function RuleGroup_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { RuleGroup_ownKeys(Object(source), true).forEach(function (key) { RuleGroup_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { RuleGroup_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function RuleGroup_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function RuleGroup_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function RuleGroup_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function RuleGroup_createClass(Constructor, protoProps, staticProps) { if (protoProps) RuleGroup_defineProperties(Constructor.prototype, protoProps); if (staticProps) RuleGroup_defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = RuleGroup_getPrototypeOf(object); if (object === null) break; } return object; }

function RuleGroup_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) RuleGroup_setPrototypeOf(subClass, superClass); }

function RuleGroup_setPrototypeOf(o, p) { RuleGroup_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return RuleGroup_setPrototypeOf(o, p); }

function RuleGroup_createSuper(Derived) { var hasNativeReflectConstruct = RuleGroup_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = RuleGroup_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = RuleGroup_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return RuleGroup_possibleConstructorReturn(this, result); }; }

function RuleGroup_possibleConstructorReturn(self, call) { if (call && (RuleGroup_typeof(call) === "object" || typeof call === "function")) { return call; } return RuleGroup_assertThisInitialized(self); }

function RuleGroup_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function RuleGroup_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function RuleGroup_getPrototypeOf(o) { RuleGroup_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return RuleGroup_getPrototypeOf(o); }









var RuleGroup_RuleGroup = (RuleGroup_dec = containers_Draggable("group rule_group"), containers_GroupContainer(RuleGroup_class = RuleGroup_dec(RuleGroup_class = (RuleGroup_temp = RuleGroup_class2 = /*#__PURE__*/function (_Group) {
  RuleGroup_inherits(RuleGroup, _Group);

  var _super = RuleGroup_createSuper(RuleGroup);

  function RuleGroup(props) {
    var _this;

    RuleGroup_classCallCheck(this, RuleGroup);

    _this = _super.call(this, props);

    _this.childrenClassName = function () {
      return "rule_group--children";
    };

    _this.renderHeaderWrapper = function () {
      return null;
    };

    _this.renderFooterWrapper = function () {
      return null;
    };

    _this.renderConjs = function () {
      return null;
    };

    _this.canAddGroup = function () {
      return false;
    };

    _this.canAddRule = function () {
      return true;
    };

    _this.canDeleteGroup = function () {
      return false;
    };

    Object(stuff["m" /* useOnPropsChanged */])(RuleGroup_assertThisInitialized(_this));

    _this.onPropsChanged(props);

    return _this;
  }

  RuleGroup_createClass(RuleGroup, [{
    key: "onPropsChanged",
    value: function onPropsChanged(nextProps) {}
  }, {
    key: "reordableNodesCnt",
    value: function reordableNodesCnt() {
      var children1 = this.props.children1;
      return children1.size;
    }
  }, {
    key: "renderChildrenWrapper",
    value: function renderChildrenWrapper() {
      return /*#__PURE__*/external_React_default.a.createElement(external_React_default.a.Fragment, null, this.renderDrag(), this.renderField(), this.renderActions(), _get(RuleGroup_getPrototypeOf(RuleGroup.prototype), "renderChildrenWrapper", this).call(this));
    }
  }, {
    key: "renderField",
    value: function renderField() {
      var immutableFieldsMode = this.props.config.settings.immutableFieldsMode;
      return /*#__PURE__*/external_React_default.a.createElement(Rule_FieldWrapper, {
        key: "field",
        classname: "group--field",
        config: this.props.config,
        selectedField: this.props.selectedField,
        setField: this.props.setField,
        parentField: this.props.parentField,
        readonly: immutableFieldsMode
      });
    }
  }, {
    key: "renderActions",
    value: function renderActions() {
      var _this$props = this.props,
          config = _this$props.config,
          addRule = _this$props.addRule;
      return /*#__PURE__*/external_React_default.a.createElement(RuleGroupActions_RuleGroupActions, {
        config: config,
        addRule: addRule,
        canAddRule: this.canAddRule(),
        canDeleteGroup: this.canDeleteGroup(),
        removeSelf: this.removeSelf
      });
    }
  }, {
    key: "extraPropsForItem",
    value: function extraPropsForItem(_item) {
      return {
        parentField: this.props.selectedField
      };
    }
  }]);

  return RuleGroup;
}(Group_Group), RuleGroup_class2.propTypes = RuleGroup_objectSpread(RuleGroup_objectSpread({}, Group_Group.propTypes), {}, {
  selectedField: prop_types_default.a.string,
  parentField: prop_types_default.a.string,
  setField: prop_types_default.a.func
}), RuleGroup_temp)) || RuleGroup_class) || RuleGroup_class);
/* harmony default export */ var components_RuleGroup = (RuleGroup_RuleGroup);
// CONCATENATED MODULE: ./modules/components/Item.jsx
function Item_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Item_typeof = function _typeof(obj) { return typeof obj; }; } else { Item_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Item_typeof(obj); }

function Item_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = Item_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function Item_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function Item_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Item_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Item_createClass(Constructor, protoProps, staticProps) { if (protoProps) Item_defineProperties(Constructor.prototype, protoProps); if (staticProps) Item_defineProperties(Constructor, staticProps); return Constructor; }

function Item_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Item_setPrototypeOf(subClass, superClass); }

function Item_setPrototypeOf(o, p) { Item_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Item_setPrototypeOf(o, p); }

function Item_createSuper(Derived) { var hasNativeReflectConstruct = Item_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = Item_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = Item_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return Item_possibleConstructorReturn(this, result); }; }

function Item_possibleConstructorReturn(self, call) { if (call && (Item_typeof(call) === "object" || typeof call === "function")) { return call; } return Item_assertThisInitialized(self); }

function Item_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Item_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function Item_getPrototypeOf(o) { Item_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Item_getPrototypeOf(o); }

function Item_extends() { Item_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return Item_extends.apply(this, arguments); }






var typeMap = {
  rule: function rule(props) {
    return /*#__PURE__*/external_React_default.a.createElement(components_Rule, Item_extends({}, props.properties.toObject(), {
      id: props.id,
      path: props.path,
      actions: props.actions,
      reordableNodesCnt: props.reordableNodesCnt,
      totalRulesCnt: props.totalRulesCnt,
      config: props.config,
      onDragStart: props.onDragStart,
      isDraggingTempo: props.isDraggingTempo,
      parentField: props.parentField
    }));
  },
  group: function group(props) {
    return /*#__PURE__*/external_React_default.a.createElement(components_Group, Item_extends({}, props.properties.toObject(), {
      id: props.id,
      path: props.path,
      actions: props.actions,
      config: props.config //tree={props.tree}
      ,
      reordableNodesCnt: props.reordableNodesCnt,
      totalRulesCnt: props.totalRulesCnt,
      onDragStart: props.onDragStart,
      isDraggingTempo: props.isDraggingTempo,
      children1: props.children1,
      parentField: null
    }));
  },
  rule_group: function rule_group(props) {
    return /*#__PURE__*/external_React_default.a.createElement(components_RuleGroup, Item_extends({}, props.properties.toObject(), {
      id: props.id,
      path: props.path,
      actions: props.actions,
      config: props.config //tree={props.tree}
      ,
      reordableNodesCnt: props.reordableNodesCnt,
      totalRulesCnt: props.totalRulesCnt,
      onDragStart: props.onDragStart,
      isDraggingTempo: props.isDraggingTempo,
      children1: props.children1,
      parentField: props.parentField
    }));
  }
};

var Item = /*#__PURE__*/function (_PureComponent) {
  Item_inherits(Item, _PureComponent);

  var _super = Item_createSuper(Item);

  function Item() {
    Item_classCallCheck(this, Item);

    return _super.apply(this, arguments);
  }

  Item_createClass(Item, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          type = _this$props.type,
          props = Item_objectWithoutProperties(_this$props, ["type"]);

      var Cmp = typeMap[type];
      if (!Cmp) return null;
      return Cmp(props);
    }
  }]);

  return Item;
}(external_React_["PureComponent"]);

Item.propTypes = {
  //tree: PropTypes.instanceOf(Immutable.Map).isRequired,
  config: prop_types_default.a.object.isRequired,
  id: prop_types_default.a.string.isRequired,
  type: prop_types_default.a.oneOf(Object.keys(typeMap)).isRequired,
  path: prop_types_default.a.any.isRequired,
  //instanceOf(Immutable.List)
  properties: prop_types_default.a.any.isRequired,
  //instanceOf(Immutable.Map)
  children1: prop_types_default.a.any,
  //instanceOf(Immutable.OrderedMap)
  actions: prop_types_default.a.object.isRequired,
  reordableNodesCnt: prop_types_default.a.number,
  onDragStart: prop_types_default.a.func,
  parentField: prop_types_default.a.string,
  //from RuleGroup
  isDraggingTempo: prop_types_default.a.bool
};
/* harmony default export */ var components_Item = (Item);
// EXTERNAL MODULE: ./modules/components/containers/SortableContainer.jsx
var SortableContainer = __webpack_require__(31);

// CONCATENATED MODULE: ./modules/components/Builder.jsx
function Builder_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Builder_typeof = function _typeof(obj) { return typeof obj; }; } else { Builder_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Builder_typeof(obj); }

var Builder_class, Builder_class2, Builder_temp;

function Builder_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Builder_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Builder_createClass(Constructor, protoProps, staticProps) { if (protoProps) Builder_defineProperties(Constructor.prototype, protoProps); if (staticProps) Builder_defineProperties(Constructor, staticProps); return Constructor; }

function Builder_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Builder_setPrototypeOf(subClass, superClass); }

function Builder_setPrototypeOf(o, p) { Builder_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Builder_setPrototypeOf(o, p); }

function Builder_createSuper(Derived) { var hasNativeReflectConstruct = Builder_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = Builder_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = Builder_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return Builder_possibleConstructorReturn(this, result); }; }

function Builder_possibleConstructorReturn(self, call) { if (call && (Builder_typeof(call) === "object" || typeof call === "function")) { return call; } return Builder_assertThisInitialized(self); }

function Builder_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Builder_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function Builder_getPrototypeOf(o) { Builder_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Builder_getPrototypeOf(o); }










var Builder_Builder = Object(SortableContainer["a" /* default */])(Builder_class = (Builder_temp = Builder_class2 = /*#__PURE__*/function (_Component) {
  Builder_inherits(Builder, _Component);

  var _super = Builder_createSuper(Builder);

  Builder_createClass(Builder, [{
    key: "shouldComponentUpdate",
    value: function shouldComponentUpdate(nextProps, nextState) {
      var prevProps = this.props;
      var should = Object(renderUtils["b" /* pureShouldComponentUpdate */])(this)(nextProps, nextState);

      if (should) {
        var chs = [];

        for (var k in nextProps) {
          var changed = nextProps[k] !== prevProps[k];

          if (changed && k != "__isInternalValueChange") {
            chs.push(k);
          }
        }

        if (!chs.length) should = false; //optimize render

        if (chs.length == 1 && chs[0] == "tree" && nextProps.__isInternalValueChange) should = false;
      }

      return should;
    }
  }]);

  function Builder(props) {
    var _this;

    Builder_classCallCheck(this, Builder);

    _this = _super.call(this, props);

    _this._updPath(props);

    return _this;
  }

  Builder_createClass(Builder, [{
    key: "_updPath",
    value: function _updPath(props) {
      var id = props.tree.get("id");
      this.path = external_Immutable_default.a.List.of(id);
    }
  }, {
    key: "render",
    value: function render() {
      var reordableNodesCnt = Object(treeUtils["h" /* getTotalReordableNodesCountInTree */])(this.props.tree);
      var totalRulesCnt = Object(treeUtils["i" /* getTotalRulesCountInTree */])(this.props.tree);
      var id = this.props.tree.get("id");
      return /*#__PURE__*/external_React_default.a.createElement(components_Item, {
        key: id,
        id: id,
        path: this.path,
        type: this.props.tree.get("type"),
        properties: this.props.tree.get("properties") || new external_Immutable_["Map"](),
        config: this.props.config,
        actions: this.props.actions,
        children1: this.props.tree.get("children1") || new external_Immutable_["Map"]() //tree={this.props.tree}
        ,
        reordableNodesCnt: reordableNodesCnt,
        totalRulesCnt: totalRulesCnt,
        onDragStart: this.props.onDragStart
      });
    }
  }]);

  return Builder;
}(external_React_["Component"]), Builder_class2.propTypes = {
  tree: prop_types_default.a.any.isRequired,
  //instanceOf(Immutable.Map)
  config: prop_types_default.a.object.isRequired,
  actions: prop_types_default.a.object.isRequired,
  onDragStart: prop_types_default.a.func
}, Builder_temp)) || Builder_class;


// EXTERNAL MODULE: ./modules/utils/funcUtils.js
var funcUtils = __webpack_require__(13);

// CONCATENATED MODULE: ./modules/export/queryBuilder.js


function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || queryBuilder_unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function queryBuilder_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return queryBuilder_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return queryBuilder_arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return queryBuilder_arrayLikeToArray(arr); }

function queryBuilder_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function queryBuilder_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function queryBuilder_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { queryBuilder_ownKeys(Object(source), true).forEach(function (key) { queryBuilder_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { queryBuilder_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function queryBuilder_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }






/*
 Build tree to http://querybuilder.js.org/ like format

 Example:
 {
    "condition": "AND",
    "rules": [
        {
            "id": "price",
            "field": "price",
            "type": "double",
            "input": "text",
            "operator": "less",
            "value": "10.25"
        },
        {
            "condition": "OR",
            "rules": [
                {
                    "id": "category",
                    "field": "category",
                    "type": "integer",
                    "input": "select",
                    "operator": "equal",
                    "value": "2"
                },
                {
                    "id": "category",
                    "field": "category",
                    "type": "integer",
                    "input": "select",
                    "operator": "equal",
                    "value": "1"
                }
            ]
        }
    ]
 }
 */

var queryBuilderFormat = function queryBuilderFormat(item, config) {
  var meta = {
    usedFields: []
  };
  return queryBuilder_objectSpread(queryBuilder_objectSpread({}, queryBuilder_queryBuilderFormat(item, config, meta)), meta);
}; //meta is mutable

var queryBuilder_queryBuilderFormat = function _queryBuilderFormat(item, config, meta) {
  if (!item) return undefined;
  var type = item.get("type");
  var properties = item.get("properties") || new external_Immutable_["Map"]();
  var children = item.get("children1");
  var id = item.get("id");

  if ((type === "group" || type === "rule_group") && children && children.size) {
    var list = children.map(function (currentChild) {
      return _queryBuilderFormat(currentChild, config, meta);
    }).filter(function (currentChild) {
      return typeof currentChild !== "undefined";
    });
    if (!list.size) return undefined;
    var conjunction = properties.get("conjunction");
    if (!conjunction) conjunction = Object(defaultUtils["a" /* defaultConjunction */])(config);
    var not = properties.get("not");
    var resultQuery = {};
    resultQuery["id"] = id;
    resultQuery["rules"] = list.toList();
    resultQuery["condition"] = conjunction.toUpperCase();
    resultQuery["not"] = not;
    return resultQuery;
  } else if (type === "rule") {
    var fieldSeparator = config.settings.fieldSeparator;
    var operator = properties.get("operator");
    var options = properties.get("operatorOptions");
    var field = properties.get("field");
    var value = properties.get("value");
    var valueSrc = properties.get("valueSrc");
    var valueType = properties.get("valueType");
    var hasUndefinedValues = value.filter(function (v) {
      return v === undefined;
    }).size > 0;
    if (field == null || operator == null || hasUndefinedValues) return undefined;
    var fieldDefinition = Object(configUtils["b" /* getFieldConfig */])(field, config) || {};
    var operatorDefinition = Object(configUtils["j" /* getOperatorConfig */])(config, operator, field) || {};
    var fieldType = fieldDefinition.type || "undefined";
    var cardinality = Object(stuff["c" /* defaultValue */])(operatorDefinition.cardinality, 1);
    var typeConfig = config.types[fieldDefinition.type] || {}; //format field

    var fieldName = field;

    if (fieldDefinition.tableName) {
      var fieldParts = Array.isArray(field) ? _toConsumableArray(field) : field.split(fieldSeparator);
      fieldParts[0] = fieldDefinition.tableName;
      fieldName = fieldParts.join(fieldSeparator);
    }

    if (value.size < cardinality) return undefined;
    if (meta.usedFields.indexOf(field) == -1) meta.usedFields.push(field);
    value = value.toArray();
    valueSrc = valueSrc.toArray();
    valueType = valueType.toArray();
    var values = [];

    for (var i = 0; i < value.length; i++) {
      var val = {
        type: valueType[i],
        value: value[i]
      };
      values.push(val);

      if (valueSrc[i] == "field") {
        var secondField = value[i];
        if (meta.usedFields.indexOf(secondField) == -1) meta.usedFields.push(secondField);
      }
    }

    var operatorOptions = options ? options.toJS() : null;
    if (operatorOptions && !Object.keys(operatorOptions).length) operatorOptions = null;
    var ruleQuery = {
      id: id,
      fieldName: fieldName,
      type: fieldType,
      input: typeConfig.mainWidget,
      operator: operator
    };
    if (operatorOptions) ruleQuery.operatorOptions = operatorOptions;
    ruleQuery.values = values;
    return ruleQuery;
  }

  return undefined;
};
// EXTERNAL MODULE: external "lodash/omit"
var omit_ = __webpack_require__(11);
var omit_default = /*#__PURE__*/__webpack_require__.n(omit_);

// CONCATENATED MODULE: ./modules/export/jsonLogic.js


function jsonLogic_toConsumableArray(arr) { return jsonLogic_arrayWithoutHoles(arr) || jsonLogic_iterableToArray(arr) || jsonLogic_unsupportedIterableToArray(arr) || jsonLogic_nonIterableSpread(); }

function jsonLogic_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function jsonLogic_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return jsonLogic_arrayLikeToArray(arr); }

function jsonLogic_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toArray(arr) { return jsonLogic_arrayWithHoles(arr) || jsonLogic_iterableToArray(arr) || jsonLogic_unsupportedIterableToArray(arr) || jsonLogic_nonIterableRest(); }

function jsonLogic_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function jsonLogic_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function jsonLogic_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function jsonLogic_createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = jsonLogic_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function jsonLogic_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return jsonLogic_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return jsonLogic_arrayLikeToArray(o, minLen); }

function jsonLogic_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }







 // http://jsonlogic.com/

var jsonLogic_jsonLogicFormat = function jsonLogicFormat(item, config) {
  var meta = {
    usedFields: [],
    errors: []
  };
  var logic = jsonLogic_jsonLogicFormatItem(item, config, meta, true); // build empty data

  var errors = meta.errors,
      usedFields = meta.usedFields;
  var _config$settings = config.settings,
      fieldSeparator = _config$settings.fieldSeparator,
      useGroupsAsArrays = _config$settings.useGroupsAsArrays;
  var data = {};

  var _iterator = jsonLogic_createForOfIteratorHelper(usedFields),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var ff = _step.value;
      var def = Object(configUtils["b" /* getFieldConfig */])(ff, config) || {};
      var parts = ff.split(fieldSeparator);
      var tmp = data;

      for (var i = 0; i < parts.length; i++) {
        var p = parts[i];
        var pdef = Object(configUtils["b" /* getFieldConfig */])(parts.slice(0, i + 1), config) || {};

        if (i != parts.length - 1) {
          if (pdef.type == "!group" && useGroupsAsArrays) {
            if (!tmp[p]) tmp[p] = [{}];
            tmp = tmp[p][0];
          } else {
            if (!tmp[p]) tmp[p] = {};
            tmp = tmp[p];
          }
        } else {
          tmp[p] = null; // can use def.type for sample values
        }
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return {
    errors: errors,
    logic: logic,
    data: data
  };
}; //meta is mutable

var jsonLogic_jsonLogicFormatValue = function jsonLogicFormatValue(meta, config, currentValue, valueSrc, valueType, fieldWidgetDefinition, fieldDefinition, operator, operatorDefinition) {
  var parentField = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : null;
  if (currentValue === undefined) return undefined;
  var fieldSeparator = config.settings.fieldSeparator;
  var ret;

  if (valueSrc == "field") {
    var rightField = currentValue;

    if (rightField) {
      var rightFieldName = Array.isArray(rightField) ? rightField.join(fieldSeparator) : rightField;
      ret = {
        "var": rightFieldName
      };
      if (meta.usedFields.indexOf(rightFieldName) == -1) meta.usedFields.push(rightFieldName);
    }
  } else if (valueSrc == "func") {
    var funcKey = currentValue.get("func");
    var args = currentValue.get("args");
    var funcConfig = Object(configUtils["h" /* getFuncConfig */])(funcKey, config);

    if (!funcConfig.jsonLogic) {
      meta.errors.push("Func ".concat(funcKey, " is not supported"));
      return undefined;
    }

    var formattedArgs = {};

    for (var argKey in funcConfig.args) {
      var argConfig = funcConfig.args[argKey];
      var fieldDef = Object(configUtils["b" /* getFieldConfig */])(argConfig, config);
      var argVal = args ? args.get(argKey) : undefined;
      var argValue = argVal ? argVal.get("value") : undefined;
      var argValueSrc = argVal ? argVal.get("valueSrc") : undefined;
      var formattedArgVal = jsonLogicFormatValue(meta, config, argValue, argValueSrc, argConfig.type, fieldDef, argConfig, null, null, parentField);

      if (argValue != undefined && formattedArgVal === undefined) {
        meta.errors.push("Can't format value of arg ".concat(argKey, " for func ").concat(funcKey));
        return undefined;
      }

      if (formattedArgVal !== undefined) {
        // skip optional in the end
        formattedArgs[argKey] = formattedArgVal;
      }
    }

    var formattedArgsArr = Object.values(formattedArgs);

    if (typeof funcConfig.jsonLogic === "function") {
      var fn = funcConfig.jsonLogic;
      var _args = [formattedArgs];
      ret = fn.apply(void 0, _args);
    } else {
      var funcName = funcConfig.jsonLogic || funcKey;
      var isMethod = !!funcConfig.jsonLogicIsMethod;

      if (isMethod) {
        var _formattedArgsArr = _toArray(formattedArgsArr),
            obj = _formattedArgsArr[0],
            params = _formattedArgsArr.slice(1);

        if (params.length) {
          ret = {
            "method": [obj, funcName, params]
          };
        } else {
          ret = {
            "method": [obj, funcName]
          };
        }
      } else {
        ret = jsonLogic_defineProperty({}, funcName, formattedArgsArr);
      }
    }
  } else {
    if (typeof fieldWidgetDefinition.jsonLogic === "function") {
      var _fn = fieldWidgetDefinition.jsonLogic;
      var _args2 = [currentValue, pick_default()(fieldDefinition, ["fieldSettings", "listValues"]), //useful options: valueFormat for date/time
      omit_default()(fieldWidgetDefinition, ["formatValue", "mongoFormatValue", "sqlFormatValue", "jsonLogic"])];

      if (operator) {
        _args2.push(operator);

        _args2.push(operatorDefinition);
      }

      ret = _fn.apply(void 0, _args2);
    } else {
      ret = currentValue;
    }
  }

  return ret;
}; //meta is mutable


var jsonLogic_jsonLogicFormatItem = function jsonLogicFormatItem(item, config, meta, isRoot) {
  var parentField = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
  if (!item) return undefined;
  var _config$settings2 = config.settings,
      fieldSeparator = _config$settings2.fieldSeparator,
      useGroupsAsArrays = _config$settings2.useGroupsAsArrays;
  var type = item.get("type");
  var properties = item.get("properties") || new external_Immutable_["Map"]();
  var children = item.get("children1");
  var field = properties.get("field");

  if ((type === "group" || type === "rule_group") && children && children.size) {
    var isRuleGroup = type === "rule_group" && !isRoot;
    var conjunction = properties.get("conjunction");
    if (!conjunction) conjunction = Object(defaultUtils["a" /* defaultConjunction */])(config);
    var conj = conjunction.toLowerCase();
    var not = properties.get("not");

    if (conj != "and" && conj != "or") {
      meta.errors.push("Conjunction ".concat(conj, " is not supported"));
      return undefined;
    }

    var groupField = isRuleGroup && useGroupsAsArrays ? field : parentField;
    var list = children.map(function (currentChild) {
      return jsonLogicFormatItem(currentChild, config, meta, false, groupField);
    }).filter(function (currentChild) {
      return typeof currentChild !== "undefined";
    });
    if (!list.size) return undefined;
    var resultQuery = {};
    if (list.size == 1 && !isRoot) resultQuery = list.first();else resultQuery[conj] = list.toList().toJS(); // revert

    if (not && !isRuleGroup) {
      if (Object.keys(resultQuery).length == 1 && ["all", "some"].includes(Object.keys(resultQuery)[0])) {
        // if `rule_group` is wrapped in group with `not` - just swap `some` to `none` for simplicity
        var gop = Object.keys(resultQuery)[0];
        resultQuery["none"] = resultQuery[gop];
        delete resultQuery[gop];
      } else {
        resultQuery = {
          "!": resultQuery
        };
      }
    } // rule_group (issue #246)


    if (isRuleGroup && useGroupsAsArrays) {
      var op = not ? "none" : "some";
      var fieldName = field;

      if (parentField) {
        fieldName = cutBeginOfString(fieldName, parentField + fieldSeparator);
      }

      resultQuery = jsonLogic_defineProperty({}, op, [{
        "var": fieldName
      }, resultQuery]);
    }

    return resultQuery;
  } else if (type === "rule") {
    var operator = properties.get("operator");
    var operatorOptions = properties.get("operatorOptions");
    operatorOptions = operatorOptions ? operatorOptions.toJS() : null;
    if (operatorOptions && !Object.keys(operatorOptions).length) operatorOptions = null;

    var _field = properties.get("field");

    var value = properties.get("value");
    if (_field == null || operator == null) return undefined;
    var fieldDefinition = Object(configUtils["b" /* getFieldConfig */])(_field, config) || {};
    var operatorDefinition = Object(configUtils["j" /* getOperatorConfig */])(config, operator, _field) || {};
    var reversedOp = operatorDefinition.reversedOp;
    var revOperatorDefinition = Object(configUtils["j" /* getOperatorConfig */])(config, reversedOp, _field) || {};

    var _fieldType = fieldDefinition.type || "undefined";

    var cardinality = Object(stuff["c" /* defaultValue */])(operatorDefinition.cardinality, 1); // check op

    var isRev = false;

    if (!operatorDefinition.jsonLogic && revOperatorDefinition.jsonLogic) {
      isRev = true;
      var _ref = [reversedOp, operator];
      operator = _ref[0];
      reversedOp = _ref[1];
      var _ref2 = [revOperatorDefinition, operatorDefinition];
      operatorDefinition = _ref2[0];
      revOperatorDefinition = _ref2[1];
    }

    if (!operatorDefinition.jsonLogic) {
      meta.errors.push("Operator ".concat(operator, " is not supported"));
      return undefined;
    } // format value


    var isReverseArgs = Object(stuff["c" /* defaultValue */])(operatorDefinition._jsonLogicIsRevArgs, false);
    var valueSrcs = [];
    var valueTypes = [];
    var _usedFields = meta.usedFields;
    value = value.map(function (currentValue, ind) {
      var valueSrc = properties.get("valueSrc") ? properties.get("valueSrc").get(ind) : null;
      var valueType = properties.get("valueType") ? properties.get("valueType").get(ind) : null;
      currentValue = Object(funcUtils["a" /* completeValue */])(currentValue, valueSrc, config);
      var widget = Object(configUtils["n" /* getWidgetForFieldOp */])(config, _field, operator, valueSrc);
      var fieldWidgetDefinition = omit_default()(Object(configUtils["e" /* getFieldWidgetConfig */])(config, _field, operator, widget, valueSrc), ["factory"]);
      var fv = jsonLogic_jsonLogicFormatValue(meta, config, currentValue, valueSrc, valueType, fieldWidgetDefinition, fieldDefinition, operator, operatorDefinition, parentField);

      if (fv !== undefined) {
        valueSrcs.push(valueSrc);
        valueTypes.push(valueType);
      }

      return fv;
    });
    var hasUndefinedValues = value.filter(function (v) {
      return v === undefined;
    }).size > 0;

    if (value.size < cardinality || hasUndefinedValues) {
      meta.usedFields = _usedFields; // restore

      return undefined;
    }

    var formattedValue = cardinality > 1 ? value.toArray() : cardinality == 1 ? value.first() : null; // format field

    var _fieldName = _field;

    if (parentField) {
      _fieldName = cutBeginOfString(_fieldName, parentField + fieldSeparator);
    }

    var formattedField = {
      "var": _fieldName
    };
    if (meta.usedFields.indexOf(_field) == -1) meta.usedFields.push(_field); // format logic

    var formatteOp = operator;
    if (typeof operatorDefinition.jsonLogic == "string") formatteOp = operatorDefinition.jsonLogic;
    var fn = typeof operatorDefinition.jsonLogic == "function" ? operatorDefinition.jsonLogic : null;

    if (!fn) {
      var rangeOps = ["<", "<=", ">", ">="];

      fn = function fn(field, op, val, opDef, opOpts) {
        if (cardinality == 0) return jsonLogic_defineProperty({}, formatteOp, formattedField);else if (cardinality == 1 && isReverseArgs) return jsonLogic_defineProperty({}, formatteOp, [formattedValue, formattedField]);else if (cardinality == 1) return jsonLogic_defineProperty({}, formatteOp, [formattedField, formattedValue]);else if (cardinality == 2 && rangeOps.includes(formatteOp)) return jsonLogic_defineProperty({}, formatteOp, [formattedValue[0], formattedField, formattedValue[1]]);else return jsonLogic_defineProperty({}, formatteOp, [formattedField].concat(jsonLogic_toConsumableArray(formattedValue)));
      };
    }

    var args = [formattedField, operator, formattedValue, omit_default()(operatorDefinition, ["formatOp", "mongoFormatOp", "sqlFormatOp", "jsonLogic"]), operatorOptions];
    var ruleQuery = fn.apply(void 0, args);

    if (isRev) {
      ruleQuery = {
        "!": ruleQuery
      };
    }

    return ruleQuery;
  }

  return undefined;
}; // helpers


var cutBeginOfString = function cutBeginOfString(str, begin) {
  if (begin && str.slice(0, begin.length) == begin) {
    str = str.slice(begin.length);
  }

  return str;
};
// EXTERNAL MODULE: ./modules/config/default.js
var config_default = __webpack_require__(15);

// CONCATENATED MODULE: ./modules/export/mongoDb.js


function mongoDb_toConsumableArray(arr) { return mongoDb_arrayWithoutHoles(arr) || mongoDb_iterableToArray(arr) || mongoDb_unsupportedIterableToArray(arr) || mongoDb_nonIterableSpread(); }

function mongoDb_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function mongoDb_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function mongoDb_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return mongoDb_arrayLikeToArray(arr); }

function mongoDb_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function mongoDb_slicedToArray(arr, i) { return mongoDb_arrayWithHoles(arr) || mongoDb_iterableToArrayLimit(arr, i) || mongoDb_unsupportedIterableToArray(arr, i) || mongoDb_nonIterableRest(); }

function mongoDb_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function mongoDb_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return mongoDb_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return mongoDb_arrayLikeToArray(o, minLen); }

function mongoDb_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function mongoDb_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function mongoDb_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function mongoDb_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { mongoDb_typeof = function _typeof(obj) { return typeof obj; }; } else { mongoDb_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return mongoDb_typeof(obj); }









var mongodbFormat = function mongodbFormat(tree, config) {
  var meta = {
    errors: []
  };
  var res = mongoDb_mongodbFormatItem([], tree, config, meta);
  if (meta.errors.length) console.warn("Errors while exporting to MongoDb:", meta.errors);
  return res;
};

var isObject = function isObject(v) {
  return mongoDb_typeof(v) == "object" && v !== null && !Array.isArray(v);
}; //meta is mutable


var mongoDb_mongoFormatValue = function mongoFormatValue(meta, config, currentValue, valueSrc, valueType, fieldWidgetDefinition, fieldDefinition, operator, operatorDefinition) {
  if (currentValue === undefined) return [undefined, false];
  var fieldSeparator = config.settings.fieldSeparator;
  var ret;
  var useExpr = false;

  if (valueSrc == "field") {
    //format field
    var rightField = currentValue;

    if (rightField) {
      var rightFieldDefinition = Object(configUtils["b" /* getFieldConfig */])(rightField, config) || {};
      var fieldParts = Array.isArray(rightField) ? rightField : rightField.split(fieldSeparator);

      var _fieldKeys = Object(configUtils["c" /* getFieldPath */])(rightField, config);

      var fieldPartsLabels = Object(configUtils["d" /* getFieldPathLabels */])(rightField, config);
      var fieldFullLabel = fieldPartsLabels ? fieldPartsLabels.join(fieldSeparator) : null;
      var formatField = config.settings.formatField || config_default["a" /* settings */].formatField;
      var rightFieldName = Array.isArray(rightField) ? rightField.join(fieldSeparator) : rightField; // if (rightFieldDefinition.tableName) {
      //     const fieldPartsCopy = [...fieldParts];
      //     fieldPartsCopy[0] = rightFieldDefinition.tableName;
      //     rightFieldName = fieldPartsCopy.join(fieldSeparator);
      // }

      var formattedField = formatField(rightFieldName, fieldParts, fieldFullLabel, rightFieldDefinition, config, false);
      ret = "$" + formattedField;
      useExpr = true;
    }
  } else if (valueSrc == "func") {
    useExpr = true;
    var funcKey = currentValue.get("func");
    var args = currentValue.get("args");
    var funcConfig = Object(configUtils["h" /* getFuncConfig */])(funcKey, config);
    var funcName = funcConfig.mongoFunc || funcKey;
    var mongoArgsAsObject = funcConfig.mongoArgsAsObject;
    var formattedArgs = {};
    var argsCnt = 0;
    var lastArg = undefined;

    for (var argKey in funcConfig.args) {
      var argConfig = funcConfig.args[argKey];
      var fieldDef = Object(configUtils["b" /* getFieldConfig */])(argConfig, config);
      var argVal = args ? args.get(argKey) : undefined;
      var argValue = argVal ? argVal.get("value") : undefined;
      var argValueSrc = argVal ? argVal.get("valueSrc") : undefined;

      var _mongoFormatValue = mongoFormatValue(meta, config, argValue, argValueSrc, argConfig.type, fieldDef, argConfig, null, null),
          _mongoFormatValue2 = mongoDb_slicedToArray(_mongoFormatValue, 2),
          formattedArgVal = _mongoFormatValue2[0],
          _argUseExpr = _mongoFormatValue2[1];

      if (argValue != undefined && formattedArgVal === undefined) {
        meta.errors.push("Can't format value of arg ".concat(argKey, " for func ").concat(funcKey));
        return [undefined, false];
      }

      argsCnt++;

      if (formattedArgVal !== undefined) {
        // skip optional in the end
        formattedArgs[argKey] = formattedArgVal;
        lastArg = formattedArgVal;
      }
    }

    if (typeof funcConfig.mongoFormatFunc === "function") {
      var fn = funcConfig.mongoFormatFunc;
      var _args = [formattedArgs];
      ret = fn.apply(void 0, _args);
    } else {
      if (mongoArgsAsObject) ret = mongoDb_defineProperty({}, funcName, formattedArgs);else if (argsCnt == 1 && lastArg !== undefined) ret = mongoDb_defineProperty({}, funcName, lastArg);else ret = mongoDb_defineProperty({}, funcName, Object.values(formattedArgs));
    }
  } else {
    if (typeof fieldWidgetDefinition.mongoFormatValue === "function") {
      var _fn = fieldWidgetDefinition.mongoFormatValue;
      var _args2 = [currentValue, pick_default()(fieldDefinition, ["fieldSettings", "listValues"]), //useful options: valueFormat for date/time
      omit_default()(fieldWidgetDefinition, ["formatValue", "mongoFormatValue", "sqlFormatValue", "jsonLogic"])];

      if (operator) {
        _args2.push(operator);

        _args2.push(operatorDefinition);
      }

      ret = _fn.apply(void 0, _args2);
    } else {
      ret = currentValue;
    }
  }

  return [ret, useExpr];
}; //meta is mutable


var mongoDb_mongodbFormatItem = function mongodbFormatItem(parents, item, config, meta) {
  var _not = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;

  if (!item) return undefined;
  var type = item.get("type");
  var properties = item.get("properties") || new external_Immutable_["Map"]();
  var children = item.get("children1");
  var _config$settings = config.settings,
      fieldSeparator = _config$settings.fieldSeparator,
      canShortMongoQuery = _config$settings.canShortMongoQuery;
  var hasParentRuleGroup = parents.filter(function (it) {
    return it.get("type") == "rule_group";
  }).length > 0;
  var parentPath = parents.filter(function (it) {
    return it.get("type") == "rule_group";
  }).map(function (it) {
    return it.get("properties").get("field");
  }).slice(-1).pop();

  if ((type === "group" || type === "rule_group") && children && children.size) {
    var not = _not ? !properties.get("not") : properties.get("not");
    var list = children.map(function (currentChild) {
      return mongodbFormatItem([].concat(mongoDb_toConsumableArray(parents), [item]), currentChild, config, meta, not);
    }).filter(function (currentChild) {
      return typeof currentChild !== "undefined";
    });
    if (!list.size) return undefined;
    var field = type === "rule_group" ? properties.get("field") : null;
    var conjunction = properties.get("conjunction");
    if (!conjunction) conjunction = Object(defaultUtils["a" /* defaultConjunction */])(config);
    var conjunctionDefinition = config.conjunctions[conjunction];
    var reversedConj = conjunctionDefinition.reversedConj;

    if (not && reversedConj) {
      conjunction = reversedConj;
      conjunctionDefinition = config.conjunctions[conjunction];
    }

    var mongoConj = conjunctionDefinition.mongoConj;
    var resultQuery;
    if (list.size == 1) resultQuery = list.first();else {
      var rules = list.toList().toJS();
      var canShort = canShortMongoQuery && mongoConj == "$and";

      if (canShort) {
        resultQuery = rules.reduce(function (acc, rule) {
          if (!acc) return undefined;

          for (var k in rule) {
            if (k[0] == "$") {
              acc = undefined;
              break;
            }

            if (acc[k] == undefined) {
              acc[k] = rule[k];
            } else {
              // https://github.com/ukrbublik/react-awesome-query-builder/issues/182
              var prev = acc[k],
                  next = rule[k];

              if (!isObject(prev)) {
                prev = {
                  "$eq": prev
                };
              }

              if (!isObject(next)) {
                next = {
                  "$eq": next
                };
              }

              var prevOp = Object.keys(prev)[0],
                  nextOp = Object.keys(next)[0];

              if (prevOp == nextOp) {
                acc = undefined;
                break;
              }

              acc[k] = Object.assign({}, prev, next);
            }
          }

          return acc;
        }, {});
      }

      if (!resultQuery) // can't be shorten
        resultQuery = mongoDb_defineProperty({}, mongoConj, rules);
    }

    if (field) {
      //format field
      var fieldName = field;

      if (hasParentRuleGroup) {
        if (parentPath && fieldName.indexOf(parentPath + ".") == 0) {
          fieldName = fieldName.slice((parentPath + ".").length);
        } else {
          meta.errors.push("Can't cut group ".concat(parentPath, " from field ").concat(fieldName));
        }
      }

      resultQuery = mongoDb_defineProperty({}, fieldName, {
        "$elemMatch": resultQuery
      });
    }

    return resultQuery;
  } else if (type === "rule") {
    var operator = properties.get("operator");
    var operatorOptions = properties.get("operatorOptions");

    var _field = properties.get("field");

    var value = properties.get("value");
    if (_field == null || operator == null) return undefined;
    var fieldDefinition = Object(configUtils["b" /* getFieldConfig */])(_field, config) || {};
    var operatorDefinition = Object(configUtils["j" /* getOperatorConfig */])(config, operator, _field) || {};
    var reversedOp = operatorDefinition.reversedOp;
    var revOperatorDefinition = Object(configUtils["j" /* getOperatorConfig */])(config, reversedOp, _field) || {};
    var cardinality = Object(stuff["c" /* defaultValue */])(operatorDefinition.cardinality, 1);
    var _not2 = _not;

    if (_not2 && reversedOp) {
      var _ref = [reversedOp, operator];
      operator = _ref[0];
      reversedOp = _ref[1];
      var _ref2 = [revOperatorDefinition, operatorDefinition];
      operatorDefinition = _ref2[0];
      revOperatorDefinition = _ref2[1];
      _not2 = false;
    } //format field


    var _fieldName = _field;

    if (hasParentRuleGroup) {
      if (parentPath && _fieldName.indexOf(parentPath + ".") == 0) {
        _fieldName = _fieldName.slice((parentPath + ".").length);
      } else {
        meta.errors.push("Can't cut group ".concat(parentPath, " from field ").concat(_fieldName));
      }
    } // if (fieldDefinition.tableName) {
    //   let fieldParts = Array.isArray(field) ? [...field] : field.split(fieldSeparator);
    //   fieldParts[0] = fieldDefinition.tableName;
    //   fieldName = fieldParts.join(fieldSeparator);
    // }
    //format value


    var valueSrcs = [];
    var valueTypes = [];
    var useExpr = false;
    value = value.map(function (currentValue, ind) {
      var valueSrc = properties.get("valueSrc") ? properties.get("valueSrc").get(ind) : null;
      var valueType = properties.get("valueType") ? properties.get("valueType").get(ind) : null;
      currentValue = Object(funcUtils["a" /* completeValue */])(currentValue, valueSrc, config);
      var widget = Object(configUtils["n" /* getWidgetForFieldOp */])(config, _field, operator, valueSrc);
      var fieldWidgetDefinition = omit_default()(Object(configUtils["e" /* getFieldWidgetConfig */])(config, _field, operator, widget, valueSrc), ["factory"]);

      var _mongoFormatValue3 = mongoDb_mongoFormatValue(meta, config, currentValue, valueSrc, valueType, fieldWidgetDefinition, fieldDefinition, operator, operatorDefinition),
          _mongoFormatValue4 = mongoDb_slicedToArray(_mongoFormatValue3, 2),
          fv = _mongoFormatValue4[0],
          _useExpr = _mongoFormatValue4[1];

      if (fv !== undefined) {
        useExpr = useExpr || _useExpr;
        valueSrcs.push(valueSrc);
        valueTypes.push(valueType);
      }

      return fv;
    });
    var hasUndefinedValues = value.filter(function (v) {
      return v === undefined;
    }).size > 0;
    if (value.size < cardinality || hasUndefinedValues) return undefined;
    var formattedValue = cardinality > 1 ? value.toArray() : cardinality == 1 ? value.first() : null; //build rule

    var fn = operatorDefinition.mongoFormatOp;

    if (!fn) {
      meta.errors.push("Operator ".concat(operator, " is not supported"));
      return undefined;
    }

    var args = [_fieldName, operator, formattedValue, useExpr, valueSrcs.length > 1 ? valueSrcs : valueSrcs[0], valueTypes.length > 1 ? valueTypes : valueTypes[0], omit_default()(operatorDefinition, ["formatOp", "mongoFormatOp", "sqlFormatOp", "jsonLogic"]), operatorOptions];
    var ruleQuery = fn.apply(void 0, args);

    if (ruleQuery && useExpr) {
      ruleQuery = {
        "$expr": ruleQuery
      };
    }

    if (_not2) {
      ruleQuery = {
        "$not": ruleQuery
      };
    }

    return ruleQuery;
  }

  return undefined;
};
// CONCATENATED MODULE: ./modules/utils/sql.js
var SqlString = __webpack_require__(35);

SqlString.trim = function (val) {
  if (val.charAt(0) == "'") return val.substring(1, val.length - 1);else return val;
};

SqlString.escapeLike = function (val) {
  var any_start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var any_end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
  // normal escape
  var res = SqlString.escape(val); // unwrap ''

  res = SqlString.trim(res); // escape % and _

  res = res.replace(/[%_]/g, "\\$&"); // wrap with % for LIKE

  res = (any_start ? "%" : "") + res + (any_end ? "%" : ""); // wrap ''

  res = "'" + res + "'";
  return res;
};


// CONCATENATED MODULE: ./modules/export/sql.js
function sql_slicedToArray(arr, i) { return sql_arrayWithHoles(arr) || sql_iterableToArrayLimit(arr, i) || sql_unsupportedIterableToArray(arr, i) || sql_nonIterableRest(); }

function sql_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function sql_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function sql_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function sql_toConsumableArray(arr) { return sql_arrayWithoutHoles(arr) || sql_iterableToArray(arr) || sql_unsupportedIterableToArray(arr) || sql_nonIterableSpread(); }

function sql_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function sql_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return sql_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return sql_arrayLikeToArray(o, minLen); }

function sql_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function sql_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return sql_arrayLikeToArray(arr); }

function sql_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }










var sqlFormat = function sqlFormat(tree, config) {
  var meta = {
    errors: []
  };
  var res = sql_sqlFormatItem(tree, config, meta);
  if (meta.errors.length) console.warn("Errors while exporting to SQL:", meta.errors);
  return res;
}; //meta is mutable

var sql_sqlFormatValue = function sqlFormatValue(meta, config, currentValue, valueSrc, valueType, fieldWidgetDefinition, fieldDefinition, operator, operatorDefinition) {
  if (currentValue === undefined) return undefined;
  var fieldSeparator = config.settings.fieldSeparator;
  var ret;

  if (valueSrc == "field") {
    //format field
    var rightField = currentValue;
    var formattedField = null;

    if (rightField) {
      var rightFieldDefinition = Object(configUtils["b" /* getFieldConfig */])(rightField, config) || {};
      var fieldParts = Array.isArray(rightField) ? rightField : rightField.split(fieldSeparator);

      var _fieldKeys = Object(configUtils["c" /* getFieldPath */])(rightField, config);

      var fieldPartsLabels = Object(configUtils["d" /* getFieldPathLabels */])(rightField, config);
      var fieldFullLabel = fieldPartsLabels ? fieldPartsLabels.join(fieldSeparator) : null;
      var formatField = config.settings.formatField || config_default["a" /* settings */].formatField;
      var rightFieldName = Array.isArray(rightField) ? rightField.join(fieldSeparator) : rightField;

      if (rightFieldDefinition.tableName) {
        var fieldPartsCopy = sql_toConsumableArray(fieldParts);

        fieldPartsCopy[0] = rightFieldDefinition.tableName;
        rightFieldName = fieldPartsCopy.join(fieldSeparator);
      }

      formattedField = formatField(rightFieldName, fieldParts, fieldFullLabel, rightFieldDefinition, config);
    }

    ret = formattedField;
  } else if (valueSrc == "func") {
    var funcKey = currentValue.get("func");
    var args = currentValue.get("args");
    var funcConfig = Object(configUtils["h" /* getFuncConfig */])(funcKey, config);
    var funcName = funcConfig.sqlFunc || funcKey;
    var formattedArgs = {};

    for (var argKey in funcConfig.args) {
      var argConfig = funcConfig.args[argKey];
      var fieldDef = Object(configUtils["b" /* getFieldConfig */])(argConfig, config);
      var argVal = args ? args.get(argKey) : undefined;
      var argValue = argVal ? argVal.get("value") : undefined;
      var argValueSrc = argVal ? argVal.get("valueSrc") : undefined;
      var formattedArgVal = sqlFormatValue(meta, config, argValue, argValueSrc, argConfig.type, fieldDef, argConfig, null, null);

      if (argValue != undefined && formattedArgVal === undefined) {
        meta.errors.push("Can't format value of arg ".concat(argKey, " for func ").concat(funcKey));
        return undefined;
      }

      if (formattedArgVal !== undefined) {
        // skip optional in the end
        formattedArgs[argKey] = formattedArgVal;
      }
    }

    if (typeof funcConfig.sqlFormatFunc === "function") {
      var fn = funcConfig.sqlFormatFunc;
      var _args = [formattedArgs];
      ret = fn.apply(void 0, _args);
    } else {
      ret = "".concat(funcName, "(").concat(Object.entries(formattedArgs).map(function (_ref) {
        var _ref2 = sql_slicedToArray(_ref, 2),
            k = _ref2[0],
            v = _ref2[1];

        return v;
      }).join(", "), ")");
    }
  } else {
    if (typeof fieldWidgetDefinition.sqlFormatValue === "function") {
      var _fn = fieldWidgetDefinition.sqlFormatValue;
      var _args2 = [currentValue, pick_default()(fieldDefinition, ["fieldSettings", "listValues"]), //useful options: valueFormat for date/time
      omit_default()(fieldWidgetDefinition, ["formatValue", "mongoFormatValue", "sqlFormatValue", "jsonLogic"])];

      if (operator) {
        _args2.push(operator);

        _args2.push(operatorDefinition);
      }

      if (valueSrc == "field") {
        var valFieldDefinition = Object(configUtils["b" /* getFieldConfig */])(currentValue, config) || {};

        _args2.push(valFieldDefinition);
      }

      ret = _fn.apply(void 0, _args2);
    } else {
      ret = SqlString.escape(currentValue);
    }
  }

  return ret;
}; //meta is mutable


var sql_sqlFormatItem = function sqlFormatItem(item, config, meta) {
  if (!item) return undefined;
  var type = item.get("type");
  var properties = item.get("properties") || new external_Immutable_["Map"]();
  var children = item.get("children1");

  if ((type === "group" || type === "rule_group") && children && children.size) {
    var not = properties.get("not");
    var list = children.map(function (currentChild) {
      return sqlFormatItem(currentChild, config, meta);
    }).filter(function (currentChild) {
      return typeof currentChild !== "undefined";
    });
    if (!list.size) return undefined;
    var conjunction = properties.get("conjunction");
    if (!conjunction) conjunction = Object(defaultUtils["a" /* defaultConjunction */])(config);
    var conjunctionDefinition = config.conjunctions[conjunction];
    return conjunctionDefinition.sqlFormatConj(list, conjunction, not);
  } else if (type === "rule") {
    var field = properties.get("field");
    var operator = properties.get("operator");
    var operatorOptions = properties.get("operatorOptions");
    if (field == null || operator == null) return undefined;
    var fieldDefinition = Object(configUtils["b" /* getFieldConfig */])(field, config) || {};
    var operatorDefinition = Object(configUtils["j" /* getOperatorConfig */])(config, operator, field) || {};
    var reversedOp = operatorDefinition.reversedOp;
    var revOperatorDefinition = Object(configUtils["j" /* getOperatorConfig */])(config, reversedOp, field) || {};
    var cardinality = Object(stuff["c" /* defaultValue */])(operatorDefinition.cardinality, 1);
    var fieldSeparator = config.settings.fieldSeparator; //format value

    var valueSrcs = [];
    var valueTypes = [];
    var value = properties.get("value").map(function (currentValue, ind) {
      var valueSrc = properties.get("valueSrc") ? properties.get("valueSrc").get(ind) : null;
      var valueType = properties.get("valueType") ? properties.get("valueType").get(ind) : null;
      currentValue = Object(funcUtils["a" /* completeValue */])(currentValue, valueSrc, config);
      var widget = Object(configUtils["n" /* getWidgetForFieldOp */])(config, field, operator, valueSrc);
      var fieldWidgetDefinition = omit_default()(Object(configUtils["e" /* getFieldWidgetConfig */])(config, field, operator, widget, valueSrc), ["factory"]);
      var fv = sql_sqlFormatValue(meta, config, currentValue, valueSrc, valueType, fieldWidgetDefinition, fieldDefinition, operator, operatorDefinition);

      if (fv !== undefined) {
        valueSrcs.push(valueSrc);
        valueTypes.push(valueType);
      }

      return fv;
    });
    var hasUndefinedValues = value.filter(function (v) {
      return v === undefined;
    }).size > 0;
    if (hasUndefinedValues || value.size < cardinality) return undefined;
    var formattedValue = cardinality == 1 ? value.first() : value; //find fn to format expr

    var isRev = false;
    var fn = operatorDefinition.sqlFormatOp;

    if (!fn && reversedOp) {
      fn = revOperatorDefinition.sqlFormatOp;

      if (fn) {
        isRev = true;
      }
    }

    if (!fn) {
      var _operator = operatorDefinition.sqlOp || operator;

      if (cardinality == 0) {
        fn = function fn(field, op, values, valueSrc, valueType, opDef, operatorOptions) {
          return "".concat(field, " ").concat(_operator);
        };
      } else if (cardinality == 1) {
        fn = function fn(field, op, value, valueSrc, valueType, opDef, operatorOptions) {
          return "".concat(field, " ").concat(_operator, " ").concat(value);
        };
      } else if (cardinality == 2) {
        // between
        fn = function fn(field, op, values, valueSrc, valueType, opDef, operatorOptions) {
          var valFrom = values.first();
          var valTo = values.get(1);
          return "".concat(field, " ").concat(_operator, " ").concat(valFrom, " AND ").concat(valTo);
        };
      }
    }

    if (!fn) {
      meta.errors.push("Operator ".concat(operator, " is not supported"));
      return undefined;
    } //format field


    var fieldName = field;
    var fieldParts = Array.isArray(field) ? field : field.split(fieldSeparator);

    if (fieldDefinition.tableName) {
      var fieldPartsCopy = sql_toConsumableArray(fieldParts);

      fieldPartsCopy[0] = fieldDefinition.tableName;
      fieldName = fieldPartsCopy.join(fieldSeparator);
    }

    var _fieldKeys = Object(configUtils["c" /* getFieldPath */])(field, config);

    var fieldPartsLabels = Object(configUtils["d" /* getFieldPathLabels */])(field, config);
    var fieldFullLabel = fieldPartsLabels ? fieldPartsLabels.join(config.settings.fieldSeparator) : null;
    var formatField = config.settings.formatField || config_default["a" /* settings */].formatField;
    var formattedField = formatField(fieldName, fieldParts, fieldFullLabel, fieldDefinition, config); //format expr

    var args = [formattedField, operator, formattedValue, valueSrcs.length > 1 ? valueSrcs : valueSrcs[0], valueTypes.length > 1 ? valueTypes : valueTypes[0], omit_default()(operatorDefinition, ["formatOp", "mongoFormatOp", "sqlFormatOp", "jsonLogic"]), operatorOptions];
    var ret = fn.apply(void 0, args);

    if (isRev) {
      ret = config.settings.sqlFormatReverse(ret, operator, reversedOp, operatorDefinition, revOperatorDefinition);
    }

    return ret;
  }

  return undefined;
};
// CONCATENATED MODULE: ./modules/export/queryString.js
function queryString_toConsumableArray(arr) { return queryString_arrayWithoutHoles(arr) || queryString_iterableToArray(arr) || queryString_unsupportedIterableToArray(arr) || queryString_nonIterableSpread(); }

function queryString_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function queryString_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function queryString_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return queryString_arrayLikeToArray(arr); }

function queryString_slicedToArray(arr, i) { return queryString_arrayWithHoles(arr) || queryString_iterableToArrayLimit(arr, i) || queryString_unsupportedIterableToArray(arr, i) || queryString_nonIterableRest(); }

function queryString_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function queryString_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return queryString_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return queryString_arrayLikeToArray(o, minLen); }

function queryString_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function queryString_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function queryString_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }










var queryString_formatValue = function formatValue(config, currentValue, valueSrc, valueType, fieldWidgetDefinition, fieldDefinition, operator, operatorDefinition, isForDisplay) {
  if (currentValue === undefined) return undefined;
  var _config$settings = config.settings,
      fieldSeparator = _config$settings.fieldSeparator,
      fieldSeparatorDisplay = _config$settings.fieldSeparatorDisplay;
  var ret;

  if (valueSrc == "field") {
    //format field
    var rightField = currentValue;
    var formattedField = null;

    if (rightField) {
      var rightFieldDefinition = Object(configUtils["b" /* getFieldConfig */])(rightField, config) || {};
      var fieldParts = Array.isArray(rightField) ? rightField : rightField.split(fieldSeparator);

      var _fieldKeys = Object(configUtils["c" /* getFieldPath */])(rightField, config);

      var fieldPartsLabels = Object(configUtils["d" /* getFieldPathLabels */])(rightField, config);
      var fieldFullLabel = fieldPartsLabels ? fieldPartsLabels.join(fieldSeparatorDisplay) : null;
      var fieldLabel2 = rightFieldDefinition.label2 || fieldFullLabel;
      var formatField = config.settings.formatField || config_default["a" /* settings */].formatField;
      var rightFieldName = Array.isArray(rightField) ? rightField.join(fieldSeparator) : rightField;
      formattedField = formatField(rightFieldName, fieldParts, fieldLabel2, rightFieldDefinition, config, isForDisplay);
    }

    ret = formattedField;
  } else if (valueSrc == "func") {
    var funcKey = currentValue.get("func");
    var args = currentValue.get("args");
    var funcConfig = Object(configUtils["h" /* getFuncConfig */])(funcKey, config);
    var funcName = isForDisplay && funcConfig.label || funcKey;
    var formattedArgs = {};
    var formattedArgsWithNames = {};

    for (var argKey in funcConfig.args) {
      var argConfig = funcConfig.args[argKey];
      var fieldDef = Object(configUtils["b" /* getFieldConfig */])(argConfig, config);
      var argVal = args ? args.get(argKey) : undefined;
      var argValue = argVal ? argVal.get("value") : undefined;
      var argValueSrc = argVal ? argVal.get("valueSrc") : undefined;
      var formattedArgVal = formatValue(config, argValue, argValueSrc, argConfig.type, fieldDef, argConfig, null, null, isForDisplay);
      var argName = isForDisplay && argConfig.label || argKey;

      if (formattedArgVal !== undefined) {
        // skip optional in the end
        formattedArgs[argKey] = formattedArgVal;
        formattedArgsWithNames[argName] = formattedArgVal;
      }
    }

    if (typeof funcConfig.formatFunc === "function") {
      var fn = funcConfig.formatFunc;
      var _args = [formattedArgs, isForDisplay];
      ret = fn.apply(void 0, _args);
    } else {
      ret = "".concat(funcName, "(").concat(Object.entries(formattedArgsWithNames).map(function (_ref) {
        var _ref2 = queryString_slicedToArray(_ref, 2),
            k = _ref2[0],
            v = _ref2[1];

        return isForDisplay ? "".concat(k, ": ").concat(v) : "".concat(v);
      }).join(", "), ")");
    }
  } else {
    if (typeof fieldWidgetDefinition.formatValue === "function") {
      var _fn = fieldWidgetDefinition.formatValue;
      var _args2 = [currentValue, pick_default()(fieldDefinition, ["fieldSettings", "listValues"]), //useful options: valueFormat for date/time
      omit_default()(fieldWidgetDefinition, ["formatValue", "mongoFormatValue", "sqlFormatValue", "jsonLogic"]), isForDisplay];

      if (operator) {
        _args2.push(operator);

        _args2.push(operatorDefinition);
      }

      if (valueSrc == "field") {
        var valFieldDefinition = Object(configUtils["b" /* getFieldConfig */])(currentValue, config) || {};

        _args2.push(valFieldDefinition);
      }

      ret = _fn.apply(void 0, _args2);
    } else {
      ret = currentValue;
    }
  }

  return ret;
};

var queryString_queryString = function queryString(item, config) {
  var isForDisplay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  if (!item) return undefined;
  var type = item.get("type");
  var properties = item.get("properties") || new external_Immutable_["Map"]();
  var children = item.get("children1");

  if ((type === "group" || type === "rule_group") && children && children.size) {
    var not = properties.get("not");
    var list = children.map(function (currentChild) {
      return queryString(currentChild, config, isForDisplay);
    }).filter(function (currentChild) {
      return typeof currentChild !== "undefined";
    });
    if (!list.size) return undefined;
    var conjunction = properties.get("conjunction");
    if (!conjunction) conjunction = Object(defaultUtils["a" /* defaultConjunction */])(config);
    var conjunctionDefinition = config.conjunctions[conjunction];
    return conjunctionDefinition.formatConj(list, conjunction, not, isForDisplay);
  } else if (type === "rule") {
    var field = properties.get("field");
    var operator = properties.get("operator");
    var operatorOptions = properties.get("operatorOptions");
    if (field == null || operator == null) return undefined;
    var fieldDefinition = Object(configUtils["b" /* getFieldConfig */])(field, config) || {};
    var operatorDefinition = Object(configUtils["j" /* getOperatorConfig */])(config, operator, field) || {};
    var reversedOp = operatorDefinition.reversedOp;
    var revOperatorDefinition = Object(configUtils["j" /* getOperatorConfig */])(config, reversedOp, field) || {};
    var cardinality = Object(stuff["c" /* defaultValue */])(operatorDefinition.cardinality, 1);
    var fieldSeparator = config.settings.fieldSeparator; //format value

    var valueSrcs = [];
    var valueTypes = [];
    var value = properties.get("value").map(function (currentValue, ind) {
      var valueSrc = properties.get("valueSrc") ? properties.get("valueSrc").get(ind) : null;
      var valueType = properties.get("valueType") ? properties.get("valueType").get(ind) : null;
      currentValue = Object(funcUtils["a" /* completeValue */])(currentValue, valueSrc, config);
      var widget = Object(configUtils["n" /* getWidgetForFieldOp */])(config, field, operator, valueSrc);
      var fieldWidgetDefinition = omit_default()(Object(configUtils["e" /* getFieldWidgetConfig */])(config, field, operator, widget, valueSrc), ["factory"]);
      var fv = queryString_formatValue(config, currentValue, valueSrc, valueType, fieldWidgetDefinition, fieldDefinition, operator, operatorDefinition, isForDisplay);

      if (fv !== undefined) {
        valueSrcs.push(valueSrc);
        valueTypes.push(valueType);
      }

      return fv;
    });
    var hasUndefinedValues = value.filter(function (v) {
      return v === undefined;
    }).size > 0;
    if (hasUndefinedValues || value.size < cardinality) return undefined;
    var formattedValue = cardinality == 1 ? value.first() : value; //find fn to format expr

    var isRev = false;
    var fn = operatorDefinition.formatOp;

    if (!fn && reversedOp) {
      fn = revOperatorDefinition.formatOp;

      if (fn) {
        isRev = true;
      }
    }

    if (!fn && cardinality == 1) {
      var _operator = operatorDefinition.labelForFormat || operator;

      fn = function fn(field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
        return "".concat(field, " ").concat(_operator, " ").concat(values);
      };
    }

    if (!fn) return undefined; //format field

    var fieldName = field;
    var fieldParts = Array.isArray(field) ? field : field.split(fieldSeparator);

    if (fieldDefinition.tableName) {
      var fieldPartsCopy = queryString_toConsumableArray(fieldParts);

      fieldPartsCopy[0] = fieldDefinition.tableName;
      fieldName = fieldPartsCopy.join(fieldSeparator);
    }

    var _fieldKeys = Object(configUtils["c" /* getFieldPath */])(field, config);

    var fieldPartsLabels = Object(configUtils["d" /* getFieldPathLabels */])(field, config);
    var fieldFullLabel = fieldPartsLabels ? fieldPartsLabels.join(config.settings.fieldSeparatorDisplay) : null;
    var fieldLabel2 = fieldDefinition.label2 || fieldFullLabel;
    var formatField = config.settings.formatField || config_default["a" /* settings */].formatField;
    var formattedField = formatField(fieldName, fieldParts, fieldLabel2, fieldDefinition, config, isForDisplay); //format expr

    var args = [formattedField, operator, formattedValue, valueSrcs.length > 1 ? valueSrcs : valueSrcs[0], valueTypes.length > 1 ? valueTypes : valueTypes[0], omit_default()(operatorDefinition, ["formatOp", "mongoFormatOp", "sqlFormatOp", "jsonLogic"]), operatorOptions, isForDisplay, fieldDefinition];
    var ret = fn.apply(void 0, args);

    if (isRev) {
      ret = config.settings.formatReverse(ret, operator, reversedOp, operatorDefinition, revOperatorDefinition, isForDisplay);
    }

    return ret;
  }

  return undefined;
};
// CONCATENATED MODULE: ./modules/export/index.js







// CONCATENATED MODULE: ./modules/import/tree.js
function tree_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { tree_typeof = function _typeof(obj) { return typeof obj; }; } else { tree_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return tree_typeof(obj); }






var tree_getTree = function getTree(immutableTree) {
  var light = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  if (!immutableTree) return undefined;
  var tree = immutableTree;
  tree = tree.toJS();
  if (light) tree = Object(treeUtils["g" /* getLightTree */])(tree);
  return tree;
};
var loadTree = function loadTree(serTree) {
  if (tree_isImmutableTree(serTree)) {
    return serTree;
  } else if (isTree(serTree)) {
    return jsTreeToImmutable(serTree);
  } else if (typeof serTree == "string" && serTree.startsWith('["~#iM"')) {
    //tip: old versions of RAQB were saving tree with `transit.toJSON()`
    // https://github.com/ukrbublik/react-awesome-query-builder/issues/69
    throw "You are trying to load query in obsolete serialization format (Immutable string) which is not supported in versions starting from 2.1.17";
  } else if (typeof serTree == "string") {
    return jsTreeToImmutable(JSON.parse(serTree));
  } else throw "Can't load tree!";
};
var tree_checkTree = function checkTree(tree, config) {
  if (!tree) return undefined;
  var extendedConfig = Object(configUtils["a" /* extendConfig */])(config);
  return Object(validation["b" /* validateTree */])(tree, null, extendedConfig, extendedConfig, true, true);
};
var tree_isValidTree = function isValidTree(tree) {
  return Object(treeUtils["j" /* getTreeBadFields */])(tree).length == 0;
};
var tree_isImmutableTree = function isImmutableTree(tree) {
  return external_Immutable_["Map"].isMap(tree);
};
var isTree = function isTree(tree) {
  return tree_typeof(tree) == "object" && tree.type == "group";
};


function jsTreeToImmutable(tree) {
  return Object(external_Immutable_["fromJS"])(tree, function (key, value) {
    var outValue;

    if (key == "value" && value.get(0) && value.get(0).toJS !== undefined) {
      var valueJs = value.get(0).toJS();

      if (valueJs.func) {
        outValue = value.toOrderedMap();
      } else {
        // only for raw values keep JS representation
        outValue = external_Immutable_default.a.List.of(valueJs);
      }
    } else outValue = external_Immutable_default.a.Iterable.isIndexed(value) ? value.toList() : value.toOrderedMap();

    return outValue;
  });
}
// EXTERNAL MODULE: external "moment"
var external_moment_ = __webpack_require__(9);
var external_moment_default = /*#__PURE__*/__webpack_require__.n(external_moment_);

// CONCATENATED MODULE: ./modules/import/jsonLogic.js
function import_jsonLogic_toConsumableArray(arr) { return import_jsonLogic_arrayWithoutHoles(arr) || import_jsonLogic_iterableToArray(arr) || import_jsonLogic_unsupportedIterableToArray(arr) || import_jsonLogic_nonIterableSpread(); }

function import_jsonLogic_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function import_jsonLogic_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return import_jsonLogic_arrayLikeToArray(arr); }

function jsonLogic_toArray(arr) { return import_jsonLogic_arrayWithHoles(arr) || import_jsonLogic_iterableToArray(arr) || import_jsonLogic_unsupportedIterableToArray(arr) || import_jsonLogic_nonIterableRest(); }

function import_jsonLogic_iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function jsonLogic_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function jsonLogic_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { jsonLogic_ownKeys(Object(source), true).forEach(function (key) { import_jsonLogic_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { jsonLogic_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function import_jsonLogic_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function jsonLogic_slicedToArray(arr, i) { return import_jsonLogic_arrayWithHoles(arr) || jsonLogic_iterableToArrayLimit(arr, i) || import_jsonLogic_unsupportedIterableToArray(arr, i) || import_jsonLogic_nonIterableRest(); }

function import_jsonLogic_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function import_jsonLogic_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return import_jsonLogic_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return import_jsonLogic_arrayLikeToArray(o, minLen); }

function import_jsonLogic_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function jsonLogic_iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function import_jsonLogic_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }







 // http://jsonlogic.com/
// helpers

Object.defineProperty(Array.prototype, "uniq", {
  enumerable: false,
  value: function value() {
    return Array.from(new Set(this));
  }
});
Object.defineProperty(Array.prototype, "to_object", {
  enumerable: false,
  value: function value() {
    return this.reduce(function (acc, _ref) {
      var _ref2 = jsonLogic_slicedToArray(_ref, 2),
          f = _ref2[0],
          fc = _ref2[1];

      return jsonLogic_objectSpread(jsonLogic_objectSpread({}, acc), {}, import_jsonLogic_defineProperty({}, f, fc));
    }, {});
  }
}); //meta is mutable

var jsonLogic_loadFromJsonLogic = function loadFromJsonLogic(logicTree, config) {
  var meta = {
    errors: []
  };
  var extendedConfig = Object(configUtils["a" /* extendConfig */])(config);
  var conv = jsonLogic_buildConv(extendedConfig);
  var jsTree = logicTree ? jsonLogic_convertFromLogic(logicTree, conv, extendedConfig, "rule", meta) : undefined;

  if (jsTree && jsTree.type != "group") {
    jsTree = jsonLogic_wrapInDefaultConj(jsTree, extendedConfig);
  }

  var immTree = jsTree ? loadTree(jsTree) : undefined;
  if (meta.errors.length) console.warn("Errors while importing from JsonLogic:", meta.errors);
  return immTree;
};

var jsonLogic_buildConv = function buildConv(config) {
  var operators = {};

  for (var opKey in config.operators) {
    var opConfig = config.operators[opKey];

    if (typeof opConfig.jsonLogic == "string") {
      // example: "</2", "#in/1"
      var opk = (opConfig._jsonLogicIsRevArgs ? "#" : "") + opConfig.jsonLogic + "/" + Object(stuff["c" /* defaultValue */])(opConfig.cardinality, 1);
      if (!operators[opk]) operators[opk] = [];
      operators[opk].push(opKey);
    } else if (typeof opConfig.jsonLogic2 == "string") {
      // example: all-in/1"
      var _opk = opConfig.jsonLogic2 + "/" + Object(stuff["c" /* defaultValue */])(opConfig.cardinality, 1);

      if (!operators[_opk]) operators[_opk] = [];

      operators[_opk].push(opKey);
    }
  }

  var conjunctions = {};

  for (var conjKey in config.conjunctions) {
    var ck = conjKey.toLowerCase();
    conjunctions[ck] = conjKey;
  }

  var funcs = {};

  for (var funcKey in config.funcs) {
    var funcConfig = config.funcs[funcKey];

    if (typeof funcConfig.jsonLogic == "string") {
      var fk = (funcConfig.jsonLogicIsMethod ? "#" : "") + funcConfig.jsonLogic;
      if (!funcs[fk]) funcs[fk] = [];
      funcs[fk].push(funcKey);
    }
  }

  return {
    operators: operators,
    conjunctions: conjunctions,
    funcs: funcs
  };
};

var jsonLogic_convertFromLogic = function convertFromLogic(logic, conv, config, expectedType, meta) {
  var not = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
  var fieldConfig = arguments.length > 6 ? arguments[6] : undefined;
  var widget = arguments.length > 7 ? arguments[7] : undefined;
  var parentField = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : null;
  var op, vals;

  if (Object(stuff["h" /* isJsonLogic */])(logic)) {
    op = Object.keys(logic)[0];
    vals = logic[op];
    if (!Array.isArray(vals)) vals = [vals];
  }

  var ret;
  var beforeErrorsCnt = meta.errors.length;
  var isNotOp = op == "!" && vals.length == 1 && vals[0] && Object(stuff["h" /* isJsonLogic */])(vals[0]) && Object.keys(vals[0])[0] == "var";
  var isRev = op == "!" && !isNotOp;

  if (isRev) {
    ret = convertFromLogic(vals[0], conv, config, expectedType, meta, !not, fieldConfig, widget, parentField);
  } else if (expectedType == "val") {
    ret = jsonLogic_convertField(op, vals, conv, config, not, meta, parentField) || convertFunc(op, vals, conv, config, not, fieldConfig, meta, parentField) || jsonLogic_convertVal(logic, fieldConfig, widget, config, meta);
  } else if (expectedType == "rule") {
    ret = jsonLogic_convertConj(op, vals, conv, config, not, meta, parentField) || jsonLogic_convertOp(op, vals, conv, config, not, meta, parentField);
  }

  var afterErrorsCnt = meta.errors.length;

  if (op != "!" && ret === undefined && afterErrorsCnt == beforeErrorsCnt) {
    meta.errors.push("Can't parse logic ".concat(JSON.stringify(logic)));
  }

  return ret;
};

var jsonLogic_convertVal = function convertVal(val, fieldConfig, widget, config, meta) {
  if (val === undefined) return undefined;
  var widgetConfig = config.widgets[widget || fieldConfig.mainWidget];

  if (!widgetConfig) {
    meta.errors.push("No widget for type ".concat(fieldConfig.type));
    return undefined;
  }

  if (Object(stuff["h" /* isJsonLogic */])(val)) {
    meta.errors.push("Unexpected logic in value: ".concat(JSON.stringify(val)));
    return undefined;
  } // number of seconds -> time string


  if (fieldConfig && fieldConfig.type == "time" && typeof val == "number") {
    var h = Math.floor(val / 60 / 60) % 24,
        m = Math.floor(val / 60) % 60,
        s = val % 60;
    var valueFormat = widgetConfig.valueFormat;

    if (valueFormat) {
      var dateVal = new Date(val);
      dateVal.setMilliseconds(0);
      dateVal.setHours(h);
      dateVal.setMinutes(m);
      dateVal.setSeconds(s);
      val = external_moment_default()(dateVal).format(valueFormat);
    } else {
      val = "".concat(h, ":").concat(m, ":").concat(s);
    }
  } // "2020-01-08T22:00:00.000Z" -> Date object


  if (fieldConfig && ["date", "datetime"].includes(fieldConfig.type) && val && !(val instanceof Date)) {
    try {
      var _dateVal = new Date(val);

      if (_dateVal instanceof Date && _dateVal.toISOString() === val) {
        val = _dateVal;
      }
    } catch (e) {
      meta.errors.push("Can't convert value ".concat(val, " as Date"));
      val = undefined;
    }
  } // Date object -> formatted string


  if (val instanceof Date && fieldConfig) {
    var _valueFormat = widgetConfig.valueFormat;

    if (_valueFormat) {
      val = external_moment_default()(val).format(_valueFormat);
    }
  }

  return {
    valueSrc: "value",
    value: val,
    valueType: widgetConfig.type
  };
};

var jsonLogic_convertField = function convertField(op, vals, conv, config, not, meta) {
  var parentField = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;
  var fieldSeparator = config.settings.fieldSeparator;

  if (op == "var") {
    var field = vals[0];
    if (parentField) field = [parentField, field].join(fieldSeparator);
    var fieldConfig = Object(configUtils["b" /* getFieldConfig */])(field, config);

    if (!fieldConfig) {
      meta.errors.push("No config for field ".concat(field));
      return undefined;
    }

    return {
      valueSrc: "field",
      value: field,
      valueType: fieldConfig.type
    };
  }

  return undefined;
};

var convertFunc = function convertFunc(op, vals, conv, config, not, fieldConfig, meta) {
  var parentField = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;
  if (!op) return undefined;
  var func, argsArr;
  var jsonLogicIsMethod = op == "method";

  if (jsonLogicIsMethod) {
    var obj, opts;

    var _vals = jsonLogic_toArray(vals);

    obj = _vals[0];
    func = _vals[1];
    opts = _vals.slice(2);
    argsArr = [obj].concat(import_jsonLogic_toConsumableArray(opts));
  } else {
    func = op;
    argsArr = vals;
  }

  var fk = (jsonLogicIsMethod ? "#" : "") + func;
  var funcKeys = conv.funcs[fk];

  if (funcKeys) {
    var funcKey = funcKeys[0];

    if (funcKeys.length > 1 && fieldConfig) {
      funcKeys = funcKeys.filter(function (k) {
        return config.funcs[k].returnType == fieldConfig.type;
      });

      if (funcKeys.length == 0) {
        meta.errors.push("No funcs returning type ".concat(fieldConfig.type));
        return undefined;
      }

      funcKey = funcKeys[0];
    }

    var funcConfig = config.funcs[funcKey];
    var argKeys = Object.keys(funcConfig.args);
    var args = argsArr.reduce(function (acc, val, ind) {
      var argKey = argKeys[ind];
      var argConfig = funcConfig.args[argKey];
      var argVal = jsonLogic_convertFromLogic(val, conv, config, "val", meta, false, argConfig, null, parentField);

      if (argVal === undefined) {
        argVal = argConfig.defaultValue;

        if (argVal === undefined) {
          meta.errors.push("No value for arg ".concat(argKey, " of func ").concat(funcKey));
          return undefined;
        }
      }

      return jsonLogic_objectSpread(jsonLogic_objectSpread({}, acc), {}, import_jsonLogic_defineProperty({}, argKey, argVal));
    }, {});
    return {
      valueSrc: "func",
      value: {
        func: funcKey,
        args: args
      },
      valueType: funcConfig.returnType
    };
  }

  return undefined;
};

var jsonLogic_convertConj = function convertConj(op, vals, conv, config, not, meta) {
  var parentField = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;
  var conjKey = conv.conjunctions[op];
  var fieldSeparator = config.settings.fieldSeparator;

  if (conjKey) {
    var type = "group";
    var children = vals.map(function (v) {
      return jsonLogic_convertFromLogic(v, conv, config, "rule", meta, false, null, null, parentField);
    }).filter(function (r) {
      return r !== undefined;
    }).reduce(function (acc, r) {
      return jsonLogic_objectSpread(jsonLogic_objectSpread({}, acc), {}, import_jsonLogic_defineProperty({}, r.id, r));
    }, {});
    var complexFields = Object.entries(children).filter(function (_ref3) {
      var _ref4 = jsonLogic_slicedToArray(_ref3, 2),
          _k = _ref4[0],
          v = _ref4[1];

      return v.properties !== undefined && v.properties.field !== undefined && v.properties.field.indexOf(fieldSeparator) != -1;
    }).map(function (_ref5) {
      var _ref6 = jsonLogic_slicedToArray(_ref5, 2),
          _k = _ref6[0],
          v = _ref6[1];

      return v.properties.field.split(fieldSeparator);
    });
    var complexFieldsParents = complexFields.map(function (parts) {
      return parts.slice(0, parts.length - 1).join(fieldSeparator);
    });
    var complexFieldsConfigs = complexFieldsParents.uniq().map(function (f) {
      return [f, Object(configUtils["b" /* getFieldConfig */])(f, config)];
    }).to_object();
    var complexFieldsInRuleGroup = complexFieldsParents.filter(function (f) {
      return complexFieldsConfigs[f].type == "!group";
    });
    var usedRuleGroups = complexFieldsInRuleGroup.uniq();
    var usedTopRuleGroups = topLevelFieldsFilter(usedRuleGroups);
    var properties = {
      conjunction: conjKey,
      not: not
    };
    var id = Object(uuid["a" /* default */])();
    var children1 = {}; // TIP: `needSplit` will be true if using useGroupsAsArrays=false and there are fields of different groups on one level
    //      (like "a.b" and "x.z" -> need to split them with hierarchy)
    // TIP: Even if fields are of same root parent (like "a.b", "a.c.d"), still we may need to create hierarchy of `rule_group`s

    var needSplit = !(usedTopRuleGroups.length == 1 && complexFieldsInRuleGroup.length == Object.keys(children).length);
    var groupToId = {};
    Object.entries(children).map(function (_ref7) {
      var _ref8 = jsonLogic_slicedToArray(_ref7, 2),
          k = _ref8[0],
          v = _ref8[1];

      if (v.type == "group" || v.type == "rule_group") {
        // put as-is
        children1[k] = v;
      } else {
        var groupFields = usedRuleGroups.filter(function (f) {
          return v.properties.field.indexOf(f) == 0;
        });
        var groupField = groupFields.length > 0 ? groupFields.sort(function (a, b) {
          return b.length - a.length;
        })[0] : null;

        if (!groupField) {
          // not in rule_group (can be simple field or in struct) - put as-is
          children1[k] = v;
        } else {
          // wrap field in rule_group (with creating hierarchy if need)
          var ch = children1;
          groupField.split(fieldSeparator).map(function (f, i, a) {
            var p = a.slice(0, i);
            var ff = [].concat(import_jsonLogic_toConsumableArray(p), [f]).join(fieldSeparator);

            if (!needSplit && i == 0) {
              type = "rule_group";
              properties.field = ff;
              groupToId[ff] = id;
            } else {
              var groupId = groupToId[ff];

              if (!groupId) {
                groupId = Object(uuid["a" /* default */])();
                groupToId[ff] = groupId;
                ch[groupId] = {
                  type: "rule_group",
                  id: groupId,
                  children1: {},
                  properties: {
                    conjunction: conjKey,
                    not: false,
                    field: ff
                  }
                };
              }

              ch = ch[groupId].children1;
            }
          });
          ch[k] = v;
        }
      }
    });
    return {
      type: type,
      id: id,
      children1: children1,
      properties: properties
    };
  }

  return undefined;
};

var topLevelFieldsFilter = function topLevelFieldsFilter(fields) {
  var arr = import_jsonLogic_toConsumableArray(fields).sort(function (a, b) {
    return a.length - b.length;
  });

  for (var i = 0; i < arr.length; i++) {
    for (var j = i + 1; j < arr.length; j++) {
      if (arr[j].indexOf(arr[i]) == 0) {
        // arr[j] is inside arr[i] (eg. "a.b" inside "a")
        arr.splice(j, 1);
        j--;
      }
    }
  }

  return arr;
};

var jsonLogic_wrapInDefaultConjRuleGroup = function wrapInDefaultConjRuleGroup(rule, parentField, config, conj) {
  if (!rule) return undefined;
  return {
    type: "rule_group",
    id: Object(uuid["a" /* default */])(),
    children1: import_jsonLogic_defineProperty({}, rule.id, rule),
    properties: {
      conjunction: conj || Object(defaultUtils["b" /* defaultGroupConjunction */])(config),
      not: false,
      field: parentField
    }
  };
};

var jsonLogic_wrapInDefaultConj = function wrapInDefaultConj(rule, config) {
  var not = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  return {
    type: "group",
    id: Object(uuid["a" /* default */])(),
    children1: import_jsonLogic_defineProperty({}, rule.id, rule),
    properties: {
      conjunction: Object(defaultUtils["a" /* defaultConjunction */])(config),
      not: not
    }
  };
};

var jsonLogic_convertOp = function convertOp(op, vals, conv, config, not, meta) {
  var parentField = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : null;
  if (!op) return undefined;
  var fieldSeparator = config.settings.fieldSeparator;
  var arity = vals.length;
  var cardinality = arity - 1;

  if (op == "all") {
    // special case for "all-in"
    var op2 = Object.keys(vals[1])[0];

    if (op2 == "in") {
      vals = [vals[0], vals[1][op2][1]];
      op = op + "-" + op2; // "all-in"
    }
  }

  var opk = op + "/" + cardinality;
  var oks = [],
      errors = [];

  var _check = function _check(isRevArgs) {
    var opKeys = conv.operators[(isRevArgs ? "#" : "") + opk];

    if (opKeys) {
      var jlField,
          _args = [];
      var rangeOps = ["<", "<=", ">", ">="];

      if (rangeOps.includes(op) && arity == 3) {
        jlField = vals[1];
        _args = [vals[0], vals[2]];
      } else if (isRevArgs) {
        jlField = vals[1];
        _args = [vals[0]];
      } else {
        var _vals2 = vals;

        var _vals3 = jsonLogic_toArray(_vals2);

        jlField = _vals3[0];
        _args = _vals3.slice(1);
      }

      var _jlField = jlField,
          _field = _jlField["var"];
      if (parentField) _field = [parentField, _field].join(fieldSeparator);

      if (!_field) {
        errors.push("Unknown field ".concat(JSON.stringify(jlField)));
        return;
      }

      var _fieldConfig = Object(configUtils["b" /* getFieldConfig */])(_field, config);

      if (!_fieldConfig) {
        errors.push("No config for field ".concat(_field));
        return;
      }

      var _opKey = opKeys[0];

      if (opKeys.length > 1 && _fieldConfig && _fieldConfig.operators) {
        // eg. for "equal" and "select_equals"
        opKeys = opKeys.filter(function (k) {
          return _fieldConfig.operators.includes(k);
        });

        if (opKeys.length == 0) {
          errors.push("No corresponding ops for field ".concat(_field));
          return;
        }

        _opKey = opKeys[0];
      }

      oks.push({
        field: _field,
        fieldConfig: _fieldConfig,
        opKey: _opKey,
        args: _args
      });
    }
  };

  _check(false);

  _check(true); // special case for `rule_group` (issue #246)


  if (["some", "all", "none"].includes(op) && arity == 2) {
    if (vals[0]["var"] !== undefined && Object.keys(vals[1]).length == 1) {
      var _field2 = vals[0]["var"];
      var sub = vals[1];
      var newOp = Object.keys(sub)[0];

      if (!(newOp == "in" && op == "all")) {
        // don't confuse with "all-in" for multiselect
        var newVals = sub[newOp];
        var newNot = !!(not ^ newOp == "none");
        var groupField = (parentField ? [parentField, _field2] : [_field2]).join(fieldSeparator);
        var groupFieldConfig = Object(configUtils["b" /* getFieldConfig */])(groupField, config);

        if (groupFieldConfig && groupFieldConfig.type == "!group") {
          var res;

          if (conv.conjunctions[newOp] !== undefined) {
            res = jsonLogic_convertConj(newOp, newVals, conv, config, newNot, meta, groupField);
          } else {
            // need to be wrapped in `rule_group`
            var _rule = convertOp(newOp, newVals, conv, config, newNot, meta, groupField);

            res = jsonLogic_wrapInDefaultConjRuleGroup(_rule, groupField, config, conv.conjunctions["and"]);
          }

          return res;
        }
      }
    }
  }

  if (!oks.length) {
    meta.errors.push(errors.join("; ") || "Unknown op ".concat(op, "/").concat(arity));
    return undefined;
  }

  var _oks$ = oks[0],
      field = _oks$.field,
      fieldConfig = _oks$.fieldConfig,
      opKey = _oks$.opKey,
      args = _oks$.args;
  var opConfig = config.operators[opKey];

  if (not && opConfig.reversedOp) {
    not = false;
    opKey = opConfig.reversedOp;
    opConfig = config.operators[opKey];
  }

  var widget = Object(configUtils["n" /* getWidgetForFieldOp */])(config, field, opKey);
  var convertedArgs = args.map(function (v) {
    return jsonLogic_convertFromLogic(v, conv, config, "val", meta, false, fieldConfig, widget, parentField);
  });

  if (convertedArgs.filter(function (v) {
    return v === undefined;
  }).length) {
    //meta.errors.push(`Undefined arg for field ${field} and op ${opKey}`);
    return undefined;
  }

  var rule = {
    type: "rule",
    id: Object(uuid["a" /* default */])(),
    properties: {
      field: field,
      operator: opKey,
      value: convertedArgs.map(function (v) {
        return v.value;
      }),
      valueSrc: convertedArgs.map(function (v) {
        return v.valueSrc;
      }),
      valueType: convertedArgs.map(function (v) {
        return v.valueType;
      })
    }
  };

  if (not) {
    //meta.errors.push(`No rev op for ${opKey}`);
    return jsonLogic_wrapInDefaultConj(rule, config, not);
  } else {
    return rule;
  }
};
// CONCATENATED MODULE: ./modules/import/index.js




// EXTERNAL MODULE: ./modules/components/widgets/index.js + 19 modules
var components_widgets = __webpack_require__(10);

// EXTERNAL MODULE: external "lodash/range"
var range_ = __webpack_require__(24);
var range_default = /*#__PURE__*/__webpack_require__.n(range_);

// CONCATENATED MODULE: ./modules/components/operators/Proximity.jsx
function Proximity_typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { Proximity_typeof = function _typeof(obj) { return typeof obj; }; } else { Proximity_typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return Proximity_typeof(obj); }

function Proximity_extends() { Proximity_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return Proximity_extends.apply(this, arguments); }

function Proximity_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Proximity_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function Proximity_createClass(Constructor, protoProps, staticProps) { if (protoProps) Proximity_defineProperties(Constructor.prototype, protoProps); if (staticProps) Proximity_defineProperties(Constructor, staticProps); return Constructor; }

function Proximity_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) Proximity_setPrototypeOf(subClass, superClass); }

function Proximity_setPrototypeOf(o, p) { Proximity_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Proximity_setPrototypeOf(o, p); }

function Proximity_createSuper(Derived) { var hasNativeReflectConstruct = Proximity_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = Proximity_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = Proximity_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return Proximity_possibleConstructorReturn(this, result); }; }

function Proximity_possibleConstructorReturn(self, call) { if (call && (Proximity_typeof(call) === "object" || typeof call === "function")) { return call; } return Proximity_assertThisInitialized(self); }

function Proximity_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function Proximity_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function Proximity_getPrototypeOf(o) { Proximity_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Proximity_getPrototypeOf(o); }





var Proximity_Proximity = /*#__PURE__*/function (_PureComponent) {
  Proximity_inherits(Proximity, _PureComponent);

  var _super = Proximity_createSuper(Proximity);

  function Proximity() {
    var _this;

    Proximity_classCallCheck(this, Proximity);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _this.handleChange = function (value) {
      _this.props.setOption("proximity", parseInt(value));
    };

    return _this;
  }

  Proximity_createClass(Proximity, [{
    key: "render",
    value: function render() {
      var _this$props = this.props,
          defaults = _this$props.defaults,
          options = _this$props.options,
          config = _this$props.config,
          optionLabel = _this$props.optionLabel,
          optionPlaceholder = _this$props.optionPlaceholder,
          customProps = _this$props.customProps,
          minProximity = _this$props.minProximity,
          maxProximity = _this$props.maxProximity,
          optionTextBefore = _this$props.optionTextBefore,
          readonly = _this$props.readonly;
      var settings = config.settings,
          widgets = config.widgets;
      var defaultProximity = defaults ? defaults.proximity : undefined;
      var showLabels = settings.showLabels;
      var selectedProximity = options.get("proximity", defaultProximity);
      var proxValues = range_default()(minProximity, maxProximity + 1).map(function (item) {
        return {
          title: item,
          value: item
        };
      });
      var Select = widgets.select.factory;
      return /*#__PURE__*/external_React_default.a.createElement("div", {
        className: "operator--PROXIMITY"
      }, /*#__PURE__*/external_React_default.a.createElement("div", {
        className: "operator--options"
      }, showLabels && /*#__PURE__*/external_React_default.a.createElement("label", {
        className: "rule--label"
      }, optionLabel), !showLabels && optionTextBefore && /*#__PURE__*/external_React_default.a.createElement("div", {
        className: "operator--options--sep"
      }, /*#__PURE__*/external_React_default.a.createElement("span", null, optionTextBefore)), /*#__PURE__*/external_React_default.a.createElement(Select, Proximity_extends({
        config: config,
        value: selectedProximity,
        listValues: proxValues,
        setValue: this.handleChange,
        readonly: readonly,
        placeholder: optionPlaceholder
      }, customProps))), /*#__PURE__*/external_React_default.a.createElement("div", {
        className: "operator--widgets"
      }, this.props.children));
    }
  }]);

  return Proximity;
}(external_React_["PureComponent"]);

Proximity_Proximity.propTypes = {
  config: prop_types_default.a.object.isRequired,
  setOption: prop_types_default.a.func.isRequired,
  options: prop_types_default.a.any.isRequired,
  //instanceOf(Immutable.Map)
  minProximity: prop_types_default.a.number,
  maxProximity: prop_types_default.a.number,
  optionPlaceholder: prop_types_default.a.string,
  optionTextBefore: prop_types_default.a.string,
  optionLabel: prop_types_default.a.string,
  customProps: prop_types_default.a.object,
  readonly: prop_types_default.a.bool //children

};
Proximity_Proximity.defaultProps = {
  customProps: {},
  minProximity: 2,
  maxProximity: 10,
  optionPlaceholder: "Select words between",
  optionLabel: "Words between",
  optionTextBefore: null
};

// CONCATENATED MODULE: ./modules/components/operators/index.js

// CONCATENATED MODULE: ./modules/utils/index.js




// CONCATENATED MODULE: ./modules/config/basic.js
function basic_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function basic_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { basic_ownKeys(Object(source), true).forEach(function (key) { basic_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { basic_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function basic_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }








var VanillaBooleanWidget = components_widgets["VanillaBooleanWidget"],
    VanillaTextWidget = components_widgets["VanillaTextWidget"],
    VanillaDateWidget = components_widgets["VanillaDateWidget"],
    VanillaTimeWidget = components_widgets["VanillaTimeWidget"],
    VanillaDateTimeWidget = components_widgets["VanillaDateTimeWidget"],
    VanillaMultiSelectWidget = components_widgets["VanillaMultiSelectWidget"],
    VanillaSelectWidget = components_widgets["VanillaSelectWidget"],
    VanillaNumberWidget = components_widgets["VanillaNumberWidget"],
    VanillaSliderWidget = components_widgets["VanillaSliderWidget"],
    ValueFieldWidget = components_widgets["ValueFieldWidget"],
    FuncWidget = components_widgets["FuncWidget"];
var ProximityOperator = Proximity_Proximity; //----------------------------  conjunctions

var basic_conjunctions = {
  AND: {
    label: "And",
    mongoConj: "$and",
    reversedConj: "OR",
    formatConj: function formatConj(children, conj, not, isForDisplay) {
      return children.size > 1 ? (not ? "NOT " : "") + "(" + children.join(" " + (isForDisplay ? "AND" : "&&") + " ") + ")" : (not ? "NOT (" : "") + children.first() + (not ? ")" : "");
    },
    sqlFormatConj: function sqlFormatConj(children, conj, not) {
      return children.size > 1 ? (not ? "NOT " : "") + "(" + children.join(" " + "AND" + " ") + ")" : (not ? "NOT (" : "") + children.first() + (not ? ")" : "");
    }
  },
  OR: {
    label: "Or",
    mongoConj: "$or",
    reversedConj: "AND",
    formatConj: function formatConj(children, conj, not, isForDisplay) {
      return children.size > 1 ? (not ? "NOT " : "") + "(" + children.join(" " + (isForDisplay ? "OR" : "||") + " ") + ")" : (not ? "NOT (" : "") + children.first() + (not ? ")" : "");
    },
    sqlFormatConj: function sqlFormatConj(children, conj, not) {
      return children.size > 1 ? (not ? "NOT " : "") + "(" + children.join(" " + "OR" + " ") + ")" : (not ? "NOT (" : "") + children.first() + (not ? ")" : "");
    }
  }
}; //----------------------------  operators
// helpers for mongo format

var mongoFormatOp1 = function mongoFormatOp1(mop, mc, not, field, _op, value, useExpr) {
  var mv = mc(value);
  if (mv === undefined) return undefined;

  if (not) {
    return !useExpr ? basic_defineProperty({}, field, {
      "$not": basic_defineProperty({}, mop, mv)
    }) : {
      "$not": basic_defineProperty({}, mop, ["$" + field, mv])
    };
  } else {
    if (!useExpr && mop == "$eq") return basic_defineProperty({}, field, mv); // short form

    return !useExpr ? basic_defineProperty({}, field, basic_defineProperty({}, mop, mv)) : basic_defineProperty({}, mop, ["$" + field, mv]);
  }
};

var mongoFormatOp2 = function mongoFormatOp2(mops, not, field, _op, values, useExpr) {
  if (not) {
    var _$not3;

    return !useExpr ? basic_defineProperty({}, field, {
      "$not": (_$not3 = {}, basic_defineProperty(_$not3, mops[0], values[0]), basic_defineProperty(_$not3, mops[1], values[1]), _$not3)
    }) : {
      "$not": {
        "$and": [basic_defineProperty({}, mops[0], ["$" + field, values[0]]), basic_defineProperty({}, mops[1], ["$" + field, values[1]])]
      }
    };
  } else {
    var _field2;

    return !useExpr ? basic_defineProperty({}, field, (_field2 = {}, basic_defineProperty(_field2, mops[0], values[0]), basic_defineProperty(_field2, mops[1], values[1]), _field2)) : {
      "$and": [basic_defineProperty({}, mops[0], ["$" + field, values[0]]), basic_defineProperty({}, mops[1], ["$" + field, values[1]])]
    };
  }
};

var basic_operators = {
  equal: {
    label: "==",
    labelForFormat: "==",
    sqlOp: "=",
    reversedOp: "not_equal",
    formatOp: function formatOp(field, op, value, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay, fieldDef) {
      if (valueTypes == "boolean" && isForDisplay) return value == "No" ? "NOT ".concat(field) : "".concat(field);else return "".concat(field, " ").concat(opDef.label, " ").concat(value);
    },
    mongoFormatOp: mongoFormatOp1.bind(null, "$eq", function (v) {
      return v;
    }, false),
    jsonLogic: "=="
  },
  not_equal: {
    label: "!=",
    labelForFormat: "!=",
    sqlOp: "<>",
    reversedOp: "equal",
    formatOp: function formatOp(field, op, value, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay, fieldDef) {
      if (valueTypes == "boolean" && isForDisplay) return value == "No" ? "".concat(field) : "NOT ".concat(field);else return "".concat(field, " ").concat(opDef.label, " ").concat(value);
    },
    mongoFormatOp: mongoFormatOp1.bind(null, "$ne", function (v) {
      return v;
    }, false),
    jsonLogic: "!="
  },
  less: {
    label: "<",
    labelForFormat: "<",
    sqlOp: "<",
    reversedOp: "greater_or_equal",
    mongoFormatOp: mongoFormatOp1.bind(null, "$lt", function (v) {
      return v;
    }, false),
    jsonLogic: "<"
  },
  less_or_equal: {
    label: "<=",
    labelForFormat: "<=",
    sqlOp: "<=",
    reversedOp: "greater",
    mongoFormatOp: mongoFormatOp1.bind(null, "$lte", function (v) {
      return v;
    }, false),
    jsonLogic: "<="
  },
  greater: {
    label: ">",
    labelForFormat: ">",
    sqlOp: ">",
    reversedOp: "less_or_equal",
    mongoFormatOp: mongoFormatOp1.bind(null, "$gt", function (v) {
      return v;
    }, false),
    jsonLogic: ">"
  },
  greater_or_equal: {
    label: ">=",
    labelForFormat: ">=",
    sqlOp: ">=",
    reversedOp: "less",
    mongoFormatOp: mongoFormatOp1.bind(null, "$gte", function (v) {
      return v;
    }, false),
    jsonLogic: ">="
  },
  like: {
    label: "Like",
    labelForFormat: "Like",
    reversedOp: "not_like",
    sqlOp: "LIKE",
    sqlFormatOp: function sqlFormatOp(field, op, values, valueSrc, valueType, opDef, operatorOptions) {
      if (valueSrc == "value") {
        return "".concat(field, " LIKE ").concat(values);
      } else return undefined; // not supported

    },
    mongoFormatOp: mongoFormatOp1.bind(null, "$regex", function (v) {
      return typeof v == "string" ? Object(stuff["d" /* escapeRegExp */])(v) : undefined;
    }, false),
    //jsonLogic: (field, op, val) => ({ "in": [val, field] }),
    jsonLogic: "in",
    _jsonLogicIsRevArgs: true,
    valueSources: ["value"]
  },
  not_like: {
    label: "Not like",
    reversedOp: "like",
    labelForFormat: "Not Like",
    sqlOp: "NOT LIKE",
    sqlFormatOp: function sqlFormatOp(field, op, values, valueSrc, valueType, opDef, operatorOptions) {
      if (valueSrc == "value") {
        return "".concat(field, " NOT LIKE ").concat(values);
      } else return undefined; // not supported

    },
    mongoFormatOp: mongoFormatOp1.bind(null, "$regex", function (v) {
      return typeof v == "string" ? Object(stuff["d" /* escapeRegExp */])(v) : undefined;
    }, true),
    valueSources: ["value"]
  },
  starts_with: {
    label: "Starts with",
    labelForFormat: "Starts with",
    sqlOp: "LIKE",
    sqlFormatOp: function sqlFormatOp(field, op, values, valueSrc, valueType, opDef, operatorOptions) {
      if (valueSrc == "value") {
        return "".concat(field, " LIKE ").concat(values);
      } else return undefined; // not supported

    },
    mongoFormatOp: mongoFormatOp1.bind(null, "$regex", function (v) {
      return typeof v == "string" ? "^" + Object(stuff["d" /* escapeRegExp */])(v) : undefined;
    }, false),
    jsonLogic: undefined,
    // not supported
    valueSources: ["value"]
  },
  ends_with: {
    label: "Ends with",
    labelForFormat: "Ends with",
    sqlOp: "LIKE",
    sqlFormatOp: function sqlFormatOp(field, op, values, valueSrc, valueType, opDef, operatorOptions) {
      if (valueSrc == "value") {
        return "".concat(field, " LIKE ").concat(values);
      } else return undefined; // not supported

    },
    mongoFormatOp: mongoFormatOp1.bind(null, "$regex", function (v) {
      return typeof v == "string" ? Object(stuff["d" /* escapeRegExp */])(v) + "$" : undefined;
    }, false),
    jsonLogic: undefined,
    // not supported
    valueSources: ["value"]
  },
  between: {
    label: "Between",
    labelForFormat: "BETWEEN",
    sqlOp: "BETWEEN",
    cardinality: 2,
    formatOp: function formatOp(field, op, values, valueSrcs, valueTypes, opDef, operatorOptions, isForDisplay) {
      var valFrom = values.first();
      var valTo = values.get(1);
      if (isForDisplay) return "".concat(field, " >= ").concat(valFrom, " AND ").concat(field, " <= ").concat(valTo);else return "".concat(field, " >= ").concat(valFrom, " && ").concat(field, " <= ").concat(valTo);
    },
    mongoFormatOp: mongoFormatOp2.bind(null, ["$gte", "$lte"], false),
    valueLabels: ["Value from", "Value to"],
    textSeparators: [null, "and"],
    reversedOp: "not_between",
    jsonLogic: "<=",
    validateValues: function validateValues(values) {
      if (values[0] != undefined && values[1] != undefined) {
        return values[0] <= values[1] ? null : "Invalid range";
      }

      return null;
    }
  },
  not_between: {
    label: "Not between",
    labelForFormat: "NOT BETWEEN",
    sqlOp: "NOT BETWEEN",
    cardinality: 2,
    mongoFormatOp: mongoFormatOp2.bind(null, ["$gte", "$lte"], true),
    valueLabels: ["Value from", "Value to"],
    textSeparators: [null, "and"],
    reversedOp: "between",
    validateValues: function validateValues(values) {
      if (values[0] != undefined && values[1] != undefined) {
        return values[0] <= values[1] ? null : "Invalid range";
      }

      return null;
    }
  },
  is_empty: {
    label: "Is empty",
    labelForFormat: "IS EMPTY",
    sqlOp: "IS EMPTY",
    cardinality: 0,
    reversedOp: "is_not_empty",
    formatOp: function formatOp(field, op, value, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
      return isForDisplay ? "".concat(field, " IS EMPTY") : "!".concat(field);
    },
    mongoFormatOp: mongoFormatOp1.bind(null, "$exists", function (v) {
      return false;
    }, false),
    jsonLogic: "!"
  },
  is_not_empty: {
    label: "Is not empty",
    labelForFormat: "IS NOT EMPTY",
    sqlOp: "IS NOT EMPTY",
    cardinality: 0,
    reversedOp: "is_empty",
    formatOp: function formatOp(field, op, value, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
      return isForDisplay ? "".concat(field, " IS NOT EMPTY") : "!!".concat(field);
    },
    mongoFormatOp: mongoFormatOp1.bind(null, "$exists", function (v) {
      return true;
    }, false),
    jsonLogic: "!!"
  },
  select_equals: {
    label: "==",
    labelForFormat: "==",
    sqlOp: "=",
    // enum/set
    formatOp: function formatOp(field, op, value, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
      return "".concat(field, " == ").concat(value);
    },
    mongoFormatOp: mongoFormatOp1.bind(null, "$eq", function (v) {
      return v;
    }, false),
    reversedOp: "select_not_equals",
    jsonLogic: "=="
  },
  select_not_equals: {
    label: "!=",
    labelForFormat: "!=",
    sqlOp: "<>",
    // enum/set
    formatOp: function formatOp(field, op, value, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
      return "".concat(field, " != ").concat(value);
    },
    mongoFormatOp: mongoFormatOp1.bind(null, "$ne", function (v) {
      return v;
    }, false),
    reversedOp: "select_equals",
    jsonLogic: "!="
  },
  select_any_in: {
    label: "Any in",
    labelForFormat: "IN",
    sqlOp: "IN",
    formatOp: function formatOp(field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
      if (valueSrc == "value") return "".concat(field, " IN (").concat(values.join(", "), ")");else return "".concat(field, " IN (").concat(values, ")");
    },
    sqlFormatOp: function sqlFormatOp(field, op, values, valueSrc, valueType, opDef, operatorOptions) {
      return "".concat(field, " IN (").concat(values.join(", "), ")");
    },
    mongoFormatOp: mongoFormatOp1.bind(null, "$in", function (v) {
      return v;
    }, false),
    reversedOp: "select_not_any_in",
    jsonLogic: "in"
  },
  select_not_any_in: {
    label: "Not in",
    labelForFormat: "NOT IN",
    sqlOp: "NOT IN",
    formatOp: function formatOp(field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
      if (valueSrc == "value") return "".concat(field, " NOT IN (").concat(values.join(", "), ")");else return "".concat(field, " NOT IN (").concat(values, ")");
    },
    sqlFormatOp: function sqlFormatOp(field, op, values, valueSrc, valueType, opDef, operatorOptions) {
      return "".concat(field, " NOT IN (").concat(values.join(", "), ")");
    },
    mongoFormatOp: mongoFormatOp1.bind(null, "$nin", function (v) {
      return v;
    }, false),
    reversedOp: "select_any_in"
  },
  multiselect_equals: {
    label: "Equals",
    labelForFormat: "==",
    sqlOp: "=",
    formatOp: function formatOp(field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
      if (valueSrc == "value") return "".concat(field, " == [").concat(values.join(", "), "]");else return "".concat(field, " == ").concat(values);
    },
    sqlFormatOp: function sqlFormatOp(field, op, values, valueSrc, valueType, opDef, operatorOptions) {
      if (valueSrc == "value") // set
        return "".concat(field, " = '").concat(values.map(function (v) {
          return SqlString.trim(v);
        }).join(","), "'");else return undefined; //not supported
    },
    mongoFormatOp: mongoFormatOp1.bind(null, "$eq", function (v) {
      return v;
    }, false),
    reversedOp: "multiselect_not_equals",
    jsonLogic2: "all-in",
    jsonLogic: function jsonLogic(field, op, vals) {
      return {
        // it's not "equals", but "includes" operator - just for example
        "all": [field, {
          "in": [{
            "var": ""
          }, vals]
        }]
      };
    }
  },
  multiselect_not_equals: {
    label: "Not equals",
    labelForFormat: "!=",
    sqlOp: "<>",
    formatOp: function formatOp(field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
      if (valueSrc == "value") return "".concat(field, " != [").concat(values.join(", "), "]");else return "".concat(field, " != ").concat(values);
    },
    sqlFormatOp: function sqlFormatOp(field, op, values, valueSrc, valueType, opDef, operatorOptions) {
      if (valueSrc == "value") // set
        return "".concat(field, " != '").concat(values.map(function (v) {
          return SqlString.trim(v);
        }).join(","), "'");else return undefined; //not supported
    },
    mongoFormatOp: mongoFormatOp1.bind(null, "$ne", function (v) {
      return v;
    }, false),
    reversedOp: "multiselect_equals"
  },
  proximity: {
    label: "Proximity search",
    cardinality: 2,
    valueLabels: [{
      label: "Word 1",
      placeholder: "Enter first word"
    }, {
      label: "Word 2",
      placeholder: "Enter second word"
    }],
    textSeparators: [//'Word 1',
      //'Word 2'
    ],
    formatOp: function formatOp(field, op, values, valueSrc, valueType, opDef, operatorOptions, isForDisplay) {
      var val1 = values.first();
      var val2 = values.get(1);
      var prox = operatorOptions.get("proximity");
      return "".concat(field, " ").concat(val1, " NEAR/").concat(prox, " ").concat(val2);
    },
    sqlFormatOp: function sqlFormatOp(field, op, values, valueSrc, valueType, opDef, operatorOptions) {
      var val1 = values.first();
      var val2 = values.get(1);

      var _val1 = SqlString.trim(val1);

      var _val2 = SqlString.trim(val2);

      var prox = operatorOptions.get("proximity");
      return "CONTAINS(".concat(field, ", 'NEAR((").concat(_val1, ", ").concat(_val2, "), ").concat(prox, ")')");
    },
    mongoFormatOp: undefined,
    // not supported
    jsonLogic: undefined,
    // not supported
    options: {
      optionLabel: "Near",
      // label on top of "near" selectbox (for config.settings.showLabels==true)
      optionTextBefore: "Near",
      // label before "near" selectbox (for config.settings.showLabels==false)
      optionPlaceholder: "Select words between",
      // placeholder for "near" selectbox
      factory: function factory(props) {
        return /*#__PURE__*/external_React_default.a.createElement(ProximityOperator, props);
      },
      minProximity: 2,
      maxProximity: 10,
      defaults: {
        proximity: 2
      }
    }
  }
}; //----------------------------  widgets

var basic_widgets = {
  text: {
    type: "text",
    jsType: "string",
    valueSrc: "value",
    valueLabel: "String",
    valuePlaceholder: "Enter string",
    factory: function factory(props) {
      return /*#__PURE__*/external_React_default.a.createElement(VanillaTextWidget, props);
    },
    formatValue: function formatValue(val, fieldDef, wgtDef, isForDisplay) {
      return isForDisplay ? '"' + val + '"' : JSON.stringify(val);
    },
    sqlFormatValue: function sqlFormatValue(val, fieldDef, wgtDef, op, opDef) {
      if (opDef.sqlOp == "LIKE" || opDef.sqlOp == "NOT LIKE") {
        return SqlString.escapeLike(val, op != "starts_with", op != "ends_with");
      } else {
        return SqlString.escape(val);
      }
    },
    toJS: function toJS(val, fieldSettings) {
      return val;
    }
  },
  number: {
    type: "number",
    jsType: "number",
    valueSrc: "value",
    factory: function factory(props) {
      return /*#__PURE__*/external_React_default.a.createElement(VanillaNumberWidget, props);
    },
    valueLabel: "Number",
    valuePlaceholder: "Enter number",
    valueLabels: [{
      label: "Number from",
      placeholder: "Enter number from"
    }, {
      label: "Number to",
      placeholder: "Enter number to"
    }],
    formatValue: function formatValue(val, fieldDef, wgtDef, isForDisplay) {
      return isForDisplay ? val : JSON.stringify(val);
    },
    sqlFormatValue: function sqlFormatValue(val, fieldDef, wgtDef, op, opDef) {
      return SqlString.escape(val);
    },
    toJS: function toJS(val, fieldSettings) {
      return val;
    }
  },
  slider: {
    type: "number",
    jsType: "number",
    valueSrc: "value",
    factory: function factory(props) {
      return /*#__PURE__*/external_React_default.a.createElement(VanillaSliderWidget, props);
    },
    valueLabel: "Number",
    valuePlaceholder: "Enter number or move slider",
    formatValue: function formatValue(val, fieldDef, wgtDef, isForDisplay) {
      return isForDisplay ? val : JSON.stringify(val);
    },
    sqlFormatValue: function sqlFormatValue(val, fieldDef, wgtDef, op, opDef) {
      return SqlString.escape(val);
    },
    toJS: function toJS(val, fieldSettings) {
      return val;
    }
  },
  select: {
    type: "select",
    jsType: "string",
    valueSrc: "value",
    factory: function factory(props) {
      return /*#__PURE__*/external_React_default.a.createElement(VanillaSelectWidget, props);
    },
    valueLabel: "Value",
    valuePlaceholder: "Select value",
    formatValue: function formatValue(val, fieldDef, wgtDef, isForDisplay) {
      var valLabel = Object(stuff["f" /* getTitleInListValues */])(fieldDef.fieldSettings.listValues, val);
      return isForDisplay ? '"' + valLabel + '"' : JSON.stringify(val);
    },
    sqlFormatValue: function sqlFormatValue(val, fieldDef, wgtDef, op, opDef) {
      return SqlString.escape(val);
    },
    toJS: function toJS(val, fieldSettings) {
      return val;
    }
  },
  multiselect: {
    type: "multiselect",
    jsType: "array",
    valueSrc: "value",
    factory: function factory(props) {
      return /*#__PURE__*/external_React_default.a.createElement(VanillaMultiSelectWidget, props);
    },
    valueLabel: "Values",
    valuePlaceholder: "Select values",
    formatValue: function formatValue(vals, fieldDef, wgtDef, isForDisplay) {
      var valsLabels = vals.map(function (v) {
        return Object(stuff["f" /* getTitleInListValues */])(fieldDef.fieldSettings.listValues, v);
      });
      return isForDisplay ? valsLabels.map(function (v) {
        return '"' + v + '"';
      }) : vals.map(function (v) {
        return JSON.stringify(v);
      });
    },
    sqlFormatValue: function sqlFormatValue(vals, fieldDef, wgtDef, op, opDef) {
      return vals.map(function (v) {
        return SqlString.escape(v);
      });
    },
    toJS: function toJS(val, fieldSettings) {
      return val;
    }
  },
  date: {
    type: "date",
    jsType: "string",
    valueSrc: "value",
    factory: function factory(props) {
      return /*#__PURE__*/external_React_default.a.createElement(VanillaDateWidget, props);
    },
    dateFormat: "DD.MM.YYYY",
    valueFormat: "YYYY-MM-DD",
    useKeyboard: true,
    valueLabel: "Date",
    valuePlaceholder: "Enter date",
    valueLabels: [{
      label: "Date from",
      placeholder: "Enter date from"
    }, {
      label: "Date to",
      placeholder: "Enter date to"
    }],
    formatValue: function formatValue(val, fieldDef, wgtDef, isForDisplay) {
      var dateVal = external_moment_default()(val, wgtDef.valueFormat);
      return isForDisplay ? '"' + dateVal.format(wgtDef.dateFormat) + '"' : JSON.stringify(val);
    },
    sqlFormatValue: function sqlFormatValue(val, fieldDef, wgtDef, op, opDef) {
      var dateVal = external_moment_default()(val, wgtDef.valueFormat);
      return SqlString.escape(dateVal.format("YYYY-MM-DD"));
    },
    jsonLogic: function jsonLogic(val, fieldDef, wgtDef) {
      return external_moment_default()(val, wgtDef.valueFormat).toDate();
    },
    toJS: function toJS(val, fieldSettings) {
      var dateVal = external_moment_default()(val, fieldSettings.valueFormat);
      return dateVal.isValid() ? dateVal.toDate() : undefined;
    }
  },
  time: {
    type: "time",
    jsType: "string",
    valueSrc: "value",
    factory: function factory(props) {
      return /*#__PURE__*/external_React_default.a.createElement(VanillaTimeWidget, props);
    },
    timeFormat: "HH:mm",
    valueFormat: "HH:mm:ss",
    use12Hours: false,
    useKeyboard: true,
    valueLabel: "Time",
    valuePlaceholder: "Enter time",
    valueLabels: [{
      label: "Time from",
      placeholder: "Enter time from"
    }, {
      label: "Time to",
      placeholder: "Enter time to"
    }],
    formatValue: function formatValue(val, fieldDef, wgtDef, isForDisplay) {
      var dateVal = external_moment_default()(val, wgtDef.valueFormat);
      return isForDisplay ? '"' + dateVal.format(wgtDef.timeFormat) + '"' : JSON.stringify(val);
    },
    sqlFormatValue: function sqlFormatValue(val, fieldDef, wgtDef, op, opDef) {
      var dateVal = external_moment_default()(val, wgtDef.valueFormat);
      return SqlString.escape(dateVal.format("HH:mm:ss"));
    },
    jsonLogic: function jsonLogic(val, fieldDef, wgtDef) {
      // return seconds of day
      var dateVal = external_moment_default()(val, wgtDef.valueFormat);
      return dateVal.get("hour") * 60 * 60 + dateVal.get("minute") * 60 + dateVal.get("second");
    },
    toJS: function toJS(val, fieldSettings) {
      // return seconds of day
      var dateVal = external_moment_default()(val, fieldSettings.valueFormat);
      return dateVal.isValid() ? dateVal.get("hour") * 60 * 60 + dateVal.get("minute") * 60 + dateVal.get("second") : undefined;
    }
  },
  datetime: {
    type: "datetime",
    jsType: "string",
    valueSrc: "value",
    factory: function factory(props) {
      return /*#__PURE__*/external_React_default.a.createElement(VanillaDateTimeWidget, props);
    },
    timeFormat: "HH:mm",
    dateFormat: "DD.MM.YYYY",
    valueFormat: "YYYY-MM-DD HH:mm:ss",
    use12Hours: false,
    useKeyboard: true,
    valueLabel: "Datetime",
    valuePlaceholder: "Enter datetime",
    valueLabels: [{
      label: "Datetime from",
      placeholder: "Enter datetime from"
    }, {
      label: "Datetime to",
      placeholder: "Enter datetime to"
    }],
    formatValue: function formatValue(val, fieldDef, wgtDef, isForDisplay) {
      var dateVal = external_moment_default()(val, wgtDef.valueFormat);
      return isForDisplay ? '"' + dateVal.format(wgtDef.dateFormat + " " + wgtDef.timeFormat) + '"' : JSON.stringify(val);
    },
    sqlFormatValue: function sqlFormatValue(val, fieldDef, wgtDef, op, opDef) {
      var dateVal = external_moment_default()(val, wgtDef.valueFormat);
      return SqlString.escape(dateVal.toDate());
    },
    jsonLogic: function jsonLogic(val, fieldDef, wgtDef) {
      return external_moment_default()(val, wgtDef.valueFormat).toDate();
    },
    toJS: function toJS(val, fieldSettings) {
      var dateVal = external_moment_default()(val, fieldSettings.valueFormat);
      return dateVal.isValid() ? dateVal.toDate() : undefined;
    }
  },
  "boolean": {
    type: "boolean",
    jsType: "boolean",
    valueSrc: "value",
    factory: function factory(props) {
      return /*#__PURE__*/external_React_default.a.createElement(VanillaBooleanWidget, props);
    },
    labelYes: "Yes",
    labelNo: "No",
    formatValue: function formatValue(val, fieldDef, wgtDef, isForDisplay) {
      return isForDisplay ? val ? "Yes" : "No" : JSON.stringify(!!val);
    },
    sqlFormatValue: function sqlFormatValue(val, fieldDef, wgtDef, op, opDef) {
      return SqlString.escape(val);
    },
    defaultValue: false,
    toJS: function toJS(val, fieldSettings) {
      return val;
    }
  },
  field: {
    valueSrc: "field",
    factory: function factory(props) {
      return /*#__PURE__*/external_React_default.a.createElement(ValueFieldWidget, props);
    },
    formatValue: function formatValue(val, fieldDef, wgtDef, isForDisplay, op, opDef, rightFieldDef) {
      return isForDisplay ? rightFieldDef.label || val : val;
    },
    sqlFormatValue: function sqlFormatValue(val, fieldDef, wgtDef, op, opDef, rightFieldDef) {
      return val;
    },
    valueLabel: "Field to compare",
    valuePlaceholder: "Select field to compare",
    customProps: {
      showSearch: true
    }
  },
  func: {
    valueSrc: "func",
    factory: function factory(props) {
      return /*#__PURE__*/external_React_default.a.createElement(FuncWidget, props);
    },
    valueLabel: "Function",
    valuePlaceholder: "Select function",
    customProps: {//showSearch: true
    }
  }
}; //----------------------------  types

var types = {
  text: {
    defaultOperator: "equal",
    widgets: {
      text: {
        operators: ["equal", "not_equal", "is_empty", "is_not_empty", "like", "not_like", "starts_with", "ends_with", "proximity"],
        widgetProps: {},
        opProps: {}
      },
      field: {
        operators: [//unary ops (like `is_empty`) will be excluded anyway, see getWidgetsForFieldOp()
        "equal", "not_equal", "proximity" //can exclude if you want
        ]
      }
    }
  },
  number: {
    defaultOperator: "equal",
    mainWidget: "number",
    widgets: {
      number: {
        operators: ["equal", "not_equal", "less", "less_or_equal", "greater", "greater_or_equal", "between", "not_between", "is_empty", "is_not_empty"]
      },
      slider: {
        operators: ["equal", "not_equal", "less", "less_or_equal", "greater", "greater_or_equal", "is_empty", "is_not_empty"]
      }
    }
  },
  date: {
    defaultOperator: "equal",
    widgets: {
      date: {
        operators: ["equal", "not_equal", "less", "less_or_equal", "greater", "greater_or_equal", "between", "not_between", "is_empty", "is_not_empty"]
      }
    }
  },
  time: {
    defaultOperator: "equal",
    widgets: {
      time: {
        operators: ["equal", "not_equal", "less", "less_or_equal", "greater", "greater_or_equal", "between", "not_between", "is_empty", "is_not_empty"]
      }
    }
  },
  datetime: {
    defaultOperator: "equal",
    widgets: {
      datetime: {
        operators: ["equal", "not_equal", "less", "less_or_equal", "greater", "greater_or_equal", "between", "not_between", "is_empty", "is_not_empty"]
      }
    }
  },
  select: {
    mainWidget: "select",
    defaultOperator: "select_equals",
    widgets: {
      select: {
        operators: ["select_equals", "select_not_equals"],
        widgetProps: {
          customProps: {
            showSearch: true
          }
        }
      },
      multiselect: {
        operators: ["select_any_in", "select_not_any_in"]
      }
    }
  },
  multiselect: {
    defaultOperator: "multiselect_equals",
    widgets: {
      multiselect: {
        operators: ["multiselect_equals", "multiselect_not_equals"]
      }
    }
  },
  "boolean": {
    defaultOperator: "equal",
    widgets: {
      "boolean": {
        operators: ["equal", "not_equal"],
        widgetProps: {//you can enable this if you don't use fields as value sources
          // hideOperator: true,
          // operatorInlineLabel: "is",
        }
      },
      field: {
        operators: ["equal", "not_equal"]
      }
    }
  }
}; //----------------------------  settings

var basic_settings = basic_objectSpread(basic_objectSpread({}, config_default["a" /* settings */]), {}, {
  formatField: function formatField(field, parts, label2, fieldDefinition, config, isForDisplay) {
    if (isForDisplay) return label2;else return field;
  },
  sqlFormatReverse: function sqlFormatReverse(q, operator, reversedOp, operatorDefinition, revOperatorDefinition) {
    if (q == undefined) return undefined;
    return "NOT(" + q + ")";
  },
  formatReverse: function formatReverse(q, operator, reversedOp, operatorDefinition, revOperatorDefinition, isForDisplay) {
    if (q == undefined) return undefined;
    if (isForDisplay) return "NOT(" + q + ")";else return "!(" + q + ")";
  },
  canCompareFieldWithField: function canCompareFieldWithField(leftField, leftFieldConfig, rightField, rightFieldConfig) {
    //for type == 'select'/'multiselect' you can check listValues
    return true;
  },
  // enable compare fields
  valueSourcesInfo: {
    value: {
      label: "Value"
    },
    field: {
      label: "Field",
      widget: "field"
    },
    func: {
      label: "Function",
      widget: "func"
    }
  },
  customFieldSelectProps: {
    showSearch: true
  }
}); //----------------------------


/* harmony default export */ var basic = ({
  conjunctions: basic_conjunctions,
  operators: basic_operators,
  widgets: basic_widgets,
  types: types,
  settings: basic_settings
});
// CONCATENATED MODULE: ./modules/index.js
function modules_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function modules_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { modules_ownKeys(Object(source), true).forEach(function (key) { modules_defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { modules_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function modules_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }









var Utils = modules_objectSpread(modules_objectSpread(modules_objectSpread({}, utils_namespaceObject), export_namespaceObject), import_namespaceObject);




/***/ })
/******/ ]);
});